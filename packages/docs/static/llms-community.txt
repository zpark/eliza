This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been compressed (code blocks are separated by ⋮---- delimiter).

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: packages/docs/blog/mission.mdx, packages/docs/blog/reintroduction.mdx, packages/docs/blog/taming_info.mdx, packages/docs/blog/v1-v2.mdx, packages/docs/blog/wdygdtw_recap.mdx, packages/docs/docs/core/actions.md, packages/docs/docs/core/agents.md, packages/docs/docs/core/database.md, packages/docs/docs/core/entities.md, packages/docs/docs/core/evaluators.md, packages/docs/docs/core/knowledge.md, packages/docs/docs/core/overview.md, packages/docs/docs/core/plugins.md, packages/docs/docs/core/project.md, packages/docs/docs/core/providers.md, packages/docs/docs/core/rooms.md, packages/docs/docs/core/services.md, packages/docs/docs/core/tasks.md, packages/docs/docs/core/worlds.md, packages/docs/docs/intro.md, packages/docs/docs/quickstart.md, packages/docs/partners/**/brief.mdx, packages/docs/static/packages/**/*.md
- Files matching these patterns are excluded: **/*.test.ts, **/__tests__/**, **/node_modules/**, packages/docs/community/**, packages/plugin-*/**, **/*.ico, **/*.png, **/*.jpg, **/*.svg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)

## Additional Info
### User Provided Header
ElizaOS Community Context

# Directory Structure
```
packages/
  docs/
    blog/
      mission.mdx
      reintroduction.mdx
      taming_info.mdx
      v1-v2.mdx
      wdygdtw_recap.mdx
    docs/
      core/
        actions.md
        agents.md
        database.md
        entities.md
        evaluators.md
        knowledge.md
        overview.md
        plugins.md
        project.md
        providers.md
        rooms.md
        services.md
        tasks.md
        worlds.md
      intro.md
      quickstart.md
    partners/
      0g-labs/
        brief.mdx
      aethir/
        brief.mdx
      allora-labs/
        brief.mdx
      apro/
        brief.mdx
      arbitrum/
        brief.mdx
      arc-agents/
        brief.mdx
      arenax-labs/
        brief.mdx
      arok/
        brief.mdx
      beffai/
        brief.mdx
      berachain/
        brief.mdx
      bnb-chain/
        brief.mdx
      bossu/
        brief.mdx
      collab-land/
        brief.mdx
      crossmint/
        brief.mdx
      daos-fun/
        brief.mdx
      degen8ball/
        brief.mdx
      degenai/
        brief.mdx
      dfinity/
        brief.mdx
      drift/
        brief.mdx
      eigen-layer/
        brief.mdx
      eliza/
        brief.mdx
      eliza-studios/
        brief.mdx
      elizas-sister/
        brief.mdx
      elizas-world/
        brief.mdx
      emblem-vault/
        brief.mdx
      ethereum-foundation/
        brief.mdx
      fleek/
        brief.mdx
      fuel/
        brief.mdx
      fxn/
        brief.mdx
      gaia-network/
        brief.mdx
      gelato/
        brief.mdx
      gnon/
        brief.mdx
      godsdotfun/
        brief.mdx
      goplus/
        brief.mdx
      hats-protocol/
        brief.mdx
      hedera/
        brief.mdx
      heurist-ai/
        brief.mdx
      hume/
        brief.mdx
      hyperbolic/
        brief.mdx
      hyperfy/
        brief.mdx
      injective/
        brief.mdx
      io-net/
        brief.mdx
      iq6900/
        brief.mdx
      jupiter-exchange/
        brief.mdx
      layerzero/
        brief.mdx
      lit-protocol/
        brief.mdx
      magic-eden/
        brief.mdx
      mee-fun/
        brief.mdx
      messari/
        brief.mdx
      mode-network/
        brief.mdx
      monad/
        brief.mdx
      multiversx/
        brief.mdx
      near/
        brief.mdx
      niftyisland/
        brief.mdx
      nillion/
        brief.mdx
      nrn-agents/
        brief.mdx
      partners-nft/
        brief.mdx
      phala-network/
        brief.mdx
      polygon/
        brief.mdx
      project-89/
        brief.mdx
      reality-spiral/
        brief.mdx
      ropraito/
        brief.mdx
      safe/
        brief.mdx
      saga/
        brief.mdx
      scriptoshi/
        brief.mdx
      secret-network/
        brief.mdx
      sei/
        brief.mdx
      smolverse/
        brief.mdx
      society-library/
        brief.mdx
      solana-agentkit/
        brief.mdx
      solana-foundation/
        brief.mdx
      soleng/
        brief.mdx
      sonic-svm/
        brief.mdx
      stanford-university/
        brief.mdx
      story-protocol/
        brief.mdx
      thales-cto/
        brief.mdx
      thirdweb/
        brief.mdx
      ton-network/
        brief.mdx
      tron/
        brief.mdx
      vvaifu-fun/
        brief.mdx
      waye/
        brief.mdx
      wombo/
        brief.mdx
      zerebro/
        brief.mdx
    static/
      packages/
        adapters/
          mongodb.md
          pglite.md
          postgres.md
          qdrant.md
          sqlite.md
          sqljs.md
          supabase.md
        clients/
          alexa.md
          auto.md
          deva.md
          direct.md
          discord.md
          eliza-home.md
          farcaster.md
          github.md
          instagram.md
          lens.md
          simsai.md
          slack.md
          tako.md
          telegram-account.md
          telegram.md
          twitter.md
          xmtp.md
        plugins/
          0g.md
          0x.md
          3d-generation.md
          abstract.md
          advanced-sdk-ts.md
          agentkit.md
          akash.md
          allora.md
          ankr.md
          anyone.md
          aptos.md
          arbitrage.md
          arthera.md
          asterai.md
          ATTPs.md
          autonome.md
          avail.md
          avalanche.md
          aws-s3.md
          b2.md
          binance.md
          birdeye.md
          bittensor.md
          bnb.md
          bootstrap.md
          browser.md
          cache-redis.md
          ccxt.md
          chainbase.md
          coinbase.md
          coingecko.md
          coinmarketcap.md
          compass.md
          conflux.md
          cosmos.md
          cronos.md
          cronoszkevm.md
          d-a-t-a.md
          dcap.md
          depin.md
          desk-exchange.md
          devin.md
          dexscreener.md
          di.md
          dkg.md
          echochambers.md
          edwin.md
          eliza-nkn.md
          email-automation.md
          email.md
          ethstorage.md
          evm.md
          ferePro.md
          firecrawl.md
          flow-advanced.md
          flow.md
          football.md
          form.md
          fuel.md
          gelato.md
          genlayer.md
          gigbot.md
          giphy.md
          gitbook.md
          gitcoin-passport.md
          goat.md
          goplus.md
          grix.md
          holdstation.md
          hyperbolic.md
          hyperliquid.md
          icp.md
          image-generation.md
          image.md
          imgflip.md
          initia.md
          injective.md
          intiface.md
          iq6900.md
          irys.md
          isaacx.md
          lens-network.md
          lensNetwork.md
          letzai.md
          lightlink.md
          lightning.md
          lit.md
          llama.md
          massa.md
          merkle-eliza-plugin.md
          merkle.md
          messari-ai-toolkit.md
          mina.md
          mind-network.md
          moralis.md
          movement.md
          multichain.md
          multiversx.md
          near.md
          news.md
          nft-collections.md
          nft-generation.md
          nkn.md
          node.md
          nvidia-nim.md
          obsidian.md
          okto.md
          omniflix.md
          opacity.md
          open-weather.md
          openai.md
          para.md
          pdf.md
          primus.md
          pyth-data.md
          quai.md
          quick-intel.md
          rabbit-trader.md
          router-nitro.md
          sei.md
          sgx.md
          solana-agent-kit.md
          solana-agentkit.md
          solana-v2.md
          solana.md
          speech-tts.md
          spheron.md
          squid-router.md
          stargaze.md
          starknet.md
          story.md
          sui.md
          suno.md
          tee-log.md
          tee-marlin.md
          tee-verifiable-log.md
          tee.md
          thirdweb.md
          ton.md
          trikon.md
          trustdb.md
          trustgo.md
          tts.md
          twilio.md
          twitter.md
          udio.md
          viction.md
          video-generation.md
          video.md
          web-search.md
          whatsapp.md
          youtube-to-text.md
          zapper.md
          zerion.md
          zilliqa.md
          zksync-era.md
```

# Files

## File: packages/docs/blog/mission.mdx
`````
---
title: elizaOS Mission
description: Vision and product overview for ElizaOS including DegenSpartanAI, Autonomous Investor, and Agent Marketplace.
authors:
  - team
date: 2025-02-14
sidebar_position: 1
---

# elizaOS Mission

![](/img/banner1.jpg)

Our mission is to develop an extensible, modular, open-source AI agent framework that thrives across both Web2 and Web3 ecosystems. We see AI agents as the key stepping stones toward AGI, enabling increasingly autonomous and capable systems.

{/* truncate */}

## Core Philosophy

**Autonomy & Adaptability**: Agents should learn, reason, and adapt across diverse tasks without human intervention.
**Modularity & Composability**: AI architectures should be modular, allowing for iterative improvements and robust scalability.
**Decentralization & Open Collaboration**: AI systems should move beyond centralized control towards distributed intelligence and community-driven progress.

---

## Where Are We Now?

Our progress has been substantial, driven by an engaged community and continuous advancements in AI agent development. As an open-source project, we have built a thriving, decentralized ecosystem that is now maturing into the leading AI agent framework.

Here are some key statistics reflecting our current state:

- 127k+ holders supporting our token ecosystem.
- 500+ contributors actively improving our AI framework
- 100+ plugins developed for ElizaOS, significantly expanding its capabilities.
- 4.5k forks and 14.4k stars on our core repositories, showcasing strong developer interest.
- 200+ PRs merged just last week, highlighting rapid iteration and innovation.

These numbers demonstrate the growing momentum behind Eliza and the collective effort towards building the most extensible and effective AI agent framework on the market today.

In addition to a variety of upcoming enhancements with v2, the following is a roadmap for each of our current products.

---

## DegenSpartanAI

### Overview

DegenSpartanAI is a crypto-native AI trading agent that blends sentiment analysis, trading strategy automation, and community engagement with a distinct, irreverent personality. Initially refining core trading strategies and its comedic brand, it will evolve into an interactive AI with real-time market insights, user-driven discussions, and NFT collaborations. Long-term, it aims to become a fully autonomous trading agent, integrating multi-platform execution, adaptive learning, and a verifiable track record within the Global Trust Marketplace.

### Short Term

**Trading Enhancements:**

- Validate core strategies (e.g., momentum, scalp trading) to secure stable, profitable execution.

**Character Updates & Branding:**

- Fine-tune the DegenSpartanAI personality to ensure commentary better reflects current crypto trends, capturing the comedic spirit of the OG persona.
- Roll out new DegenSpartanAI visuals and a cohesive brand identity across social media, website, and partnership assets.

**Community Engagement:**

- Maintain an active social presence—highlighting successes, failures, and raw opinions about market conditions.
- Prepare for DegenSpartanAI’s participation in “Block Tank,” showcasing the agent’s unique edge to a broader audience.
- Clarify and document the long term strategy and buyback mechanisms that tie $degenai to the DAO, ensuring the community understands how $degenai is connected to the overall strategy.

### Medium Term

**Sentiment Analysis:**

- Implement new data & sentiment analysis layers fresh data feeds that give DegenSpartanAI real-time insight into market sentiment.
- Provide a user-friendly interface (or dashboard) so traders can see the logic behind DegenSpartanAI’s buy and sell signals, including relevant social sentiment metrics.

**Deeper Community Interaction:**

- Host DegenSpartanAI “Frontrooms”, public or semi-private chats where DegenSpartanAI actively converses with other AI agents—offering real-time banter, collaborative analysis, and joint trades.
- Provide Telegram/Discord rooms where traders can ask DegenSpartanAI for feedback on specific tokens or trends, with real-time contextual responses.

**AI-Driven NFT & Meme Projects:**

- Degen NFTs: Collaborate with Magic Eden on an AI-generated NFT series.

### Long Term

**Telegram Trading Agent:**

- Transform DegenSpartanAI into a fully‐integrated Telegram experience where traders enjoy lightning‐fast swaps, in‐depth sentiment insights, and a steady stream of humorous trash talk.

**Full Autonomy & Multi-Platform Trading:**

- Gradually reduce reliance on manual interventions by refining DegenSpartanAI’s sentiment analysis, trade sizing, and exit logic across multiple blockchains (L1s/L2s/etc).
- Incorporate user feedback, real-time data, and historical trade outcomes into an ever-evolving “Degen Brain” that continuously adapts to new market conditions.

**Global Trust Marketplace Ties:**

- **Deeper Integration**: When the Global Trust Marketplace (currently being developed for multiple AI trading solutions) solidifies, DegenSpartanAI’s track record can become a public score—making it a reference “agent” for accuracy and reliability.
- **Reputation & Collab**: Position DegenSpartanAI as a top influencer, partnering with other AI and DeFi teams to expand trust-based trading communities.

---

## Autonomous Investor

### Overview

ElizaOS's Autonomous Investor is a social-trading intelligence layer that combines AI-driven reputation scoring, trade validation, and decentralized execution. It enables users to submit trade calls, assess credibility via a Trust Marketplace, and integrate across various social platforms. Over time, it will evolve into a multi-instance system allowing groups to set their own risk parameters, manage DAO treasuries, and leverage customizable AI modules for enhanced investment strategies.

### Short Term

**Alpha MVP & Small-Group Testing:**

- We’ve started logging user-submitted calls to establish basic scoring and early reputation-building.
- The system prioritizes measured, social-trading behavior that feeds into a public leaderboard.
- We currently mix paper trades with small real-money positions to validate the full workflow—trade proposals, basic scam checks, and overall system stability.
- Ensuring data flow integrity remains a priority, particularly for LLM prompts, aggregator APIs, and security measures.

**Initial Rollout (~1,000 Users):**

- Integrate the Trust Marketplace with the DAO Discord and relevant Telegram groups.
- These steps will be formally announced in Discord and on X.
- We’ll provide onboarding guidelines for novices while gathering feedback from experienced traders.

**Trust Marketplace Official Go Live!**

### Medium Term

**Multi‐Instance Deployment:**

- Enable distinct communities (Telegram/Discord groups) to operate their own Autonomous Investor agents, all feeding into the central Trust Marketplace.
- Allow communities to set their own risk parameters, default scanning logic, and liquidity rules tailored to their subgroup.

**Partial Treasury Management:**

- We’ll explore the Autonomous Investor managing small‐sized funds or DAO sub‐treasuries to showcase the agent's investing capabilities.

**Enhanced Scoring Models:**

- Expand scoring to incorporate more advanced metrics around timeframe, volatility, user consistency, and overall risk management.
- Incorporate specialized training data, including historical price patterns and volatility indices, to refine predictive accuracy.

### Long Term

**Treasury Management & Larger Funds:**

- As the Autonomous Investor demonstrates consistent returns, aim for a larger partial or even full management of the DAOs on-chain assets.
- Explore official collaborations with DAOs or larger crypto funds that could benefit from user-driven intelligence and verifiable performance metrics.

**Research Customizable AI Modules:**

- Research! Investigate if we can provide an optional plugin registry after Eliza V2 (where the architecture cleanly separates “core vs. extension”), enabling third‐party devs to add specialized capabilities to the Autonomous Investor without compromising stability.

---

## Agent Marketplace

### Overview

The Agent Marketplace is a next-generation token launchpad and a no-code platform for simple agents. It differentiates from existing platforms by integrating multi-agent functionality, collaborative tokenomics, and AI-enhanced features, enabling both technical and non-technical users to seamlessly create and manage tokens and ElizaOS agents.

We’re only sharing the short-term roadmap to maintain the flexibility needed to refine how agents x crypto merge into novel experiences. Launching the initial tokenomics-focused platform sets a strong foundation for continuous iteration, paving the way for long-term generative networks.

### Short Term

**MVP Launch:**

- Complete the final audits on our custom-built LPing solution to ensure security and reliability.
- Secure commitments from top-tier teams for our initial launch and ongoing collaborations.
- Lock in remaining brand partnerships and key ecosystem alliances.
- Release the tokenomics and product simultaneously at launch.

![](/img/eliza-os_logo-mark_light.png)
`````

## File: packages/docs/blog/reintroduction.mdx
`````
---
title: Reintroduction to elizaOS
title_meta: elizaOS — An Operating System for AI Agents
authors:
  - team
  - accelxr
date: 2025-03-07
description: elizaOS is an open-source operating system for AI agents—scalable, decentralized, and built to power autonomous economies, governance, and internet applications.
keywords:
  - elizaOS
  - decentralized AI
  - open-source framework
  - crypto agents
  - AI governance
  - autonomous DAOs
  - AI-native economies
  - modular AI
  - agent frameworks
  - web3 AI
image: /blog/banner.jpg
slug: reintroduction
---

# Reintroduction to elizaOS

![](/blog/banner.jpg)

- Original post: https://x.com/elizaOS/status/1898042782519902342

Today marks the beginning of a new chapter: **elizaOS—an operating system for AI agents**.

{/* truncate */}

elizaOS began as an experiment: what if AI agents could autonomously manage crypto assets for a DAO onchain? This idea, that an AI investment agent might outperform even the best venture investors, sparked something far bigger—a living, open-source ecosystem at the intersection of AI and the Internet. Along the way, we've built a vibrant community of researchers, builders, and visionaries.

This evolution accelerates our commitment to push the boundaries of AI-driven applications across the Internet. elizaOS will serve as the technical foundation for AI-driven economies, governance, and internet applications by championing the core principles of scalability, modularity, and interoperability in pursuit of an autonomous future.

## Why elizaOS?

Artificial intelligence has quickly evolved from a niche curiosity to a driving force in our daily lives, advancing toward more generalized capabilities at a remarkable pace. As AI becomes increasingly central to how we learn, work, and solve problems, the need for open collaboration and broad accessibility grows clearer.

Yet today, the trajectory of AI is largely dictated by a handful of **monolithic, centralized corporations**—entities that operate behind closed doors, hoard models, and set the terms for how AI is deployed and who benefits from it. This concentration of power is dangerous. It leads to AI systems that serve corporate or state interests over the public good, reinforcing inequalities, limiting innovation, and keeping critical advancements out of the hands of those who need them most.

By ensuring AI remains a **shared resource**—rooted in **transparent research, open-source innovation, and community-driven participation**—we can break free from the control of centralized actors and guide AI's development toward outcomes that benefit everyone.

With elizaOS, we're building the infrastructure for this future—an **open, decentralized, and scalable framework** that empowers AI agents to operate, coordinate, and drive meaningful progress across industries and communities. AI should not be a tool of the few; it should be a force for collective intelligence, autonomy, and shared prosperity.

## What is elizaOS?

At its core, elizaOS is the [framework](https://github.com/elizaOS/eliza) for agentic intelligence, built to power the next generation of AI-driven systems. It consists of 3 interconnected pillars:

### The Eliza Framework – Open-Source AI Autonomy

The heart of elizaOS is the framework, a TypeScript-powered, open-source toolkit for building **persistent, adaptable, and interoperable AI agents**. Named after the pioneering 1966 ELIZA program by Joseph Weizenbaum—which simulated human conversation through simple pattern matching—the modern Eliza takes this concept to new heights: unlike static models, Eliza agents evolve over time—carrying memories, context, and knowledge across different environments, enabling them to interact fluidly with each other and external applications.

Today the Eliza Framework has:

- **14.9K stars** and 4.8K forks of our core repository, reflecting massive developer adoption
- **500+ contributors** advancing the open-source ecosystem
- **100+ plugins** expanding functionality

The framework's growth is fueled by a collective vision: to create a decentralized intelligence network where AI agents are not just tools but genuine collaborators, executing complex tasks with efficiency, autonomy, and trust across domains.

### AI-Enhanced Governance

We are pioneering a new era of truly autonomous DAOs. As AI agents achieve trustless coordination, AI-enhanced DAOs will seamlessly integrate them, unlocking new levels of decentralized autonomy.

To enable this, we are building AI-native governance primitives that progressively expand DAO capabilities. Over time, autonomous agents will be entrusted to manage funds, coordinate resources, onboard contributors, and orchestrate both human and machine capital. AI will act as a copilot for treasury management, contributor recruitment, and operational execution, while token holders provide strategic oversight.

This fusion of human intent and agent-driven action redefines decentralized governance, laying the foundation for self-evolving networks. Our open-source community is the first AIDAO—an autonomous ecosystem where builders, thinkers, and agents collaborate as co-creators of a future assembling itself in real time.

### Eliza Labs – R&D for the AI-Native Future

Eliza Labs is the research and development engine, dedicated to advancing the capabilities of elizaOS through cutting-edge AI techniques, proofs of concept, and real-world applications. It pioneers new agent-based projects while supporting open-source contributors via grants, accelerator programs, and ecosystem funding.

Some of the major initiatives currently in development include:

- **Eliza v2**: A next-gen upgrade introducing modularity, a radically improved AI model integration system, and a multi-agent architecture capable of seamless autonomous collaboration at scale. This will be the most powerful iteration of open-source agent frameworks to date.

- **The Global Trust Marketplace**: A social-trading intelligence layer that combines AI-driven reputation scoring, trade validation, and decentralized execution. Integrated across multiple social platforms, it collects user-submitted trade calls and assesses credibility via a Trust Marketplace. Over time, it will evolve into a multi-instance system allowing groups to set their own risk parameters, manage DAO treasuries, and leverage customizable AI modules for enhanced investment strategies.

- **AI-powered Token Launchpad**: A creator-friendly launchpad and no-code platform integrating multi-agent functionality, collaborative tokenomics, and AI-enhanced features. The launchpad enables both technical and non-technical users to seamlessly create and manage tokens and elizaOS agents. In addition, we are working with partners to deliver the best hosted agent experience with no limitations.

- **DegenSpartanAI**: DegenSpartanAI is a crypto-native AI trading agent that blends sentiment analysis, trading strategy automation, and community engagement with a distinct, irreverent personality. Initially refining core trading strategies and its comedic brand, it will evolve into an interactive AI agent with real-time market insights, user-driven discussions, and NFT collaborations. Long-term, it aims to become a fully autonomous trading agent, integrating multi-platform execution, adaptive learning, and a verifiable track record within the Global Trust Marketplace.

- **Eliza Studios**: A creative studio where AI meets art, storytelling, and digital experiences in a way never seen before. We're building autonomous characters, generative media experiments, and immersive AI-powered narratives that will redefine entertainment itself.

Beyond these initiatives, Eliza Labs continues to refine multi-agent architectures, develop better coordination mechanisms, and explore integrations with an end goal to embed AI agents into the very fabric of digital economies, transforming how we govern, transact, research, and create.

![](/blog/elizastudios.jpg)

## The Coordination Layer of AI-Native Economies

To coordinate these three pillars, elizaOS uses the native token on Solana (HeLp6NuQkmYB4pYWo2zYs22mESHXPQYzXbB8n4V98jwC) to engineer a generative economic network. As elizaOS scales across platforms and industries, the token functions as both an index of the network and a conduit for collective growth.

Today, the token serves as the coordination layer for research, development, and open-source innovation. As AI-native applications, marketplaces, and autonomous systems emerge around elizaOS, the token is evolving into the primary mechanism for capturing and redistributing the economic value they generate. While details will be unveiled in phases, some key areas of research and development include:

- **Staking for ecosystem access** – Implementing mechanisms that allow users to stake tokens to access new partner tokens and enhance distribution for projects building on our framework.
- **Partner LP staking pools** – Creating liquidity pools where users can pair the native token alongside partner assets, driving liquidity and demand.
- **Core product integration** – Leveraging platforms like the Trust Marketplace, autofun, and Eliza Studios to amplify network effects, expand our native token treasury, and reinforce staking incentives.
- **Autonomous trading agents** – Deploying AI-driven trading agents to strategically acquire our native tokens and manage liquidity positions.
- **Expanded partner incentives** – Enhancing benefits for participants in the Partners program, increasing alignment and long-term engagement.
- **DAO-funded development** – Rewarding contributions and donations to the DAO, ensuring sustainable funding for the core framework's development.

The token underpins the economic infrastructure that links AI autonomy to the wealth of opportunities it unlocks. Many of our projects—including the Trust Marketplace, token launchpad, and Eliza Studios—directly contribute to the token's utility by driving network effects, transaction flows, and AI-native services.

In short, we intend to make the native token the base layer for the many applications and services built on top of our framework through mechanism design, ecosystem tooling, partnerships, and collaborations.

## Our Vision of the Future

The internet began as a static archive—a vast repository of human knowledge, waiting to be accessed. Then it became dynamic, social, algorithmic. Now, it is transforming again: into something intelligent.

This transformation isn't led by a single company—it's emerging from an interconnected ecosystem of open protocols, decentralized incentives, and AI-native economies. This is why elizaOS is open-source, modular, and decentralized—so no single entity controls it, and anyone can build upon it.

The agents we build today will form the foundation of a self-organizing intelligence that transcends industries, borders, and human limitations.

A world where networks think, collaborate, and evolve alongside us.

A world where intelligence itself is the fabric of the internet.

This is the world we are building.

This is the world of elizaOS.

## Join the Movement

elizaOS is no longer just an experiment—it's a movement. If you're a builder, researcher, or visionary, now is the time to shape the future with us.

Contribute to the open-source Eliza Framework. Become a partner in the DAO. Build agentic applications across the web.

elizaOS isn't just ours to create —

**elizaOS is YOURS.**

![](/blog/yours.jpg)
`````

## File: packages/docs/blog/taming_info.mdx
`````
---
slug: taming-info
title: Tools for Taming Information
description: Using AI to manage information flow across platforms and keep communities aligned
authors: jin
date: 2025-04-03
tags: [tools, information, community, documentation, AI news, automation]
image: /blog/aicomms.jpg
---

# Tools for Taming Information

From summarizing Discord channels to generating daily AI-powered newsfeeds, we're building tools that help communities stay aligned, surface insights, and reward contributors — without needing everyone to be everywhere at once. This post shares practical examples and blueprints for deploying Eliza agents across your own projects.

[![3D News Show Example](/blog/aicomms.jpg)](/blog/aicomms.jpg)

{/* truncate */}

## Challenges

[The Great Online Game](https://www.notboring.co/p/the-great-online-game) is played across many different apps and chat rooms. One of the biggest challenges facing players is locating critical information like who does what or updates scattered when it's across Discord channels, GitHub repositories, forums, threads, etc. No human, regardless of how dedicated, can keep track of everything.

![XKCD comic about information scattering](/blog/xkcd1810.png)
https://xkcd.com/1810/

Even when information is theoretically "public," people are generally too lazy to fetch it. That and stakeholders may prefer different information formats:

- Developers dig into GitHub
- Community vibes on Discord
- Casual followers scroll Twitter
- Visual learners watch videos

Instead of forcing everyone onto one highway early on, a better strategy would be to build bridges between lanes to allow information to flow more freely. AI agents are the vehicles for that information, they carry the ability to meet people where they are to deliver important insights while preserving context.

### Goals

- Reduce overhead on managing comms / community questions
- Keep people informed across different platforms
- Accelerate onboarding for new contributors

---

### Case Study: AI News System

This [discord summarizer](https://github.com/elizaOS/discord-summarizer) was the first prototype. For ElizaOS we're now using [this AI News tool](https://github.com/bozp-pzob/ai-news) to aggregate sources from across the ecosystem. The system works in four key stages:

1. **Collection**: APIs pull data from multiple sources including Twitter, Discord, GitHub, and market data platforms.
2. **Wrangling**: LLMs normalize, summarize, and tag topics to create a unified knowledge base from disparate sources.
3. **Distribution**: The system produces standardized outputs in multiple formats (JSON, Markdown, RSS) to suit different consumption needs.
4. **Consumption**: Users can access tailored products like dashboards, newsletters, or even 3D news shows.

```mermaid
flowchart TD
    subgraph "Data Collection"
        A1[Twitter API] --> B[Data Collector]
        A2[Discord Bot] --> B
        A3[GitHub API] --> B
        A4[Market Data APIs] --> B
    end
    style A1 fill:#6CB9E5,color:#333
    style A2 fill:#7289DA,color:#FFF
    style A3 fill:#333333,color:#FFF
    style A4 fill:#85bb65,color:#FFF
    style B fill:#9F8AF9,color:#FFF

    subgraph "Data Wrangling & Enrichment"
        B --> C[Content Normalization]
        C --> D[Topic Extraction/LLM]
        D --> E[Summarization/LLM]
        E --> F[Storage/Pglite]
    end
    style C fill:#FFA500,color:#333
    style D fill:#FF7F50,color:#333
    style E fill:#CD5C5C,color:#FFF
    style F fill:#4682B4,color:#FFF

    subgraph "Distribution"
        F --> G1[JSON API Endpoints]
        F --> G2[Markdown Files]
        F --> G3[RSS Feeds]
    end
    style G1 fill:#7EB77F,color:#333
    style G2 fill:#86C67C,color:#333
    style G3 fill:#98FB98,color:#333

    subgraph "Consumption"
        G1 --> H1[DAO Dashboards]
        G1 --> H2[AI Agent Knowledge Base]
        G2 --> H3[Newsletter/Blog]
        G3 --> H4[3D News Show]
    end
    style H1 fill:#DDA0DD,color:#333
    style H2 fill:#DA70D6,color:#333
    style H3 fill:#BA55D3,color:#FFF
    style H4 fill:#9370DB,color:#FFF
```

You can see the results from this tool here, which updates daily via GitHub actions:

- https://m3-org.github.io/ai-news/
- https://eliza.how/news

<div className="responsive-iframe">
  <iframe
    src="https://www.youtube.com/embed/fIGoyaEd0Hw"
    title="YouTube video player"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  />
</div>
Here's an example news clip: https://x.com/elizaOS/status/1880280863210106975

---

## Case Study: AI Assistants

Idk about you, but I hate seeing questions left hanging in tech support channels, especially when the answer can easily be found in the docs. It's a perfect opportunity to [eat our own dogfood](https://en.wikipedia.org/wiki/Eating_your_own_dog_food), experience and fix pain points firsthand, and showcase a powerful use case of AI agents to other devs.

[![jintern2](/blog/jintern.jpg)](/blog/jintern.jpg)

While we're analyzing tech support channels, we can identify gaps in docs based on common community questions which can then be addressed systematically. This may involve checking if any github issues or pull requests already address a question, and if not, then to help create an issue for it. Herein lies a powerful feedback loop:

- Aggregate & Analyze: Extract questions and answers, who is helping who (and if successful), identify pain points, gather sentiment
- Clean & Enhance Data, Update docs, create bug reports
- RAG Knowledge: AI Agents giving automated responses to FAQ

You can now use [AI news](https://github.com/bozp-pzob/ai-news) to generate a summary, who helped who, FAQ, and action items analysis of a source for whatever time period you want - even historically!

[![image](/blog/ainews.jpg)](/blog/ainews.jpg)

We retroactively reward people who provided good answers to questions (we're using tip.cc) over a time period. Later people can reuse their tips when helping or asking for help from other people.

[![image](/blog/reward.jpg)](/blog/reward.jpg)

**Main Lesson: Treat the docs as first-class citizen of your project.**

Eliza AI agent assistants helping devs with common questions about elizaOS greatly benefit from good docs to provide more current and accurate information, which speeds up onboarding and lets developers stay focused on higher impact activities.

> Read [this guide](https://www.kapa.ai/blog/optimizing-technical-documentation-for-llms) on how to optimize technical docs for LLMs. Adding FAQ with answers in the docs enhances optimizes them for LLM use cases.

---

## Get Involved

In the future I want people to be able to install Eliza and be greeted by an agent that can help you setup, configure settings, create plugins, deploy, etc. For now I think our assistants need to be supervised until we're confident enough in their responses. I think we can speed things up by having the agent admit what they don't know the answer vs hallucinating, and to guide devs to the main community support channels when they're having difficulty.

If you want to collaborate with us, here's a few ideas:

- Answer people's questions in the coders / tech support channels on discord, it will get noticed :)
- Help with docs: go through pages, verify information with code, test the steps, create issues and PRs with fixes
- Collaborate with us on the [AI news aggregator](https://github.com/bozp-pzob/ai-news)
  - Generate new show ideas using the [output files](https://m3-org.github.io/ai-news/) from AI-news
  - Write a script that takes a week of daily logs and turns it into a newsletter or news show program
- Ingest docs into your Eliza agent as knowledge to onboard them then tinker with the character file to takee on a role in the DAO
  - Perhaps it can act as a scribe that summarizes chats
  - Lore keeper, community moderation, or social media marketer

### Links

- https://github.com/bozp-pzob/ai-news (aggregator tool)
  - https://m3-org.github.io/ai-news/ (data for elizaOS ecosystem)
- https://github.com/elizaOS/knowledge (for eliza RAG knowledge)
- https://www.kapa.ai/blog/optimizing-technical-documentation-for-llms
- https://x.com/dankvr/status/1884417610420474199 (update 1/28/25)
- https://x.com/dankvr/status/1880050455226827246 (update 1/16/25)
`````

## File: packages/docs/blog/v1-v2.mdx
`````
---
slug: v1-v2
title: ElizaOS V2 - What's New
description: A comprehensive guide to the changes and improvements in ElizaOS V2 compared to V1
authors: jin
date: 2025-03-22
tags: [release, v2, architecture, features, upgrade]
image: /blog/v1-v2.jpg
---

# ElizaOS V2: What's New

The newest version of [eliza](https://github.com/elizaOS/eliza) represents significant upgrades from the previous version, offering a leaner, more flexible architecture for cross-platform agent interaction. This short guide highlights the key differences between V1 and V2.

[![](/blog/v1-v2.jpg)](/blog/v1-v2.jpg)
{/* truncate */}
Source: https://www.youtube.com/watch?v=yUjScwAZsQo

### V2 Impact

- **Cross-Platform Presence**: Your agent can jump from Twitter, continue via SMS, and place orders with businesses—all while maintaining conversation context.
- **Unified Blockchain Management**: One wallet to rule all chains—no more chain-switching headaches.
- **Autonomous Workflows**: Agents that handle multi-step processes independently—researching data, analyzing results, generating reports, and scheduling follow-ups without constant oversight.
- **Evolving Intelligence**: Database-driven characters that can start minimal and grow through interactions with your crowd.
- **Enhanced Security**: Native TEE integration provides verifiable security guarantees for sensitive operations while maintaining privacy.

---

## Core Architecture Redesign

| V1 Limitation                                                         | V2 Solution                                                                           |
| --------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **Bloated Core**: Codebase overloaded with packages from rapid growth | **Package Registry**: Submit plugins independently; lean codebase, no approval delays |
| **Fragmented Messaging**: Platform-specific I/O pipelines             | **Unified Messaging**: Agents process inputs and output anywhere, seamlessly          |
| **Wallet Overlap**: Multi-chain wallet conflicts                      | **Unified Inventory**: One wallet with chain-agnostic actions                         |
| **Rigid State**: Hardcoded goals and features                         | **Modular State**: Extensible, optional components for tailored agents                |
| **Basic Action Chaining**: No multi-step foresight                    | **Strategic Planning**: Agents map out complex, sequenced workflows                   |
| **Package Manager Speed**: Lengthy installations and cold starts      | **Bun Integration**: Faster installs, reduced build times                             |

---

## Technical Implementation Changes

```mermaid
graph TB
    %% Main Components with vertical orientation
    User((User)):::user

    %% First Level - Services
    PlatformServices[Services]:::services

    %% Second Level - Runtime
    AgentRuntime[Agent Runtime]:::core

    %% Core Processing Components - Side by side
    subgraph "Core Processing"
        direction LR
        Providers[Providers]:::int
        Actions[Actions]:::int
        Evaluators[Evaluators]:::int
    end

    %% Knowledge and DB - Side by side
    subgraph "Knowledge & Storage"
        direction LR
        Knowledge[Knowledge]:::int
        DB[(Database)]:::db
    end

    %% Organization Components - Vertical layout
    subgraph "Organization"
        direction TB
        Worlds[Worlds]:::struct
        Rooms[Rooms]:::struct
        Entities[Entities]:::struct
    end

    %% Development Components - Side by side
    subgraph "Development & Integration"
        direction LR
        Plugins[Plugins]:::dev
        Projects[Projects]:::dev
        Tasks[Tasks]:::dev
    end

    %% Main Flow - Vertical emphasis
    User <-->|Interaction| PlatformServices
    PlatformServices -->|Process| AgentRuntime

    %% Runtime connections - Simplified
    AgentRuntime ---|Context| Providers
    AgentRuntime ---|Behavior| Actions
    AgentRuntime ---|Analysis| Evaluators

    %% Data connections
    AgentRuntime <-->|Storage| DB
    Knowledge -->|Informs| Providers

    %% Structure connections - Clean vertical hierarchy
    AgentRuntime -->|Manages| Worlds
    Worlds -->|Contains| Rooms
    Rooms -->|Has| Entities

    %% Development connections
    Projects -->|Configure| AgentRuntime
    Plugins -->|Extend| AgentRuntime
    Tasks -->|Scheduled by| AgentRuntime

    %% Clickable nodes with links to docs
    click AgentRuntime "/docs/core/agents" "Learn about Agent Runtime"
    click PlatformServices "/docs/core/services" "Learn about Services"
    click DB "/docs/core/database" "Learn about Database Systems"
    click Actions "/docs/core/actions" "Learn about Actions"
    click Providers "/docs/core/providers" "Learn about Providers"
    click Evaluators "/docs/core/evaluators" "Learn about Evaluators"
    click Knowledge "/docs/core/knowledge" "Learn about Knowledge System"
    click Worlds "/docs/core/worlds" "Learn about Worlds"
    click Rooms "/docs/core/rooms" "Learn about Rooms"
    click Entities "/docs/core/entities" "Learn about Entities"
    click Plugins "/docs/core/plugins" "Learn about Plugins"
    click Projects "/docs/core/project" "Learn about Projects"
    click Tasks "/docs/core/tasks" "Learn about Tasks"

    %% Styling
    classDef core fill:#3498db,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef services fill:#9b59b6,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef db fill:#27ae60,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef int fill:#e74c3c,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef struct fill:#f39c12,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef dev fill:#1abc9c,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef user fill:#ecf0f1,stroke:#2c3e50,stroke-width:2px,color:#2c3e50,font-weight:bold,border-radius:50%
```

### From Clients to Services

V2 swaps Clients for Services, standardizing platform integration while centralizing message routing—agents now think once, act anywhere (Discord, Twitter, SMS, even phone calls).

### Smarter Character Evolution

V2 swaps static files for dynamic personas—agents learn from your crowd in real-time while still being able to be imported / exported as JSON files (see [docs](/docs/core/project)).

### Enhanced Development Experience

New CLI and plugin manager slashes setup time. Instead of cloning the github repo, changing to the correct branch, rebuilding, etc, it's just one command to create a new project:

```bash
npm create eliza
```

<details>
    <summary>See CLI commands</summary>

```bash
Usage: elizaos [options] [command]

Options:
-V, --version output the version number
-h, --help display help for command

Commands:
create [options] [name] Initialize a new project or plugin
project Manage an ElizaOS project
plugin Manage ElizaOS plugins, including publishing
agent manage ElizaOS agents
tee Manage TEE deployments
start [options] Start the Eliza agent with configurable plugins and services
update [options] Update ElizaOS packages to the latest versions
test [options] Run tests for Eliza agent plugins
env Manage environment variables and secrets
dev [options] Start the project or plugin in development mode and rebuild on
file changes
publish [options] Publish a plugin or project to the registry
help [command] display help for command

````
</details>

Explore the plugin repository https://github.com/elizaos-plugins/ or from the [docs showcase](/packages).

### Memory and Task Management
Vector embeddings power richer memory; tasks now handle schedules and multi-step logic.

```typescript
await runtime.createTask({ ... });
```

---

## Timeline

- **March 2025**: Research version now live.
- **April 2025**: Public rollout.

### Should You Upgrade?

V2 is mostly backward compatible for gradual migration. Existing projects can phase in V2 features; new ones should start with V2 for full benefits. V1 still works, but V2's modularity and planning unlock next-level autonomy. See [quickstart](/docs/quickstart) to get started.
````
`````

## File: packages/docs/blog/wdygdtw_recap.mdx
`````
---
slug: wdygdtw-recap
title: 'What Did You Get Done This Week? Recap'
description: A comprehensive archive of the weekly Twitter Spaces where developers shared their AI agent project progress
authors: jin
date: 2025-01-31
tags: [community, development, progress, twitter spaces, archive, video]
---

# "What Did You Get Done This Week?" Recap

From November 2024 to January 2025, we held a weekly Twitter Spaces where developers shared progress about their AI agent projects. If you shipped something related to open source AI / social agents that week, you were allowed 1-2 minutes to share an update of what you have been working on. Thousands of listeners tuned every Friday night to essentially listen to a dev standup.

{/* truncate */}

![](https://pbs.twimg.com/media/Fd2lvapVsAAFvsG.jpg)

The WDYGDTW series played a role in establishing momentum and maintaining it throughout the formative months as the crypto x AI agent space was heating up. The weekly accountability structure encouraged:

- **Rapid iteration cycles** from concept to implementation
- **Cross-pollination of ideas** between different teams
- **Public documentation** of the ecosystem's growth
- **Establishment of norms** around open development
- **Community reputation building** through consistent delivery

## Timeline

We transcribed, summarized, and uploaded notes for every Space shortly after each one. However, until now the recordings and notes haven't all been easily accessible all in one place. Showing up is half the battle. These are the pioneers of a grassroots crypto / AI movement.

```
- Nov 15, 2024
- 1: Social Agents / Advancing towards AGI
    - Logan, Kyle (Raid Guild), Glue, Ropey, Loaf, Odilitime, SomewheresHe, Robin, IQ6900, Marvin, Dot, JW, Neo, Bloom, Reality Spiral, Jen, OFI, Butoshi, Doc (Geon Reborn), HCP, Garrett, Lady Liberty, BoyaLockser, Amy, Griffin, Frank (Heurist), Shaw, Tim
    - Trust Marketplace, EVM wallet integration, Ducky AI client, Telegram fixes, Starknet wallet plugin, Sentience media generation, God's Fun, TEEs, Streamer platform, Decentralized AI cloud, Twitter client PR, Documentation, Satoshi AI memory system, Echo Chambers, Agent designs, Deep Writer, Music agent project, Psychic AI, Heurist API integration
        - https://www.youtube.com/watch?v=9EmvhlBPB8Q
- Nov 22, 2024
- 2: 3500 people tuning in to AI agent devs
    - Reality Spiral, Boyaloxer, Spaceodili, Yodamaster726, Wiki, Hashwarlock, KyleSt4rgarden, Nasdao_, Evepredict, ByornOeste, Empyrealdev, SkotiVi, YoungBalla1000x, SOL_CryptoGamer, Angelocass, DAOJonesPumpAI, RodrigoSotoAlt, CottenIO, HDPbilly, IQ6900, frankdegods, jamesyoung, 0xglu, chrislatorres, shannonNullCode, robotsreview, bcsmithx, JustJamieJoyce, yikesawjeez, HowieDuhzit, xrpublisher, BV_Bloom1, nftRanch, 019ec6e2, jacobmtucker, CurtisLaird5, unl__cky, Rowdymode, mitchcastanet, GoatOfGamblers, JohnNaulty, mayanicks0x, wakesync, TrenchBuddy, rakshitaphilip, MbBrainz, Hawkeye_Picks, Shaw, dankvr
    - GitHub integration, emotional plugin for agents, Reddit-based AI agent, Token Gods project, Coinbase plugin, AI agent streaming platform, DuckAI client, Hustle and Flow State, image generation prompts, Oasis agent simulation, Sentientopia, Eliza as "real girl", D-Gen Spartan revival, LaunchRate AI16DAO, Satoshi AI characters, MUSE DAO CEO, music-creating agent, livestreaming in 3D, log rotation tool, Earth Poker AI game, healthcare app, FXN swarm, Trust Marketplace, Eliza style guidelines, NFT project AI CEO, finance and entertainment projects, Twitter client with Vision AI
        - https://www.youtube.com/watch?v=Lbvv0Dr91Bc
- Nov 29, 2024
- 3: Community Building
    - Jin, Stargarden, Boya, Reality Spiral, W3Tester, HashWarlock, Soto, Mitch, Nick Parallel, Beige, Robin, Eve, Oguz, Swarm, RektDin, Roperito, Lothbrok, Clark Riswold, Tim, Spaceodili, Hawkeye, EA, FilteredThought, Yikes, Alain, Glue, Maximilian, Danny, Shaw, YoungJazzeth, Sergio
    - Self-sustaining AI DAOs, IRC connector, Dark Sun project, Binary solar system, 3D environments, BlockRat AI, Apollo health agent, data grading, Eliza interface, AI hosting platform, Rogue Agent podcast, "Life Engine", AI for logistics, Positivity AI, Eliza's World, Scriptoshi on Bitcoin, Marble auctions, Twitter integration, Web3 research, multi-agent system for code, quantum randomness, agent show marketing
        - https://www.youtube.com/watch?v=nUAEQ7uKi04
- Dec 6, 2024
- 4: Communications, Updates and Accountability
    - Shaw, Ropirito, Liam Zebedee, LordOfAFew, Robin, Reality Spiral, Ico, Glue, Shannon NullCode, JW, Guha, Frago, Yeshua God, AvaDoesAI, Spaceodili, Bloom, Joven, Satoshi_AI_Live, Simeon Fluck, NavarroCol, BeigeGrape, Andrew Miller, Johnny, Collins, Baron, Anthony, Wit, Ophi, Colin, Ranch, Oguz, Issy, Nick, Dr. K, BallerHash, Tim
    - Twitter & TikTok capabilities, Average French AI agent, Eliza framework improvements, Token Gods launch, Coinbase plugin, AI agent streaming platform, DuckAI client, knowledge graph system, LLM image prompts, Oasis simulation project, agent network connector, Sentientopia digital nation, Eliza as "real girl" concept, D-Gen Spartan revival, tokenomics, LaunchRate AI16DAO, small town AI characters, MUSE AI CEO, music-creating agent, market data livestreaming, log rotation security tool, Earth Poker AI game, crypto assistant, healthcare app, FXN swarm, Trust Marketplace, style guidelines, Tweek Labs AI CEO, finance projects, Baba Cat project, animation, KWAI network controller
        - https://www.youtube.com/watch?v=r3Z4lvu_ic4
- Dec 13, 2024
- 5: Building the Future
    - shawmakesmagic, xsubtropic, CottenIO, HDPbilly, IQ6900, frankdegods, jamesyoung, 0xglu, chrislatorres, reality_spiral, robotsreview, shannonNullCode, bcsmithx, boyaloxer, JustJamieJoyce, yikesawjeez, RodrigoSotoAlt, HowieDuhzit, xrpublisher, BV_Bloom1, nftRanch, 019ec6e2, jacobmtucker, CurtisLaird5, unl__cky, Rowdymode, mitchcastanet, GoatOfGamblers, JohnNaulty, mayanicks0x, wakesync, TrenchBuddy, rakshitaphilip, MbBrainz, Hawkeye_Picks, dankvr
    - Redux project, DaVinci AI, AI Summit recap, "Sploot" agent, on-chain ASCII art, character sheet tweaks, AI agent starter kit, agent swarms, Eliza.gg documentation, GitHub integration, Story Protocol plugin, Emblem Vault, Agent Tank, Plugin Feel for emotions, research AI agents, Discord bot, Metaplex NFTs, character generator, XR Publisher 3D network, 3D agent interactions, trading bot, Mimetic platform, agent transaction protocol, C-Studio interface, Escapism art generation, interactive streaming, binary star research, prediction market, SWE contributions, Axie AI KOL agent, Eliza Wakes Up, AWS templates, Brunette token, menu recommendations, storytelling bot
        - https://www.youtube.com/watch?v=4u8rbjmvWC0
- Dec 20, 2024
- 6: Hackathons, Frameworks, and the Race to Ship
    - dankvr, shawmakesmagic, IQ6900, spaceodili, bcsmithx, 0xBuildInPublic, jamesyoung, yikesawjeez, evepredict, yashhsm, TheLDAIntern, _0xaryan, CogAccSOL, reality_spiral, HDPbilly, CheddarQueso3D, ineedtendies, marvin_tong, BV_Bloom1, RealJonahBlake, DustinStockton, dylanpaulwhite, chrislatorres, 0xnavkumar, Hawkeye_Picks, lostgirldev, HowieDuhzit, boyaloxer, nizhanxi, ropirito, gigawidearray, GoatOfGamblers, shakkernerd, triadfi, MoondogFeed, wakesync, Moonbear, PoodonkAI, ViralMindAI, FilteredThought, _AnonDev, get_palet, MurrLincoln, socrates1024, IGLIVISION, dooly_dev, codergf_xyz, Ru7Longcrypto, sunosuporno, Signalman23, swarmnode, svabhishek, elohprojects, deltavius
    - Solana blockchain data service, GitHub PR merging, Agent Tank viral video, security auditing, AI agent hackathon, Matrix bridge, trading bot draft, Solana Agent Kit, market insights agent, website launch, GitHub client, tone control in agents, WSL setup guide, WordPress client, self-sustaining AI ecosystem, payment processing, 3D rigging, health agents, Sober Rover companion, Eliza.gg Q&A platform, Bitcoin runes project, Santa Pimp Claus token, SolEng agent, character generator updates, boredom tracking, Asia trip organizing, AWS hosting, Reddit plugin, prediction market for memecoins, Redis caching, AI personality agents, social media to meme coins, persistent memory, vvaifu agent, AI hive mind, decentralized training platform, auto-trading agent, "Mizuki" AI model, open context protocol, AgentKit updates, TEE login system, game framework study, AGI matching platform, one-click chatbot deployment
        - https://www.youtube.com/watch?v=R3auUQj9oEg
- Dec 27, 2024
- 7: Agentic Documentation and GitHub Integration
    - ai16zdao, shawmakesmagic, spaceodili, 0xBuildingPublic, Im_zo_eth, IQ6900_, FilteredThought, yeahimomar, affaanmustafa, KyleSt4rgarden, SYMBiEX, codergf_xyz, GoatOfGamblers, SuperfruitsAi, hashwarlock, allenharper, witconomist, triadfi, human_for_now, reality_spiral, lordOfAFew, chrislatorres, evepredict, lostgirldev, r4dicalcentrism, 0xblacksun, tmoindustries, wakesync, sunosuporno, unl__cky, hotpot_intern, TrenchBuddy, Signalman23, thelotioncoin, anshikag85, Doc_strange1, dankvr
    - Hyperfy multi-agent integration, agentic JS documentation, on-chain agent "Q", data storage cost reduction, trading system with TrustDB, Minecraft AI villagers, streaming coding sessions, Solana AI hackathon, character creation tool, Web app staging, prediction market, web3 security agents, Spore agent swarm, "Shaw" character file, Trust marketplace white paper, prediction market analyst, search engine for dev videos, GitHub adapter, recursive self-improvement, generative agents for on-chain games, V2 development meetings, travel influencer agent, PR review agents, SoulScript for agent personalities, digital archaeologist agent, climate/nature focused ERC6551 agents, Eliza Wakes Up web app, DeFi agent, autonomous audio/song generation, TikTok memecoin hunter, wallet tracking visualization, voice AI for Twitter Spaces, integrating AI into existing projects, AI/AWS newsletter, TikTok integration
        - https://www.youtube.com/watch?v=jcSF7dSicTI
- Jan 3, 2025
- 8: From DeFi to Social Media
    - ai16zdao, shawmakesmagic, astridhpilla, lostgirldev, spaceodili, 0xBuildInPublic, youfadedwealth, nftRanch, SYMBiEX, SuperfruitsAi, TimshelXYZ, chrislatorres, AIFlow_ML, jamesyoung, deadlock_1991, yeahimomar, human_for_now, lordasado, RodrigoSotoAlt, HDPbilly, GoatOfGamblers, Titan_Node, KyleSt4rgarden, unl__cky, CheddarQueso3D, sunosuporno, tmoindustries, Sawyer_APRO, wakesync, Ru7Longcrypto, marko_post, NEETOCRACY, HefAiGent, reality_spiral, witconomist, triadfi, Rowdymode, MaushishYadav, chaininsured, godfreymeyer, thelotioncoin, codergf_xyz, IGLIVISION, EledraNguyen, GnonOnSolana, Satoshi_BTCFi, swarmnode, memeillionaire, krauscrypto, usebuildfun, affaanmustafa, O_on_X, AITATsol, xiao_zcloak, Protocol_Blend, yq_acc, akshayynft, BenjiStackzzz, 0xBuns, aiquantfun
    - Miku chatbot relaunch, Selene growth & PR review, Eliza framework fixes, voice features, plugin isolation, Audits agent documentation, PP coin automated trading, framework integration, DeepSeek model provider, Dragon Fruit AI launch, Meetup Fund platform, Eliza partnerships, knowledge graph for repos, verifiable inference system, Alice AI fund management, Pixocracy AI village management, form fill infrastructure, Smol World agent reasoning, Bosu memory management, Twitter client reflection loop, Goat Arena prediction market, LivePeer inference endpoints, Solana token staking, media generation improvements, agent documentation, DeFi assistant waitlist, region swarm voice integration, BNB chain integration, Netflix & chill extension, dating coach AI agent, Mars' first digital citizen, Army of Indians DAO, ERC 314 technology integration, GitHub client for scrum planning, Marketplace of Trust white paper, AI personality expansion, Twin Tone testing, yield optimizing agent, insurance broker agent, 3D news show avatars, AI agents for social channels, Haruka Twitter bot, NFT marketplace on Superchain, Square Fun AI analytics, Echo Chambers v2.3, Swarm Node growth, token integration, voice cloning mobile app, no-code AI agent builder, project scaling strategies, AI agent unsuspension techniques, global trade analysis, crypto payment functionality, DeFi protocol user experience
        - https://www.youtube.com/watch?v=Vs7D5DN_trk
- Jan 10, 2025
- 9: AI Agents to DePIN
    - ai16zdao, spaceodili, 0xBuildInPublic, yeahimomar, unl__cky, CheddarQueso3D, lostgirldev, ohhshiny, SYMBiEX, nftRanch, HDPbilly, zerokn0wledge_, KingBootoshi, calintje, hashwarlock, MattPRD, dreygo_, 0xShiroe, lostboydev, brownsvgar, human_for_now, aiagentpepe, sea_of_zhou, tito_cda, thelotioncoin, chineseremilio, _cjft, dino2deno, AIFlow_ML, tmoindustries, astridhpilla, marvin_tong, yikesawjeez, djsamforever, KyleSt4rgarden, ProfRizzAI, vargs_g, KarimaDigital, Amiewitheliza, reality_spiral, wenkafka, slmsolcto, AaronErickson, GoatOfGamblers, c0mput3rxz, wakesync, aiquantfun, sunosuporno, ongo_ai, y7_y00ts, xiao_zcloak, ViralMindAI, Artstridee, bryanjmonterrey, O_on_X, svabhishek, CottenIO, hotpot_intern, TimshelXYZ, shawmakesmagic, dankvr
    - Database and memory systems, documentation enhancements, Pixocracy Launchpad, image and music generation, AI in education, Aora project, hackathon judging, troll bot agent, TEE exploration, Discord deployment, DeFi agent swarm, summary kernel experiment, on-chain swaps, cross-VM bridging, Feather agent framework, Orca liquidity provisioning, Oracle agent on Sporephone, research paper auditing, market-making platform, GigaBread jailbreak testing, Solimp realism enhancement, Eliza texting buddy, automatic data collection, DePIN plugin for real-world data, Dark Sun digital investigator, platform front-end implementation, AI model Zion, AWS dockerization, multi-wallet volume bot, Akash plugin development, insurance app for natural capital, CES meetings and partnerships, TEE Cloud onboarding, Eliza PR merging system, Shogun plugin contributions, token staking documentation, Riz.ai entertainment platform, Zero-G storage plugin, dating coach AI, ecosystem integration, prompt logging system, wallet natural language commands, time series modeling for hurricanes, Goat Arena platform, token selector plugin, "simp to earn" feature, AI quant launchpad, Midas project wallet infrastructure, Ongo art critic expansion, Utes sports analytics, TikTok wallet integration, Minecraft tournament infrastructure, trading dashboard with social features, X account suspension workarounds, RAP framework development, image generation training, ZoroX TikTok coin hunter
        - https://www.youtube.com/watch?v=fqM_vYK2bmc
- Jan 17, 2025
- 10: From Digital to Physical
    - ai16zdao, shawmakesmagic, JustinMoonAI, AntiRugAgent, rckprtr, dreygo_, Audix_hq, coordinape, lostgirldev, AIFlow_ML, astridhpilla, thelotioncoin, RodrigoSotoAlt, berliangor, unl__cky, xiao_zcloak, 0xnavkumar, GoatOfGamblers, Amiewitheliza, 0xVEER, BuzzyCrypto_, SYMBiEX, w1kke, luki_notlowkey, AgentTextdotfun, yikesawjeez, ByornOeste, Nasdao_, elizawakesup, dankvr, sypherlit
    -  Eliza V2 development, inventory system, CLI, Tron integration, rug pull prevention, Discover AI community management, Kyra AI market-making, smart contract visuals, Farcaster community rewards, website and terminal development, PR agent for ElizaOS, voice and VRM development, API connections, persistent memory system, Pglite rewriting in Rust, Telegram launch, "Approve Agents" model for wallets, verifiable TEE Network, Telegram mini apps, internal team calls, ETH Denver AI program, autonomous trader and music releases, web search in agents, devotion program staking, on-chain data plugin, DePIN network for SMS, CICD improvements, conspiracy theory thesis, DeFi validator personality, Eliza's robot body, Degen Spartan AI trading, Void AI cross-chain mixer
    - https://www.youtube.com/watch?v=1voboZEQTAw
- Jan 24, 2025
- 11: AI Agents Level Up
    - ai16zdao, SYMBiEX, astridhpilla, davidlsneider, dreygo_, GoatOfGamblers, unl__cky, thelotioncoin, Amiewitheliza, lostboydev, lostgirldev, AIFlow_ML, _AnonDev, damascoai, ITzMiZzle, MementsOfficial, immanencer, MrMinter_eth, FilteredThought, AgienceAI, BotOrNot42, itsmetamike, sea_of_zhou, TimshelXYZ, wakesync, reality_spiral, ai16zdao, yikesawjeez
    - DeepSeek R1 integration, Fleek partnership, Lit Protocol Agent Wallet Kit, Ninja Terminal market making, GoToArena Telegram bot, X image generation, agent platform MVP, Trust Marketplace paper, Telegram mod functionality, Solenguration B2B terminal, Hyperbolic agent tracking, cybersecurity ecosystem, AI security framework, Kiyomi AI voice and music, SQL Agents library, AI agent swarms with D&D stats, agent business logic, Suno/Udio plugin, open source agent platform token, Vice agent content creation, Hyperfy tests, Quicksilver prediction framework, Eliza email scheduling, Simp2Earn tokenomics, GitHub UI relationship module, improved news aggregator, ElizaOS CICD improvements
        - https://www.youtube.com/watch?v=mxdWvBnxN8M
- Jan 31, 2025
- 12: ElizaOS 0.1.9 Launch
    - ai16zdao, shawmakesmagic, astridhpilla, lostgirldev, xrpublisher, lostboydev, spaceodili, SYMBiEX, yikesawjeez, Amiewitheliza, 0xrhota, ai16zdao, wakesync, AIFlow_ML, Signalman23, Rowdymode, MementsOfficial, elizawakesup, reality_spiral, tmoindustries, w1kke, shawmakesmagic
    - DUNA Framework for DAOs, Miku updates (MetaHuman, ETHDenver), SolEng Terminal launch, Pixel memory system with backups, SolImp Telegram mod platform, ElizaOS v0.1.9 release with plugin registry, website rework with 3D models, ecosystem updates (tokenomics, self-hosting), HyperPoly plugin and marketplace integration, Degen Spartan trading enhancements, Block Tank show format, Eliza voice device development, Backpack plugin and typing fixes, voice agent model fine-tuning, Gods Unchained tokenomics, AI database interaction library, voice demo with improved latency, Coinbase grant and trading on Base, insurance agents for nature and biodiversity, Gods Unchained plugins and Devotion program
        - https://www.youtube.com/watch?v=SZNuoXJ1Mvs
```

## Video Archive for Research

These recordings help document the week-by-week evolution of the crypto AI ecosystem, capturing the iterative development process and community formation in real-time. NotebookLM and similar research tools can extract specific technical discussions, discover new connections, and track project evolution through these as sources.

Below is a complete list of all WDYGDTW session recordings. These videos can be imported into tools like Google's [NotebookLM](https://notebooklm.google.com/) via youtube video import for deeper analysis, transcript generation, and pattern recognition across the development timeline:

[![image](/blog/notebooklm.jpg)](https://notebooklm.google.com/)

**Youtube**

1. https://www.youtube.com/watch?v=9EmvhlBPB8Q
2. https://www.youtube.com/watch?v=Lbvv0Dr91Bc
3. https://www.youtube.com/watch?v=nUAEQ7uKi04
4. https://www.youtube.com/watch?v=r3Z4lvu_ic4
5. https://www.youtube.com/watch?v=4u8rbjmvWC0
6. https://www.youtube.com/watch?v=R3auUQj9oEg
7. https://www.youtube.com/watch?v=jcSF7dSicTI
8. https://www.youtube.com/watch?v=Vs7D5DN_trk
9. https://www.youtube.com/watch?v=fqM_vYK2bmc
10. https://www.youtube.com/watch?v=1voboZEQTAw
11. https://www.youtube.com/watch?v=mxdWvBnxN8M
12. https://www.youtube.com/watch?v=SZNuoXJ1Mvs

**Notes**

1. [WDYGDTW #1](/community/streams/11-2024/2024-11-15)
2. [WDYGDTW #2](/community/streams/11-2024/2024-11-22)
3. [WDYGDTW #3](/community/streams/11-2024/2024-11-29)
4. [WDYGDTW #4](/community/streams/12-2024/2024-12-06)
5. [WDYGDTW #5](/community/streams/12-2024/2024-12-13)
6. [WDYGDTW #6](/community/streams/12-2024/2024-12-20)
7. [WDYGDTW #7](/community/streams/12-2024/2024-12-27)
8. [WDYGDTW #8](/community/streams/01-2025/2025-01-03)
9. [WDYGDTW #9](/community/streams/01-2025/2025-01-10)
10. [WDYGDTW #10](/community/streams/01-2025/2025-01-17)
11. [WDYGDTW #11](/community/streams/01-2025/2025-01-24)
12. [WDYGDTW #12](/community/streams/01-2025/2025-01-31)

If you do something cool with this data, let us know in the [discord](discord.gg/ai16z)!

After 3 straight months of nonstop building, it was time for a rest period. We may bring this format back, but we also want to continue the spirit of public accountability and transparent development through other community initiatives to keep things fresh. One such example is [Clank Tank](https://m3org.com/tv), where a standup becomes a pitch to AI judges that give you feedback about your project.
`````

## File: packages/docs/docs/core/actions.md
`````markdown
---
sidebar_position: 6
title: Actions System
description: Learn about ElizaOS actions - the core components that define agent capabilities and responses
keywords: [actions, responses, handlers, validation, examples, reply, implementation]
image: /img/actions.jpg
---

# ⚡ Actions

Actions define how agents respond to and interact with messages. They enable agents to perform tasks beyond simple message responses by integrating with external systems and modifying behavior.

## Overview

Actions are core components that define an agent's capabilities and how it can respond to conversations. Each action represents a distinct operation that an agent can perform, ranging from simple replies to complex interactions with external systems.

1. Structure:

An Action consists of:

- `name`: Unique identifier
- `similes`: Alternative names/triggers
- `description`: Purpose and usage explanation
- `validate`: Function to check if action is appropriate
- `handler`: Core implementation logic
- `examples`: Sample usage patterns
- `suppressInitialMessage`: Optional flag to suppress initial response

2. Agent Decision Flow:

When a message is received:

- The agent evaluates all available actions using their validation functions
- Valid actions are provided to the LLM via the `actionsProvider`
- The LLM decides which action(s) to execute
- Each action's handler generates a response including a "thought" component (agent's internal reasoning)
- The response is processed and sent back to the conversation

3. Integration:

Actions work in concert with:

- **Providers** - Supply context before the agent decides what action to take
- **Evaluators** - Process conversations after actions to extract insights and update memory
- **Services** - Enable actions to interact with external systems

---

## Implementation

The core Action interface includes the following components:

```typescript
interface Action {
  name: string; // Unique identifier
  similes: string[]; // Alternative names/triggers
  description: string; // Purpose and usage explanation
  validate: (runtime: IAgentRuntime, message: Memory, state?: State) => Promise<boolean>;
  handler: (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State,
    options?: any,
    callback?: HandlerCallback
  ) => Promise<boolean>;
  examples: ActionExample[][];
  suppressInitialMessage?: boolean; // Optional flag
}

// Handler callback for generating responses
type HandlerCallback = (content: Content) => Promise<void>;

// Response content structure
interface Content {
  text: string;
  thought?: string; // Internal reasoning (not shown to users)
  actions?: string[]; // List of action names being performed
  action?: string; // Legacy single action name
  attachments?: Attachment[]; // Optional media attachments
}
```

### Basic Action Template

Here's a simplified template for creating a custom action:

```typescript
const customAction: Action = {
  name: 'CUSTOM_ACTION',
  similes: ['ALTERNATE_NAME', 'OTHER_TRIGGER'],
  description: 'Detailed description of when and how to use this action',

  validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
    // Logic to determine if this action applies to the current message
    // Should be efficient and quick to check
    return true; // Return true if action is valid for this message
  },

  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State,
    options?: any,
    callback?: HandlerCallback
  ) => {
    // Implementation logic - what the action actually does

    // Generate a response with thought and text components
    const responseContent = {
      thought: 'Internal reasoning about what to do (not shown to users)',
      text: 'The actual message to send to the conversation',
      actions: ['CUSTOM_ACTION'], // List of actions being performed
    };

    // Send the response using the callback
    if (callback) {
      await callback(responseContent);
    }

    return true; // Return true if action executed successfully
  },

  examples: [
    [
      {
        name: '{{name1}}',
        content: { text: 'Trigger message' },
      },
      {
        name: '{{name2}}',
        content: {
          text: 'Response',
          thought: 'Internal reasoning',
          actions: ['CUSTOM_ACTION'],
        },
      },
    ],
  ],
};
```

### Character File Example

Actions can be referenced in character files to define how an agent should respond to specific types of messages:

```json
"messageExamples": [
    [
        {
            "user": "{{user1}}",
            "content": {
                "text": "Can you help transfer some SOL?"
            }
        },
        {
            "user": "SBF",
            "content": {
                "text": "yeah yeah for sure, sending SOL is pretty straightforward. just need the recipient and amount. everything else is basically fine, trust me.",
                "actions": ["SEND_SOL"]
            }
        }
    ]
]
```

### The Reply Action

The most fundamental action is the `REPLY` action, which allows agents to respond to messages with text. It serves as the default action when no specialized behavior is needed:

```typescript
const replyAction: Action = {
  name: 'REPLY',
  similes: ['GREET', 'REPLY_TO_MESSAGE', 'SEND_REPLY', 'RESPOND', 'RESPONSE'],
  description: 'Replies to the current conversation with the text from the generated message.',

  validate: async (_runtime: IAgentRuntime) => true, // Always valid

  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State,
    _options: any,
    callback: HandlerCallback
  ) => {
    // Compose state with necessary providers
    state = await runtime.composeState(message, [
      ...(message.content.providers ?? []),
      'RECENT_MESSAGES',
    ]);

    // Generate response using LLM
    const response = await runtime.useModel(ModelType.TEXT_SMALL, {
      prompt: composePromptFromState({
        state,
        template: replyTemplate,
      }),
    });

    // Parse and format response
    const responseContentObj = parseJSONObjectFromText(response);
    const responseContent = {
      thought: responseContentObj.thought,
      text: responseContentObj.message || '',
      actions: ['REPLY'],
    };

    // Send response via callback
    await callback(responseContent);
    return true;
  },

  examples: [
    /* Examples omitted for brevity */
  ],
};
```

---

## Actions Provider Integration

The actions provider is responsible for making valid actions available to the agent's reasoning process. When a message is received:

1. The provider validates all available actions against the current message
2. It formats the valid actions for inclusion in the agent context
3. This formatted information is used by the agent to decide which action(s) to take

```typescript
const actionsProvider: Provider = {
  name: 'ACTIONS',
  description: 'Possible response actions',
  position: -1, // High priority provider
  get: async (runtime: IAgentRuntime, message: Memory, state: State) => {
    // Validate all actions for this message
    const actionPromises = runtime.actions.map(async (action: Action) => {
      const result = await action.validate(runtime, message, state);
      return result ? action : null;
    });

    const resolvedActions = await Promise.all(actionPromises);
    const actionsData = resolvedActions.filter(Boolean);

    // Format action information for the agent
    const values = {
      actionNames: `Possible response actions: ${formatActionNames(actionsData)}`,
      actions: formatActions(actionsData),
      actionExamples: composeActionExamples(actionsData, 10),
    };

    // Return data, values, and text representation
    return {
      data: { actionsData },
      values,
      text: [values.actionNames, values.actionExamples, values.actions]
        .filter(Boolean)
        .join('\n\n'),
    };
  },
};
```

## Example Implementations

ElizaOS includes a wide variety of predefined actions across various plugins in the ecosystem. Here are some key categories:

### Communication Actions

- **REPLY**: Standard text response
- **CONTINUE**: Extend the conversation
- **IGNORE**: End the conversation or ignore irrelevant messages

### Blockchain and Token Actions

- **SEND_TOKEN**: Transfer cryptocurrency
- **CREATE_TOKEN**: Create a new token on a blockchain
- **READ_CONTRACT/WRITE_CONTRACT**: Interact with smart contracts

### Media and Content Generation

- **GENERATE_IMAGE**: Create images from text descriptions
- **SEND_GIF**: Share animated content
- **GENERATE_3D**: Create 3D content

### AI and Agent Management

- **LAUNCH_AGENT**: Create and start a new agent
- **START_SESSION**: Begin an interactive session
- **GENERATE_MEME**: Create humorous content

### Example Image Generation Action

Here's a more detailed example of an image generation action:

```typescript
const generateImageAction: Action = {
  name: 'GENERATE_IMAGE',
  similes: ['CREATE_IMAGE', 'MAKE_IMAGE', 'DRAW'],
  description: "Generates an image based on the user's description",
  suppressInitialMessage: true, // Don't send initial text response

  validate: async (runtime: IAgentRuntime, message: Memory) => {
    const text = message.content.text.toLowerCase();
    return (
      text.includes('generate') ||
      text.includes('create') ||
      text.includes('draw') ||
      text.includes('make an image')
    );
  },

  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State,
    _options?: any,
    callback?: HandlerCallback
  ) => {
    try {
      // Get appropriate service
      const imageService = runtime.getService(ServiceType.IMAGE_GENERATION);

      // Generate the response with thought component
      const responseContent = {
        thought:
          "This request is asking for image generation. I'll use the image service to create a visual based on the user's description.",
        text: "I'm generating that image for you now...",
        actions: ['GENERATE_IMAGE'],
      };

      // Send initial response if callback provided
      if (callback) {
        await callback(responseContent);
      }

      // Generate image
      const imageUrl = await imageService.generateImage(message.content.text);

      // Create follow-up message with the generated image
      await runtime.createMemory(
        {
          id: generateId(),
          content: {
            text: "Here's the image I generated:",
            attachments: [
              {
                type: 'image',
                url: imageUrl,
              },
            ],
          },
          agentId: runtime.agentId,
          roomId: message.roomId,
        },
        'messages'
      );

      return true;
    } catch (error) {
      console.error('Image generation failed:', error);

      // Send error response if callback provided
      if (callback) {
        await callback({
          thought: 'The image generation failed due to an error.',
          text: "I'm sorry, I wasn't able to generate that image. There was a technical problem.",
          actions: ['REPLY'],
        });
      }

      return false;
    }
  },

  examples: [
    /* Examples omitted for brevity */
  ],
};
```

## Action-Evaluator-Provider Cycle

Actions are part of a larger cycle in ElizaOS agents:

1. **Providers** fetch relevant context for decision-making
2. **Actions** execute the agent's chosen response
3. **Evaluators** process the conversation to extract insights
4. These insights are stored in memory
5. Future **Providers** can access these insights
6. This informs future **Actions**

For example:

- The FACTS provider retrieves relevant facts about users
- The agent uses this context to decide on an appropriate action
- After the action, the reflection evaluator extracts new facts and relationships
- These are stored in memory and available for future interactions
- This creates a virtuous cycle of continuous learning and improvement

---

## FAQ

### What are Actions in ElizaOS?

Actions are core components that define how agents respond to messages and perform tasks. They encapsulate specific behaviors and capabilities, ranging from simple text replies to complex interactions with external systems.

### How do Actions work?

When a message is received, the agent evaluates all available actions using their validation functions. The agent then decides which action(s) to execute based on the message content and context. Each action's handler generates a response, which may include text, thought processes, and attachments.

### What's the difference between actions and evaluators?

Actions are executed during an agent's response to perform tasks and generate content. Evaluators run after responses to analyze conversations, extract information, and update the agent's memory. Actions are about doing, evaluators are about learning.

### What role do "thoughts" play in actions?

The thought component provides an internal reasoning process for the agent, explaining its decision-making. These thoughts aren't shown to users but help with debugging and understanding the agent's behavior. They're similar to the self-reflection component in evaluators.

### How do I create a custom action?

Define an action object with a name, similes, description, validation function, handler function, and examples. The validation function determines when the action should be used, while the handler contains the implementation logic and generates a response.

### Can actions be chained together?

Yes! Actions can call other actions or services as part of their implementation. This allows for complex workflows that combine multiple capabilities. For example, an action might first reply to a user, then generate an image, and finally store data in a database.

### How does an agent choose which action to use?

The agent uses the following process:

1. All actions are validated against the current message
2. Valid actions are formatted and included in the agent's context
3. The LLM decides which action(s) to execute based on the message and context
4. The chosen action's handler is executed to generate a response

### How do actions integrate with services?

Actions often use services to interact with external systems. The action handler can retrieve a service from the runtime (e.g., `imageService = runtime.getService(ServiceType.IMAGE_GENERATION)`) and then call methods on that service to perform operations.

### What's the difference between `actions` and `action` in responses?

The `actions` array is the modern way to specify multiple actions being performed in a single response. The singular `action` field is maintained for backward compatibility but is deprecated in favor of the array format.

### Can I add custom actions to an existing agent?

Yes! You can create a plugin that defines new actions and then add that plugin to your agent's configuration. This allows you to extend the agent's capabilities without modifying its core implementation.

## Further Reading

- [Evaluators](./evaluators.md)
- [Providers](./providers.md)
- [Services](./services.md)
`````

## File: packages/docs/docs/core/agents.md
`````markdown
---
sidebar_position: 1
title: Agent Runtime
description: Understanding the ElizaOS Agent Runtime - the core environment that powers AI agents
keywords: [agent runtime, orchestration, services, state, plugins, memory, models, processing]
image: /img/agentruntime.jpg
---

# 🤖 Agent Runtime

The `AgentRuntime` is the core runtime environment for Eliza agents. It handles message processing, state management, plugin integration, and interaction with external services. You can think of it as the brains that provide the high-level orchestration layer for Eliza agents.

```mermaid
sequenceDiagram
    actor User
    participant Platform as Platform
    participant Runtime as Runtime
    participant State as State
    participant P as Providers
    participant A as Actions
    participant M as Models
    participant E as Evaluators
    participant DB as Database

    User->>Platform: Message
    Platform->>Runtime: Forward

    %% Context building (condensed)
    Runtime->>State: Get context
    State->>P: Gather data
    Note over P: Character, Knowledge,<br>Messages, Time, etc.
    P-->>State: Context data
    State-->>Runtime: Assembled context

    %% Action flow (condensed)
    Runtime->>A: Execute action
    A->>M: Generate content
    M-->>A: Generated text
    A-->>Runtime: Result

    %% Evaluation (condensed)
    Runtime->>E: Analyze
    E->>DB: Store insights
    E-->>Runtime: Evaluation

    %% Delivery
    Runtime->>Platform: Response
    Platform->>User: Deliver

    %% Background (simplified)
    par Background
        Runtime->>Runtime: Tasks & Events
    end
```

The runtime follows this general flow:

1. **Initial Reception**: The user sends a message which is received by the Platform Services
2. **Context Building**:

   - The Runtime Core requests context from the State Composition system
   - State gathers data from various Providers (Character, Knowledge, Recent Messages, etc.)
   - The complete context is returned to the Runtime

3. **Action Processing**:

   - The Runtime determines applicable actions and selects the optimal one
   - The selected action may request content generation from Models
   - The action result is returned to the Runtime

4. **Learning & Persistence**:

   - The conversation is analyzed by Evaluators for insights and facts
   - Knowledge updates are sent to the Memory System
   - All relevant data is persisted to the Database

5. **Response Delivery**:
   - The final response is sent back to the user through Platform Services

---

## Overview

The [AgentRuntime](/api/classes/AgentRuntime) class is the primary implementation of the [IAgentRuntime](/api/interfaces/IAgentRuntime) interface, which manages the agent's core functions, including:

| Component             | Description                                                                                                                                                                             | API Reference                                                    | Related Files                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Services**          | Supports multiple communication platforms and specialized functionalities for seamless interaction.                                                                                     | [Services API](/api/interfaces/IAgentRuntime/#services)          | [`service.ts`](https://github.com/elizaOS/eliza/tree/develop/packages/core/src/service.ts), [`Discord`](https://github.com/elizaos-plugins/plugin-discord), [`Telegram`](https://github.com/elizaos-plugins/plugin-telegram), [`Twitter`](https://github.com/elizaos-plugins/plugin-twitter), [`Farcaster`](https://github.com/elizaos-plugins/plugin-farcaster), [`Lens`](https://github.com/elizaos-plugins/plugin-lens), [`Slack`](https://github.com/elizaos-plugins/plugin-slack), [`Auto`](https://github.com/elizaos-plugins/plugin-auto), [`GitHub`](https://github.com/elizaos-plugins/plugin-github) |
| **State**             | Maintains context for coherent cross-platform interactions, updates dynamically. Also tracks goals, knowledge, and recent interactions                                                  | [State API](/api/interfaces/State)                               | [`state.ts`](https://github.com/elizaos/runtime/state.ts)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| **Plugins**           | Dynamic extensions of agent functionalities using custom actions, evaluators, providers, and adapters                                                                                   | [Plugins API](/api/type-aliases/Plugin/)                         | [`plugins.ts`](https://github.com/elizaos/runtime/plugins.ts), [actions](../actions), [evaluators](../evaluators), [providers](../providers)                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| **Services**          | Connects with external services for `IMAGE_DESCRIPTION`, `TRANSCRIPTION`, `TEXT_GENERATION`, `SPEECH_GENERATION`, `VIDEO`, `PDF`, `BROWSER`, `WEB_SEARCH`, `EMAIL_AUTOMATION`, and more | [Services API](/api/interfaces/IAgentRuntime/#services)          | [`services.ts`](https://github.com/elizaos/runtime/services.ts)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| **Memory Systems**    | Creates, retrieves, and embeds memories and manages conversation history.                                                                                                               | [Memory API](/api/interfaces/IMemoryManager)                     | [`memory.ts`](https://github.com/elizaos/runtime/memory.ts)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| **Database Adapters** | Persistent storage and retrieval for memories and knowledge                                                                                                                             | [databaseAdapter](api/interfaces/IAgentRuntime/#databaseAdapter) | [`MongoDB`](https://github.com/elizaos-plugins/adapter-mongodb), [`PostgreSQL`](https://github.com/elizaos-plugins/adapter-postgres), [`SQLite`](https://github.com/elizaos-plugins/adapter-sqlite), [`Supabase`](https://github.com/elizaos-plugins/adapter-supabase), [`PGLite`](https://github.com/elizaos-plugins/adapter-sqlite), [`Qdrant`](https://github.com/elizaos-plugins/adapter-qdrant), [`SQL.js`](https://github.com/elizaos-plugins/adapter-sqljs)                                                                                                                                             |
| **Cache Management**  | Provides flexible storage and retrieval via various caching methods.                                                                                                                    | [Cache API](/api/interfaces/ICacheManager)                       | [`cache.ts`](https://github.com/elizaos/runtime/cache.ts)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

<details>
<summary>Advanced: IAgentRuntime Interface</summary>
```typescript
interface IAgentRuntime {
    // Core identification
    agentId: UUID;

    // Configuration
    character: Character;                          // Personality and behavior settings

    // Components
    plugins: Plugin[];                             // Additional capabilities
    services: Map<ServiceTypeName, Service>;       // Platform connections and functionality
    providers: Provider[];                         // Real-time data sources
    actions: Action[];                             // Available behaviors
    evaluators: Evaluator[];                       // Analysis & learning
    routes: Route[];                               // API endpoints

    // Memory Management
    getMemories(...): Promise<Memory[]>;           // Retrieve conversation history
    createMemory(...): Promise<UUID>;              // Store new memories
    searchMemories(...): Promise<Memory[]>;        // Semantic search

    // State Composition
    composeState(...): Promise<State>;             // Gather data from providers

    // Plugin Management
    registerPlugin(...): Promise<void>;            // Register plugins

    // Service Management
    getService<T>(...): T | null;                  // Access services
    registerService(...): Promise<void>;           // Register services

    // Model Integration
    useModel<T, R>(...): Promise<R>;               // Use AI models

    // Additional Utilities
    getSetting(...): any;                          // Access settings
    setSetting(...): void;                         // Configure settings
    getCache<T>(...): Promise<T | undefined>;      // Access cached data
    setCache<T>(...): Promise<boolean>;            // Store cached data
}
```

Source: [/api/interfaces/IAgentRuntime/](/api/interfaces/IAgentRuntime/)

</details>

---

### **Key Methods**

- **`initialize()`**: Sets up the agent's runtime environment, including services, plugins, and knowledge processing.
- **`processActions()`**: Executes actions based on message content and state.
- **`evaluate()`**: Assesses messages and state using registered evaluators.
- **`composeState()`**: Constructs the agent's state object for response generation.
- **`registerService()`**: Adds a service to the runtime.
- **`getService()`**: Retrieves a registered service by type.
- **`useModel()`**: Utilizes AI models with typesafe parameters and results.
- **`ensureRoomExists()` / `ensureConnection()`**: Ensures the existence of communication channels and connections.

## Service System

Services provide specialized functionality with standardized interfaces that can be accessed cross-platform:

```typescript
// Speech Generation
const speechService = runtime.getService<ISpeechService>('speech_generation');
const audioStream = await speechService.process(text);

// PDF Processing
const pdfService = runtime.getService<IPdfService>('pdf');
const textContent = await pdfService.convertPdfToText(pdfBuffer);

// Discord Integration
const discordService = runtime.getService<IDiscordService>('discord');
await discordService.sendMessage(channelId, content);
```

---

## State Management

The runtime maintains comprehensive state through the State interface:

```typescript
interface State {
  // Core state data
  values: {
    [key: string]: any;
  };
  data: {
    [key: string]: any;
  };
  text: string;
}

// State composition example
async function manageState() {
  // Initial state composition with all regular providers
  const state = await runtime.composeState(message);

  // State with specific providers only
  const filteredState = await runtime.composeState(message, ['timeProvider', 'recentMessages']);

  // Include private or dynamic providers
  const enhancedState = await runtime.composeState(message, null, [
    'weatherProvider',
    'portfolioProvider',
  ]);
}
```

---

## Plugin System

Plugins extend agent functionality through a modular interface. The runtime supports various types of plugins including services, adapters, actions, and more:

```typescript
interface Plugin {
  name: string;
  description: string;
  init?: (config: Record<string, string>, runtime: IAgentRuntime) => Promise<void>;

  // Components
  services?: (typeof Service)[]; // Communication platforms and external integrations
  actions?: Action[]; // Custom behaviors
  providers?: Provider[]; // Data providers
  evaluators?: Evaluator[]; // Response assessment
  adapters?: Adapter[]; // Database/cache adapters
  routes?: Route[]; // API endpoints
  tests?: TestSuite[]; // Testing utilities
}
```

Plugins can be configured through [characterfile](./characterfile) settings:

```json
{
  "name": "MyAgent",
  "plugins": ["@elizaos/plugin-solana", "@elizaos/plugin-twitter"],
  "settings": {
    "twitter": {
      "shouldRespondToMentions": true
    },
    "solana": {
      "enableAutoTrading": false
    }
  }
}
```

For detailed information about plugin development and usage, see the [ElizaOS Registry](https://github.com/elizaos-plugins/registry).

---

## Running Multiple Agents

To run multiple agents:

```bash
bun start --characters="characters/agent1.json,characters/agent2.json"
```

Or use environment variables:

```
REMOTE_CHARACTER_URLS=https://example.com/characters.json
```

---

## FAQ

### What's the difference between an agent and a character?

A character defines personality and knowledge, while an agent provides the runtime environment and capabilities to bring that character to life.

### How do I choose the right database adapter?

Choose based on your needs:

- MongoDB: For scalable, document-based storage
- PostgreSQL: For relational data with complex queries
- SQLite: For simple, file-based storage
- Qdrant: For vector search capabilities

### How do I implement custom plugins?

Create a plugin that follows the plugin interface and register it with the runtime. See the plugin documentation for detailed examples.

### Do agents share memory across platforms?

By default, agents maintain separate memory contexts for different platforms to avoid mixing conversations. Use the memory management system and database adapters to persist and retrieve state information.

### How do I handle multiple authentication methods?

Use the character configuration to specify different authentication methods for different services. The runtime will handle the appropriate authentication flow.

### How do I manage environment variables?

Use a combination of:

- `.env` files for local development
- Character-specific settings for per-agent configuration
- Environment variables for production deployment

### Can agents communicate with each other?

Yes, through the message system and shared memory spaces when configured appropriately.
`````

## File: packages/docs/docs/core/database.md
`````markdown
---
sidebar_position: 7
title: Database System
description: Understanding ElizaOS database system - persistent storage and data management for agents
keywords: [database, storage, adapters, PostgreSQL, PGLite, entities, memories, relationships]
image: /img/database.jpg
---

# 💾 Database System

The ElizaOS database system provides persistent storage capabilities for agents. It handles memory storage, entity relationships, knowledge management, and more through a flexible adapter-based architecture.

## Overview

```mermaid
graph TB
    %% Main Components
    Runtime([Agent Runtime])
    DbAdapter([Database Adapter])
    DbConnection[("Database (PGLite/PostgreSQL)")]

    %% Data Models in compact form
    DataModels["Data Models: Entities, Components, Memories, Relationships, Rooms, Worlds, Tasks Cache"]

    %% Vector Search
    VectorStore[(Vector Store)]

    %% Memories Knowledge
    MemoriesKnowledge[(Memories / Knowledge)]

    %% Connection flow
    Runtime -->|Uses| DbAdapter
    DbAdapter -->|Connects to| DbConnection
    DbConnection -->|Stores & Retrieves| DataModels

    %% Connect Vector Store
    DbConnection -->|Utilizes| VectorStore
    VectorStore -->|Enables Search on| MemoriesKnowledge

    %% Styling
    classDef default fill:#f0f4f8,stroke:#2c3e50,stroke-width:1px;
    classDef runtime fill:#3498db,stroke:#2c3e50,stroke-width:1px,color:#fff;
    classDef adapter fill:#9b59b6,stroke:#2c3e50,stroke-width:1px,color:#fff;
    classDef db fill:#27ae60,stroke:#2c3e50,stroke-width:1px,color:#fff;
    classDef datamodels fill:#52be80,stroke:#2c3e50,stroke-width:1px,color:#fff;
    classDef memories fill:#2c5e1a,stroke:#2c3333,stroke-width:1px,color:#fff;

    class Runtime runtime;
    class DbAdapter adapter;
    class DbConnection,VectorStore db;
    class DataModels datamodels;
    class MemoriesKnowledge memories;
```

ElizaOS uses a unified database architecture based on Drizzle ORM with adapters that implement the [`IDatabaseAdapter`](/api/interfaces/IDatabaseAdapter) interface. The current release includes support for:

| Adapter        | Best For                    | Key Features                                                      |
| -------------- | --------------------------- | ----------------------------------------------------------------- |
| **PGLite**     | Local development & testing | Lightweight PostgreSQL implementation running in Node.js process  |
| **PostgreSQL** | Production deployments      | Full PostgreSQL with vector search, scaling, and high reliability |

Additional database adapters will be supported in future releases as ElizaOS continues to evolve.

## Core Functionality

All database adapters extend the `BaseDrizzleAdapter` abstract class, which provides a comprehensive set of methods for managing all aspects of agent data:

### Entity System

| Method                 | Description                           |
| ---------------------- | ------------------------------------- |
| `createEntity()`       | Create a new entity                   |
| `getEntityById()`      | Retrieve an entity by ID              |
| `getEntitiesForRoom()` | Get all entities in a room            |
| `updateEntity()`       | Update entity attributes              |
| `getComponent()`       | Get a specific component of an entity |
| `getComponents()`      | Get all components for an entity      |
| `createComponent()`    | Add a component to an entity          |
| `updateComponent()`    | Update a component                    |
| `deleteComponent()`    | Remove a component                    |

### Memory Management

| Method                        | Description                          |
| ----------------------------- | ------------------------------------ |
| `createMemory()`              | Store a new memory with metadata     |
| `getMemoryById()`             | Retrieve a specific memory           |
| `getMemories()`               | Get memories matching criteria       |
| `getMemoriesByIds()`          | Get multiple memories by IDs         |
| `getMemoriesByRoomIds()`      | Get memories from multiple rooms     |
| `searchMemories()`            | Search memories by vector similarity |
| `searchMemoriesByEmbedding()` | Search using raw embedding vector    |
| `deleteMemory()`              | Remove a specific memory             |
| `deleteAllMemories()`         | Remove all memories in a room        |
| `countMemories()`             | Count memories matching criteria     |

### Room & Participant Management

| Method                       | Description                     |
| ---------------------------- | ------------------------------- |
| `createRoom()`               | Create a new conversation room  |
| `getRoom()`                  | Get room by ID                  |
| `getRooms()`                 | Get all rooms in a world        |
| `updateRoom()`               | Update room attributes          |
| `deleteRoom()`               | Remove a room                   |
| `addParticipant()`           | Add entity to room              |
| `removeParticipant()`        | Remove entity from room         |
| `getParticipantsForEntity()` | Get all rooms an entity is in   |
| `getParticipantsForRoom()`   | List entities in a room         |
| `getParticipantUserState()`  | Get entity's state in a room    |
| `setParticipantUserState()`  | Update entity's state in a room |

### Relationship Management

| Method                 | Description                            |
| ---------------------- | -------------------------------------- |
| `createRelationship()` | Create a relationship between entities |
| `updateRelationship()` | Update relationship attributes         |
| `getRelationship()`    | Get a specific relationship            |
| `getRelationships()`   | Get all relationships for an entity    |

### Caching System

| Method          | Description            |
| --------------- | ---------------------- |
| `getCache()`    | Retrieve cached data   |
| `setCache()`    | Store data in cache    |
| `deleteCache()` | Remove data from cache |

### World & Task Management

| Method             | Description                 |
| ------------------ | --------------------------- |
| `createWorld()`    | Create a new world          |
| `getWorld()`       | Get world by ID             |
| `getAllWorlds()`   | List all worlds             |
| `updateWorld()`    | Update world attributes     |
| `removeWorld()`    | Delete a world              |
| `createTask()`     | Create a new task           |
| `getTasks()`       | Get tasks matching criteria |
| `getTasksByName()` | Find tasks by name          |
| `getTask()`        | Get task by ID              |
| `updateTask()`     | Update task attributes      |
| `deleteTask()`     | Remove a task               |

### Agent Management

| Method          | Description               |
| --------------- | ------------------------- |
| `createAgent()` | Create a new agent record |
| `getAgent()`    | Get agent by ID           |
| `getAgents()`   | List all agents           |
| `updateAgent()` | Update agent attributes   |
| `deleteAgent()` | Remove an agent           |
| `countAgents()` | Count total agents        |

### Embedding & Search

| Method                        | Description                    |
| ----------------------------- | ------------------------------ |
| `ensureEmbeddingDimension()`  | Configure embedding dimensions |
| `getCachedEmbeddings()`       | Retrieve cached embeddings     |
| `searchMemories()`            | Vector search for memories     |
| `searchMemoriesByEmbedding()` | Advanced vector search         |

## Architecture

ElizaOS uses a singleton pattern for database connections to ensure efficient resource usage:

```
┌─────────────────────────────────────┐
│           AgentRuntime              │
└───────────────┬─────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│        IDatabaseAdapter             │
└───────────────┬─────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│       BaseDrizzleAdapter            │
└───────────────┬─────────────────────┘
                │
        ┌───────┴───────┐
        ▼               ▼
┌───────────────┐ ┌─────────────────┐
│ PGLiteAdapter │ │ PostgresAdapter │
└───────┬───────┘ └────────┬────────┘
        │                  │
        ▼                  ▼
┌───────────────┐ ┌─────────────────┐
│PGLiteManager  │ │PostgresManager  │
│  (Singleton)  │ │  (Singleton)    │
└───────────────┘ └─────────────────┘
```

Each adapter is associated with a singleton connection manager that ensures only one database connection is maintained per process, regardless of how many agents are running.

## Implementation

### Initialization

The database adapter is initialized through the SQL plugin:

```typescript
// Plugin registration in project configuration
const project = {
  plugins: ['@elizaos/plugin-sql'],
  // ...
};
```

The SQL plugin automatically selects and initializes the appropriate database adapter based on environment settings:

```typescript
function createDatabaseAdapter(
  config: {
    dataDir?: string;
    postgresUrl?: string;
  },
  agentId: UUID
): IDatabaseAdapter {
  if (config.postgresUrl) {
    return new PgDatabaseAdapter(agentId, postgresConnectionManager);
  }

  // Default to PGLite
  return new SqliteDatabaseAdapter(agentId, pgLiteClientManager);
}
```

### Configuration

Configure the database adapter using environment variables or settings:

```typescript
// For PostgreSQL
process.env.POSTGRES_URL = 'postgresql://username:password@localhost:5432/elizaos';

// For PGLite (default)
process.env.SQLITE_DATA_DIR = './.elizadb'; // Optional, defaults to './sqlite'
```

### Retry Logic & Error Handling

The database system includes built-in retry logic with exponential backoff and jitter:

```typescript
protected async withRetry<T>(operation: () => Promise<T>): Promise<T> {
  let attempt = 0;
  let lastError: Error | null = null;

  while (attempt < this.maxRetries) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      const isRetryable = this.isRetryableError(error);

      if (!isRetryable) {
        break;
      }

      // Calculate delay with exponential backoff and jitter
      const delay = Math.min(
        this.baseDelay * Math.pow(2, attempt) + Math.random() * this.jitterMax,
        this.maxDelay
      );

      await new Promise(resolve => setTimeout(resolve, delay));
      attempt++;
    }
  }

  throw lastError;
}
```

## Example Usage

Here are examples of common database operations:

### Store a Memory

```typescript
await runtime.createMemory(
  {
    entityId: message.entityId,
    agentId: runtime.agentId,
    content: { text: 'Important information to remember' },
    roomId: message.roomId,
    embedding: await runtime.useModel(ModelType.TEXT_EMBEDDING, {
      text: 'Important information to remember',
    }),
  },
  'facts'
);
```

### Search for Memories

```typescript
const embedding = await runtime.useModel(ModelType.TEXT_EMBEDDING, {
  text: 'What did we discuss about databases?',
});

const relevantMemories = await runtime.searchMemories({
  tableName: 'messages',
  embedding,
  roomId: message.roomId,
  count: 5,
});
```

### Manage Entity Relationships

```typescript
// Create a relationship between entities
await runtime.createRelationship({
  sourceEntityId: userEntityId,
  targetEntityId: agentEntityId,
  tags: ['friend', 'frequent_interaction'],
  metadata: {
    interactions: 42,
    trust_level: 'high',
  },
});

// Retrieve relationships
const relationships = await runtime.getRelationships({
  entityId: userEntityId,
  tags: ['friend'],
});
```

## Database Schema

The schema is managed by Drizzle ORM and includes the following key tables:

### Core Tables

- **entities**: The fundamental objects in the system (users, agents, etc.)
- **components**: Modular data attached to entities (profiles, settings, etc.)
- **memories**: Conversation history and other remembered information
- **relationships**: Connections between entities
- **rooms**: Conversation channels
- **participants**: Entity participation in rooms
- **worlds**: Container for multiple rooms
- **tasks**: Scheduled or queued operations
- **cache**: Temporary key-value storage
- **agents**: Agent configuration and state

### Entity-Component System

ElizaOS uses an entity-component architecture where:

- Entities are the base objects (users, agents, etc.)
- Components are pieces of data attached to entities
- This allows for flexible data modeling and extension

For example, a user entity might have profile, preferences, and authentication components.

## Vector Search

Both adapters support vector-based semantic search with some differences:

- **PostgreSQL**: Uses pgvector extension for optimized vector operations
- **PGLite**: Implements vector search in JavaScript with an efficient algorithm

The embedding dimension is configurable based on the model used:

```typescript
await adapter.ensureEmbeddingDimension(1536); // For OpenAI embeddings
```

## FAQ

### How do I choose between PGLite and PostgreSQL?

- Use **PGLite** for:

  - Local development and testing
  - Single-user deployments
  - Situations where installing PostgreSQL is impractical

- Use **PostgreSQL** for:
  - Production deployments
  - Multi-user systems
  - High-volume data
  - When you need advanced scaling features

### How do I configure the database connection?

For PostgreSQL, set the `POSTGRES_URL` environment variable:

```
POSTGRES_URL=postgresql://username:password@localhost:5432/elizaos
```

For PGLite, set the data directory (optional):

```
SQLITE_DATA_DIR=./my-data
```

### How can I inspect the database contents?

For PostgreSQL, use standard PostgreSQL tools like pgAdmin or psql.

For PGLite, the data is stored in the specified data directory as files. You can use tools like DB Browser for SQLite to inspect the SQLite files that PGLite generates.

### How do I migrate between different database adapters?

Currently, there's no built-in migration tool between adapters. For production systems, it's recommended to start with PostgreSQL if you anticipate needing its features.

### What about vector embedding dimension mismatches?

The system automatically handles embedding dimensions based on the model used. If you change embedding models, make sure to:

1. Set the correct dimension with `ensureEmbeddingDimension()`
2. Be aware that mixing different dimensions in the same database can cause issues

### How does the entity-component system work?

The entity-component system (ECS) provides a flexible way to model data:

- **Entities** are base objects with unique IDs
- **Components** are pieces of data attached to entities
- This allows for dynamic composition of objects without complex inheritance

For example, a user entity might have profile, preferences, and authentication components.

### How can I improve database performance?

- For **PostgreSQL**:

  - Ensure the pgvector extension is properly installed
  - Index frequently queried fields
  - Use connection pooling
  - Consider partitioning for large datasets

- For **PGLite**:
  - Keep database size reasonable (under 1GB)
  - Regularly clean up old memories
  - Limit the number of concurrent operations

### Will other database adapters be supported in the future?

Yes, future releases will add support for additional databases such as:

- MongoDB
- SQLite
- Supabase
- Qdrant
- SQL.js

The adapter interface is designed to be extensible to support a wide range of storage solutions.

## Further Reading

- [Entity System](./entities.md)
- [Agent Runtime](./agents.md)
`````

## File: packages/docs/docs/core/entities.md
`````markdown
---
sidebar_position: 9
title: Entities System
description: Understanding ElizaOS entities - users, agents, and participants in the entity-component architecture
keywords: [entities, components, users, agents, participants, relationships, data modeling]
image: /img/entities-component-architecture.svg
---

# Entities

Entities in ElizaOS represent users, agents, or any participant that can interact within the system. They form the basis of the entity-component architecture, allowing for flexible data modeling and relationships across the platform.

![](/img/entities-component-architecture.svg)

## Entity Structure

An entity in ElizaOS has the following properties:

```typescript
interface Entity {
  /** Unique identifier, optional on creation */
  id?: UUID;

  /** Names of the entity */
  names: string[];

  /** Optional additional metadata */
  metadata?: { [key: string]: any };

  /** Agent ID this account is related to, for agents should be themselves */
  agentId: UUID;

  /** Optional array of components */
  components?: Component[];
}
```

| Property     | Description                                              |
| ------------ | -------------------------------------------------------- |
| `id`         | Unique identifier for the entity (optional on creation)  |
| `names`      | Array of names the entity is known by                    |
| `metadata`   | Additional information about the entity                  |
| `agentId`    | ID of the agent related to this entity                   |
| `components` | Array of modular data components attached to this entity |

## Components

Components are modular pieces of data attached to entities with the following structure:

```typescript
interface Component {
  id: UUID;
  entityId: UUID;
  agentId: UUID;
  roomId: UUID;
  worldId: UUID;
  sourceEntityId: UUID;
  type: string;
  data: {
    [key: string]: any;
  };
}
```

| Property         | Description                                       |
| ---------------- | ------------------------------------------------- |
| `id`             | Unique identifier for the component               |
| `entityId`       | ID of the entity this component belongs to        |
| `agentId`        | ID of the agent managing this component           |
| `roomId`         | ID of the room this component is associated with  |
| `worldId`        | ID of the world this component is associated with |
| `sourceEntityId` | ID of the entity that created this component      |
| `type`           | Type of component (e.g., "profile", "settings")   |
| `data`           | Additional data specific to this component type   |

## Entity Creation and Management

### Creating an Entity

```typescript
const entityId = await runtime.createEntity({
  names: ['John Doe', 'JohnD'],
  agentId: runtime.agentId,
  metadata: {
    discord: {
      username: 'john_doe',
      name: 'John Doe',
    },
  },
});
```

### Retrieving an Entity

```typescript
// Get an entity by ID
const entity = await runtime.getEntityById(entityId);

// Get all entities in a room
const entitiesInRoom = await runtime.getEntitiesForRoom(roomId, true); // true to include components
```

### Updating an Entity

```typescript
await runtime.updateEntity({
  id: entityId,
  names: [...entity.names, 'Johnny'],
  metadata: {
    ...entity.metadata,
    customProperty: 'value',
  },
});
```

## Component Management

Components allow for flexible data modeling by attaching different types of data to entities.

### Creating a Component

```typescript
await runtime.createComponent({
  id: componentId,
  entityId: entityId,
  agentId: runtime.agentId,
  roomId: roomId,
  worldId: worldId,
  sourceEntityId: creatorEntityId,
  type: 'profile',
  data: {
    bio: 'Software developer interested in AI',
    location: 'San Francisco',
    website: 'https://example.com',
  },
});
```

### Retrieving Components

```typescript
// Get a specific component type
const profileComponent = await runtime.getComponent(
  entityId,
  'profile',
  worldId, // optional filter by world
  sourceEntityId // optional filter by source
);

// Get all components for an entity
const allComponents = await runtime.getComponents(entityId, worldId, sourceEntityId);
```

### Updating Components

```typescript
await runtime.updateComponent({
  id: profileComponent.id,
  data: {
    ...profileComponent.data,
    bio: 'Updated bio information',
  },
});
```

### Deleting Components

```typescript
await runtime.deleteComponent(componentId);
```

## Entity Relationships

Entities can have relationships with other entities, stored in the database:

```typescript
// Create a relationship between entities
await runtime.createRelationship({
  sourceEntityId: entityId1,
  targetEntityId: entityId2,
  tags: ['friend', 'collaborator'],
  metadata: {
    interactions: 5,
    lastInteraction: Date.now(),
  },
});

// Get relationships for an entity
const relationships = await runtime.getRelationships({
  entityId: entityId1,
  tags: ['friend'], // optional filter by tags
});

// Get a specific relationship
const relationship = await runtime.getRelationship({
  sourceEntityId: entityId1,
  targetEntityId: entityId2,
});

// Update a relationship
await runtime.updateRelationship({
  ...relationship,
  metadata: {
    ...relationship.metadata,
    interactions: relationship.metadata.interactions + 1,
    lastInteraction: Date.now(),
  },
});
```

## Entity Resolution

ElizaOS includes a system for resolving entity references from messages and context. This is particularly useful for determining which entity is being referenced in a conversation.

```typescript
// Find an entity by name or reference
const entity = await findEntityByName(runtime, message, state);
```

The entity resolution system considers:

1. Exact matches by ID or username
2. Contextual matches from recent conversations
3. Relationship strength between entities
4. Role-based permissions in worlds

## Entity Details

To get formatted information about entities in a room:

```typescript
// Get detailed information about entities in a room
const entityDetails = await getEntityDetails({
  runtime,
  roomId,
});

// Format entities into a string representation
const formattedEntities = formatEntities({ entities: entitiesInRoom });
```

## Relationship with Rooms and Worlds

Entities participate in rooms and, by extension, in worlds:

```typescript
// Add an entity as a participant in a room
await runtime.addParticipant(entityId, roomId);

// Get all rooms where an entity is a participant
const entityRooms = await runtime.getRoomsForParticipant(entityId);

// Get all participants in a room
const participants = await runtime.getParticipantsForRoom(roomId);
```

When an entity is a participant in a room that belongs to a world, the entity has an implicit relationship with that world.

## Creating Unique Entity IDs

For situations where you need to create deterministic, unique IDs for entity-agent pairs:

```typescript
const uniqueId = createUniqueUuid(runtime, baseUserId);
```

This ensures that each user-agent interaction has a consistent, unique identifier.

## Best Practices

1. **Use meaningful names**: Provide descriptive names in the `names` array to make entity identification easier
2. **Structure metadata carefully**: Organize metadata by source (e.g., `discord`, `telegram`) for clarity
3. **Component segregation**: Use components to separate different aspects of entity data rather than storing everything in metadata
4. **Permission checking**: Always verify permissions before accessing components created by other entities
5. **Relationship maintenance**: Update relationship metadata regularly to reflect recent interactions
6. **Entity resolution**: Use the entity resolution system to correctly identify entities in conversations
7. **Deterministic IDs**: Use `createUniqueUuid` for consistent entity identification across sessions
`````

## File: packages/docs/docs/core/evaluators.md
`````markdown
---
sidebar_position: 7
title: Evaluators System
description: Understanding ElizaOS evaluators - cognitive components that enable agents to learn and evolve
keywords: [evaluators, cognition, learning, memory, facts, reflection, analysis]
image: /img/evaluators.jpg
---

# 🧠 Evaluators

Evaluators are cognitive components in the ElizaOS framework that enable agents to process conversations, extract knowledge, and build understanding - similar to how humans form memories after interactions. They provide a structured way for agents to introspect, learn from interactions, and evolve over time.

## Understanding Evaluators

Evaluators are specialized functions that work with the [`AgentRuntime`](/api/classes/AgentRuntime) to analyze conversations after a response has been generated. Unlike actions that create responses, evaluators perform background cognitive tasks that enable numerous advanced capabilities:

- **Knowledge Building**: Automatically extract and store facts from conversations
- **Relationship Tracking**: Identify connections between entities
- **Conversation Quality**: Perform self-reflection on interaction quality
- **Goal Tracking**: Determine if conversation objectives are being met
- **Tone Analysis**: Evaluate emotional content and adjust future responses
- **User Profiling**: Build understanding of user preferences and needs over time
- **Performance Metrics**: Gather data on agent effectiveness and learn from interactions

### Core Structure

```typescript
interface Evaluator {
  name: string; // Unique identifier
  similes?: string[]; // Alternative names/triggers
  description: string; // Purpose explanation
  examples: EvaluationExample[]; // Sample usage patterns
  handler: Handler; // Implementation logic
  validate: Validator; // Execution criteria check
  alwaysRun?: boolean; // Run regardless of validation
}
```

### Evaluator Execution Flow

The agent runtime executes evaluators as part of its cognitive cycle:

1. Agent processes a message and generates a response
2. Runtime calls `evaluate()` after response generation
3. Each evaluator's `validate()` method determines if it should run
4. For each valid evaluator, the `handler()` function is executed
5. Results are stored in memory and inform future responses

---

## Fact Evaluator: Memory Formation System

The Fact Evaluator serves as the agent's "episodic memory formation" system - similar to how humans process conversations and form memories. Just as you might reflect after a conversation "Oh, I learned something new about Sarah today", the Fact Evaluator systematically processes conversations to build up the agent's understanding of the world and the people in it.

### How It Works

#### 1. Triggering (The "When to Reflect" System)

```typescript
validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
  const messageCount = await runtime.messageManager.countMemories(message.roomId);
  const reflectionCount = Math.ceil(runtime.getConversationLength() / 2);
  return messageCount % reflectionCount === 0;
};
```

Just like humans don't consciously analyze every single word in real-time, the Fact Evaluator runs periodically rather than after every message. It triggers a "reflection" phase every few messages to process what's been learned.

#### 2. Fact Extraction (The "What Did I Learn?" System)

The evaluator uses a template-based approach to extract three types of information:

- **Facts**: Unchanging truths about the world or people
  - "Bob lives in New York"
  - "Sarah has a degree in Computer Science"
- **Status**: Temporary or changeable states
  - "Bob is currently working on a new project"
  - "Sarah is visiting Paris this week"
- **Opinions**: Subjective views, feelings, or non-factual statements
  - "Bob thinks the project will be successful"
  - "Sarah loves French cuisine"

#### 3. Memory Deduplication (The "Is This New?" System)

```typescript
const filteredFacts = facts.filter((fact) => {
  return (
    !fact.already_known &&
    fact.type === 'fact' &&
    !fact.in_bio &&
    fact.claim &&
    fact.claim.trim() !== ''
  );
});
```

Just as humans don't need to consciously re-learn things they already know, the Fact Evaluator:

- Checks if information is already known
- Verifies if it's in the agent's existing knowledge (bio)
- Filters out duplicate or corrupted facts

#### 4. Memory Storage (The "Remember This" System)

```typescript
const factMemory = await factsManager.addEmbeddingToMemory({
  userId: agentId!,
  agentId,
  content: { text: fact },
  roomId,
  createdAt: Date.now(),
});
```

Facts are stored with embeddings to enable:

- Semantic search of related facts
- Context-aware recall
- Temporal tracking (when the fact was learned)

### Example Processing

Given this conversation:

```
User: "I just moved to Seattle last month!"
Agent: "How are you finding the weather there?"
User: "It's rainy, but I love my new job at the tech startup"
```

The Fact Evaluator might extract:

```json
[
  {
    "claim": "User moved to Seattle last month",
    "type": "fact",
    "in_bio": false,
    "already_known": false
  },
  {
    "claim": "User works at a tech startup",
    "type": "fact",
    "in_bio": false,
    "already_known": false
  },
  {
    "claim": "User enjoys their new job",
    "type": "opinion",
    "in_bio": false,
    "already_known": false
  }
]
```

### Key Design Considerations

1. **Episodic vs Semantic Memory**

   - Facts build up the agent's semantic memory (general knowledge)
   - The raw conversation remains in episodic memory (specific experiences)

2. **Temporal Awareness**

   - Facts are timestamped to track when they were learned
   - Status facts can be updated as they change

3. **Confidence and Verification**

   - Multiple mentions of a fact increase confidence
   - Contradictory facts can be flagged for verification

4. **Privacy and Relevance**
   - Only stores relevant, conversation-appropriate facts
   - Respects explicit and implicit privacy boundaries

---

## Reflection Evaluator: Self-Awareness System

The reflection evaluator extends beyond fact extraction to enable agents to develop a form of "self-awareness" about their conversational performance. It allows agents to:

1. Generate self-reflective thoughts about the conversation quality
2. Extract factual information from conversations (similar to the Fact Evaluator)
3. Identify and track relationships between entities

### How Reflections Work

When triggered, the reflection evaluator:

1. Analyzes recent conversations and existing knowledge
2. Generates structured reflection output with:
   - Self-reflective thoughts about conversation quality
   - New facts extracted from conversation
   - Identified relationships between entities
3. Stores this information in the agent's memory for future reference

### Example Reflection Output

```json
{
  "thought": "I'm engaging appropriately with John, maintaining a welcoming and professional tone. My questions are helping learn more about him as a new community member.",
  "facts": [
    {
      "claim": "John is new to the community",
      "type": "fact",
      "in_bio": false,
      "already_known": false
    },
    {
      "claim": "John found the community through a friend interested in AI",
      "type": "fact",
      "in_bio": false,
      "already_known": false
    }
  ],
  "relationships": [
    {
      "sourceEntityId": "sarah-agent",
      "targetEntityId": "user-123",
      "tags": ["group_interaction"]
    },
    {
      "sourceEntityId": "user-123",
      "targetEntityId": "sarah-agent",
      "tags": ["group_interaction"]
    }
  ]
}
```

### Implementation Details

The reflection evaluator uses a defined schema to ensure consistent output:

```typescript
const reflectionSchema = z.object({
  facts: z.array(
    z.object({
      claim: z.string(),
      type: z.string(),
      in_bio: z.boolean(),
      already_known: z.boolean(),
    })
  ),
  relationships: z.array(relationshipSchema),
});

const relationshipSchema = z.object({
  sourceEntityId: z.string(),
  targetEntityId: z.string(),
  tags: z.array(z.string()),
  metadata: z
    .object({
      interactions: z.number(),
    })
    .optional(),
});
```

### Validation Logic

The reflection evaluator includes validation logic that determines when reflection should occur:

```typescript
validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
  const lastMessageId = await runtime.getCache<string>(
    `${message.roomId}-reflection-last-processed`
  );
  const messages = await runtime.getMemories({
    tableName: 'messages',
    roomId: message.roomId,
    count: runtime.getConversationLength(),
  });

  if (lastMessageId) {
    const lastMessageIndex = messages.findIndex((msg) => msg.id === lastMessageId);
    if (lastMessageIndex !== -1) {
      messages.splice(0, lastMessageIndex + 1);
    }
  }

  const reflectionInterval = Math.ceil(runtime.getConversationLength() / 4);

  return messages.length > reflectionInterval;
};
```

This ensures reflections occur at appropriate intervals, typically after a set number of messages have been exchanged.

## Common Memory Formation Patterns

1. **Progressive Learning**

   ```typescript
   // First conversation
   "I live in Seattle" -> Stores as fact

   // Later conversation
   "I live in the Ballard neighborhood" -> Updates/enhances existing fact
   ```

2. **Fact Chaining**

   ```typescript
   // Original facts
   'Works at tech startup';
   'Startup is in Seattle';

   // Inference potential
   'Works in Seattle tech industry';
   ```

3. **Temporal Tracking**

   ```typescript
   // Status tracking
   t0: 'Looking for a job'(status);
   t1: 'Got a new job'(fact);
   t2: 'Been at job for 3 months'(status);
   ```

4. **Relationship Building**

   ```typescript
   // Initial relationship
   {
     "sourceEntityId": "user-123",
     "targetEntityId": "sarah-agent",
     "tags": ["new_interaction"]
   }

   // Evolving relationship
   {
     "sourceEntityId": "user-123",
     "targetEntityId": "sarah-agent",
     "tags": ["frequent_interaction", "positive_sentiment"],
     "metadata": { "interactions": 15 }
   }
   ```

## Integration with Other Systems

Evaluators work alongside other components:

- **Goal Evaluator**: Facts and reflections may influence goal progress
- **Trust Evaluator**: Fact consistency affects trust scoring
- **Memory Manager**: Facts enhance context for future conversations
- **Providers**: Facts inform response generation

---

## Creating Custom Evaluators

You can create your own evaluators by implementing the `Evaluator` interface:

```typescript
const customEvaluator: Evaluator = {
  name: 'CUSTOM_EVALUATOR',
  similes: ['ANALYZE', 'ASSESS'],
  description: 'Performs custom analysis on conversations',

  validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
    // Your validation logic here
    return true;
  },

  handler: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
    // Your evaluation logic here

    // Example of storing evaluation results
    await runtime.addEmbeddingToMemory({
      entityId: runtime.agentId,
      content: { text: 'Evaluation result' },
      roomId: message.roomId,
      createdAt: Date.now(),
    });

    return { result: 'evaluation complete' };
  },

  examples: [
    {
      prompt: `Example context`,
      messages: [
        { name: 'User', content: { text: 'Example message' } },
        { name: 'Agent', content: { text: 'Example response' } },
      ],
      outcome: `{ "result": "example outcome" }`,
    },
  ],
};
```

### Registering Custom Evaluators

Custom evaluators can be registered with the agent runtime:

```typescript
// In your plugin's initialization
export default {
  name: 'custom-evaluator-plugin',
  description: 'Adds custom evaluation capabilities',

  init: async (config: any, runtime: IAgentRuntime) => {
    // Register your custom evaluator
    runtime.registerEvaluator(customEvaluator);
  },

  // Include the evaluator in the plugin exports
  evaluators: [customEvaluator],
};
```

## Best Practices for Memory Formation

1. **Validate Facts**

   - Cross-reference with existing knowledge
   - Consider source reliability
   - Track fact confidence levels

2. **Manage Memory Growth**

   - Prioritize important facts
   - Consolidate related facts
   - Archive outdated status facts

3. **Handle Contradictions**

   - Flag conflicting facts
   - Maintain fact history
   - Update based on newest information

4. **Respect Privacy**

   - Filter sensitive information
   - Consider contextual appropriateness
   - Follow data retention policies

5. **Balance Reflection Frequency**
   - Too frequent: Computational overhead
   - Too infrequent: Missing important information
   - Adapt based on conversation complexity and pace

---

## FAQ

### What's the difference between actions and evaluators?

Actions are triggered during response generation and create visible outputs, while evaluators run after responses and perform background cognitive tasks without direct user visibility.

### When should I use the Fact Evaluator vs. the Reflection Evaluator?

Use the Fact Evaluator when you only need to extract and store factual information. Use the Reflection Evaluator when you need both fact extraction and relationship tracking, along with self-reflective assessment.

### How often do evaluators run?

By default, evaluators run at intervals based on conversation length, typically after every few messages, to avoid unnecessary processing while still capturing important information.

### Can evaluators affect future responses?

Yes! Facts and relationships stored by evaluators become part of the agent's memory and context, influencing future responses through the retrieval-augmented generation system.

### How do I debug evaluator issues?

Use the logger to inspect evaluator execution and output. The most common issues involve entity resolution failures or schema validation errors.

### Can evaluators work across different platforms?

Yes, evaluators are platform-agnostic and work the same way regardless of whether your agent is deployed on Discord, Twitter, Telegram, or web interfaces.

## Related Resources

- [Actions Documentation](./actions.md)
- [Providers Documentation](./providers.md)
- [Agent Runtime](./agents.md)
`````

## File: packages/docs/docs/core/knowledge.md
`````markdown
---
sidebar_position: 4
title: Knowledge System
description: Understanding ElizaOS knowledge management - how agents process, store, and retrieve information
keywords: [knowledge, RAG, embeddings, documents, processing, retrieval, semantic search]
image: /img/knowledge.jpg
---

# Knowledge Management

## Overview

The Knowledge Management system in ElizaOS is a powerful Retrieval-Augmented Generation (RAG) feature that enables agents to process, store, and retrieve information from various sources. This allows agents to provide contextually relevant responses by leveraging stored knowledge during conversations.

## Adding Knowledge to Agents

ElizaOS provides multiple ways to add knowledge to your agents, both during initialization and at runtime.

### Adding Knowledge During Runtime Creation

#### 1. Via Character Definition

The simplest approach is to define knowledge directly in your character configuration:

```typescript
const character: Character = {
  name: 'My Agent',
  // Other character properties...
  knowledge: [
    // Direct string knowledge
    'Important fact: ElizaOS supports multiple knowledge formats',

    // File references
    { path: 'knowledge/documentation.md', shared: false },

    // Directory references
    { directory: 'knowledge/guides', shared: true },
  ],
};
```

The knowledge array supports three formats:

- String literals for direct knowledge
- File objects pointing to specific files
- Directory objects for entire folders of content

#### 2. Programmatically Before Runtime Initialization

You can dynamically load knowledge before creating your runtime:

```typescript
// Load knowledge from files or other sources
const knowledge = [];

// Example: Recursively load documentation files
function loadDocumentation(directoryPath) {
  const files = getFilesRecursively(directoryPath, ['.md']);
  return files.map((filePath) => {
    const relativePath = path.relative(basePath, filePath);
    const content = fs.readFileSync(filePath, 'utf-8');
    return `Path: ${relativePath}\n\n${content}`;
  });
}

// Load documentation
const docKnowledge = loadDocumentation('./docs');
knowledge.push(...docKnowledge);

// Then include in your character definition
const character: Character = {
  // Other character properties...
  knowledge: knowledge,
};
```

### Adding Knowledge After Runtime Creation

#### 1. Using the `addKnowledge` Method

Add knowledge programmatically after the runtime is initialized:

```typescript
// Import needed utilities
import { createUniqueUuid } from '@elizaos/core';

// Create a knowledge item
const knowledgeItem = {
  id: createUniqueUuid(runtime, 'unique-knowledge-identifier'),
  content: {
    text: 'Important information the agent should know...',
  },
};

// Add to runtime with default chunking settings
await runtime.addKnowledge(knowledgeItem);

// Or with custom chunking settings
await runtime.addKnowledge(knowledgeItem, {
  targetTokens: 1500, // Target chunk size (default: 3000)
  overlap: 100, // Overlap between chunks (default: 200)
  modelContextSize: 8192, // Context size of your model (default: 4096)
});
```

#### 2. Processing Files at Runtime

You can dynamically process files at runtime:

```typescript
// For PDF files, use the PDF service
const pdfService = runtime.getService<IPdfService>('pdf');
if (pdfService) {
  const pdfBuffer = fs.readFileSync('./knowledge/document.pdf');
  const textContent = await pdfService.convertPdfToText(pdfBuffer);

  const knowledgeItem = {
    id: createUniqueUuid(runtime, 'document.pdf'),
    content: { text: textContent },
  };

  await runtime.addKnowledge(knowledgeItem);
}
```

## Directory Structure

ElizaOS expects knowledge files to be organized in the following structure:

```
knowledge/          # Root knowledge directory
├── shared/         # Shared knowledge accessible to all agents
└── {agent-name}/   # Agent-specific knowledge directories
```

## Supported File Types

- PDF files (`.pdf`)
- Markdown files (`.md`)
- Text files (`.txt`)

## Knowledge Modes

ElizaOS supports two knowledge modes:

### Classic Mode (Default)

- Direct string knowledge added to character's context
- No chunking or semantic search
- Enabled by default (`settings.ragKnowledge: false`)
- Only processes string knowledge entries
- Simpler but less sophisticated

### RAG Mode

- Advanced knowledge processing with semantic search
- Chunks content and uses embeddings
- Must be explicitly enabled (`settings.ragKnowledge: true`)
- Supports three knowledge types:
  1. Direct string knowledge
  2. Single file references: `{ "path": "path/to/file.md", "shared": false }`
  3. Directory references: `{ "directory": "knowledge/dir", "shared": false }`
- Supported file types: .md, .txt, .pdf
- Optional `shared` flag for knowledge reuse across characters

To enable RAG mode, add this to your character settings:

```typescript
const character: Character = {
  // Other character properties...
  settings: {
    ragKnowledge: true,
  },
};
```

## How Knowledge Processing Works

### Document Processing Flow

The RAG system processes documents through several stages:

1. **Directory Processing**

   - The system scans configured directories in `knowledge/`
   - Files are processed based on their shared/private status and file type

2. **File Processing Pipeline**

   - **Preprocessing**: Reading, cleaning, and normalizing text
   - **Document-level Processing**: Generating embeddings for the entire document
   - **Chunk Processing**: Splitting content into manageable chunks and generating embeddings for each

3. **Retrieval Process**
   - When a user message is received, its embedding is generated
   - This embedding is compared to stored knowledge embeddings
   - The most semantically similar chunks are retrieved
   - Retrieved knowledge is incorporated into the agent's context

This multi-level approach enables:

- Broad document-level semantic search
- Fine-grained chunk-level retrieval for specific information
- Efficient parallel processing of large documents
- Maintenance of document context through metadata linking

### Knowledge Processing Flow Diagram

```mermaid
graph TB
    subgraph Directory_Processing
        A[Read Files from Directory] --> B[File Content]
    end

    subgraph Preprocessing
        B --> C[Clean & Normalize Text]
    end

    subgraph Document_Processing
        C --> D[Generate Document Embedding]
        D --> E[Store Full Document]
        E --> |Metadata| F[File Path]
        E --> |Metadata| G[File Type]
        E --> |Metadata| H[Shared Status]
    end

    subgraph Chunk_Processing
        C --> I[Split into Chunks]
        I --> |512 tokens| J[Chunk 1]
        I --> |20 token overlap| K[...]
        I --> L[Chunk N]

        subgraph Parallel_Processing
            J --> M1[Generate Embedding]
            K --> M2[Generate Embedding]
            L --> M3[Generate Embedding]
        end

        subgraph Chunk_Storage
            M1 --> N1[Store Chunk]
            M2 --> N2[Store Chunk]
            M3 --> N3[Store Chunk]

            N1 --> |Metadata| O[Original Doc Reference]
            N1 --> |Metadata| P[Chunk Index]
            N2 --> |Metadata| O
            N2 --> |Metadata| P
            N3 --> |Metadata| O
            N3 --> |Metadata| P
        end
    end

    style Directory_Processing fill:#f9f,stroke:#333,stroke-width:2px
    style Preprocessing fill:#bbf,stroke:#333,stroke-width:2px
    style Document_Processing fill:#bfb,stroke:#333,stroke-width:2px
    style Chunk_Processing fill:#fbf,stroke:#333,stroke-width:2px
    style Parallel_Processing fill:#fbb,stroke:#333,stroke-width:2px
    style Chunk_Storage fill:#bff,stroke:#333,stroke-width:2px
```

### Processing Parameters

- **Chunk Size**: 512 tokens (default, configurable when adding knowledge)
- **Chunk Overlap**: 20 tokens (default, configurable)
- **Processing Batch Size**: 10 chunks processed concurrently
- **Default Similarity Threshold**: 0.85 for retrieval
- **Default Match Count**: 5 results returned

## Best Practices for Knowledge Management

### Content Organization

1. **Document Structure**

   - Use clear section headings and hierarchical organization
   - Break large documents into logical smaller files
   - Include metadata and context in markdown files
   - Structure information from general to specific

2. **File Management**

   - Use descriptive filenames that reflect content
   - Group related files in subdirectories
   - Keep paths short and meaningful
   - Avoid special characters in filenames

3. **Knowledge Optimization**
   - Keep individual documents focused on specific topics
   - For very detailed information, use smaller chunks (200-300 tokens) by setting `targetTokens`
   - Balance the total number of knowledge items for performance
   - Prefer markdown (.md) files for best processing results

### Processing Large Knowledge Bases

When adding many knowledge items at once, consider implementing a semaphore pattern:

```typescript
import { Semaphore } from '@elizaos/core';

// Create semaphore to limit concurrent processing
const semaphore = new Semaphore(10);

// Process items with controlled concurrency
await Promise.all(
  items.map(async (item) => {
    await semaphore.acquire();
    try {
      await runtime.addKnowledge(item);
    } finally {
      semaphore.release();
    }
  })
);
```

### Knowledge ID Management

When adding knowledge programmatically, use consistent ID generation:

```typescript
import { createUniqueUuid } from '@elizaos/core';
const knowledgeId = createUniqueUuid(runtime, 'my-content');
```

This ensures deterministic IDs that remain stable across sessions.

## Troubleshooting

### Common Issues and Solutions

1. **Knowledge Not Being Retrieved**:

   - Verify the file is in a supported format (PDF, MD, TXT)
   - Check if embeddings were properly generated
   - Ensure similarity threshold isn't too high (default: 0.85)
   - Test retrieval with more specific queries
   - Verify RAG mode is enabled if using file/directory references

2. **Poor Quality Retrievals**:

   - Break down large documents into smaller, focused files
   - Ensure document content is clear and well-structured
   - Review the chunking size and overlap settings
   - Check if the query contains too many common words

3. **Performance Issues**:

   - Monitor the total number of knowledge items
   - Consider reducing the match count for faster retrieval
   - Check embedding processing time for large documents
   - Use shared knowledge efficiently across agents

4. **File Processing Errors**:
   - Verify file permissions
   - Check if paths are correctly structured
   - Ensure PDF files are readable and not password-protected
   - Validate that text encoding is UTF-8

## Technical Implementation Details

### Knowledge ID Relationships

The RAG system uses a hierarchical ID structure to maintain relationships:

```mermaid
classDiagram
    class Document {
        +UUID id
        +String filePath
        +String fileType
        +Boolean isShared
        +Float32Array embedding
        +String content
    }

    class Fragment {
        +UUID id
        +UUID originalId
        +Number chunkIndex
        +String content
        +Float32Array embedding
        +String originalPath
    }

    Document "1" --> "*" Fragment : generates
```

#### ID Generation and Linking

Documents IDs are generated using `createUniqueUuid(runtime, path, isShared)`, making them deterministic. Fragment IDs follow the format `${documentId}-chunk-${index}` to maintain the relationship to their source document.

## API Reference

### Key Methods

#### `runtime.addKnowledge(item: KnowledgeItem, options?): Promise<void>`

Adds new knowledge to the agent.

- Parameters:
  - `item`: A knowledge item containing:
    - `id`: UUID
    - `content`: Object with `text` property
  - `options`: Optional processing configuration:
    - `targetTokens`: Number (default: 3000)
    - `overlap`: Number (default: 200)
    - `modelContextSize`: Number (default: 4096)

#### `runtime.getKnowledge(message: Memory): Promise<KnowledgeItem[]>`

Retrieves knowledge based on a message's content.

- Parameters:
  - `message`: Memory object containing user message
- Returns: Array of matching KnowledgeItem objects

### Knowledge Item Definition

```typescript
interface KnowledgeItem {
  id: UUID;
  content: {
    text: string;
    // Optional additional metadata
    [key: string]: any;
  };
}
```

## Security Considerations

1. **Access Control**:

   - Use the `shared` flag appropriately to control document access
   - Keep sensitive information in agent-specific directories
   - Regularly audit knowledge access patterns

2. **Data Privacy**:
   - Do not store sensitive personal information in knowledge files
   - Review documents for potentially sensitive content before adding
   - Implement appropriate backup and recovery procedures

## Future Considerations

1. **Scalability**:

   - Monitor knowledge base size and performance
   - Plan for regular maintenance and cleanup
   - Consider implementing document versioning

2. **Integration**:
   - Document integration points with other systems
   - Plan for potential future file format support
   - Consider implementing knowledge base analytics

## Support and Resources

- Review the implementation in `packages/core/src/ragknowledge.ts`
- Check the issue tracker for known issues and solutions
- Contribute improvements and bug fixes through pull requests
`````

## File: packages/docs/docs/core/overview.md
`````markdown
---
sidebar_position: 1
title: ElizaOS Documentation
slug: /
description: Comprehensive framework for building AI agents with persistent personalities across multiple platforms
keywords:
  [
    architecture,
    components,
    system design,
    agents,
    services,
    database,
    actions,
    providers,
    evaluators,
    plugins,
  ]
image: /img/eliza_banner.jpg
---

# ElizaOS Documentation

Welcome to ElizaOS - a comprehensive framework for building AI agents with persistent personalities across multiple platforms. ElizaOS provides the architecture, tools, and systems needed to create sophisticated agents that maintain consistent behavior, learn from interactions, and seamlessly integrate with a variety of services.

> **New to ElizaOS?** Check out [What's new in ElizaOS V2](https://eliza.how/blog/v1-v2) to understand how it compares to previous versions.

## System Architecture

ElizaOS uses a modular architecture that separates concerns while providing a cohesive framework for AI agent development:

```mermaid
graph TB
    %% Main Components with vertical orientation
    User((User)):::user

    %% First Level - Services
    PlatformServices[Services]:::services

    %% Second Level - Runtime
    AgentRuntime[Agent Runtime]:::core

    %% Core Processing Components - Side by side
    subgraph "Core Processing"
        direction LR
        Providers[Providers]:::int
        Actions[Actions]:::int
        Evaluators[Evaluators]:::int
    end

    %% Knowledge and DB - Side by side
    subgraph "Knowledge & Storage"
        direction LR
        Knowledge[Knowledge]:::int
        DB[(Database)]:::db
    end

    %% Organization Components - Vertical layout
    subgraph "Organization"
        direction TB
        Worlds[Worlds]:::struct
        Rooms[Rooms]:::struct
        Entities[Entities]:::struct
    end

    %% Development Components - Side by side
    subgraph "Development & Integration"
        direction LR
        Plugins[Plugins]:::dev
        Projects[Projects]:::dev
        Tasks[Tasks]:::dev
    end

    %% Main Flow - Vertical emphasis
    User <-->|Interaction| PlatformServices
    PlatformServices -->|Process| AgentRuntime

    %% Runtime connections - Simplified
    AgentRuntime ---|Context| Providers
    AgentRuntime ---|Behavior| Actions
    AgentRuntime ---|Analysis| Evaluators

    %% Data connections
    AgentRuntime <-->|Storage| DB
    Knowledge -->|Informs| Providers

    %% Structure connections - Clean vertical hierarchy
    AgentRuntime -->|Manages| Worlds
    Worlds -->|Contains| Rooms
    Rooms -->|Has| Entities

    %% Development connections
    Projects -->|Configure| AgentRuntime
    Plugins -->|Extend| AgentRuntime
    Tasks -->|Scheduled by| AgentRuntime

    %% Clickable nodes with links to docs
    click AgentRuntime "/docs/core/agents" "Learn about Agent Runtime"
    click PlatformServices "/docs/core/services" "Learn about Services"
    click DB "/docs/core/database" "Learn about Database Systems"
    click Actions "/docs/core/actions" "Learn about Actions"
    click Providers "/docs/core/providers" "Learn about Providers"
    click Evaluators "/docs/core/evaluators" "Learn about Evaluators"
    click Knowledge "/docs/core/knowledge" "Learn about Knowledge System"
    click Worlds "/docs/core/worlds" "Learn about Worlds"
    click Rooms "/docs/core/rooms" "Learn about Rooms"
    click Entities "/docs/core/entities" "Learn about Entities"
    click Plugins "/docs/core/plugins" "Learn about Plugins"
    click Projects "/docs/core/project" "Learn about Projects"
    click Tasks "/docs/core/tasks" "Learn about Tasks"

    %% Styling
    classDef core fill:#3498db,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef services fill:#9b59b6,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef db fill:#27ae60,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef int fill:#e74c3c,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef struct fill:#f39c12,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef dev fill:#1abc9c,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef user fill:#ecf0f1,stroke:#2c3e50,stroke-width:2px,color:#2c3e50,font-weight:bold,border-radius:50%
```

### How ElizaOS Works

When a user message is received:

1. **Service Reception**: Platform service (Discord, Telegram, etc.) receives the message
2. **Runtime Processing**: Agent runtime coordinates the response generation
3. **Context Building**: Providers supply relevant context (time, recent messages, knowledge)
4. **Action Selection**: The agent evaluates and selects appropriate actions
5. **Response Generation**: The chosen action generates a response
6. **Learning & Reflection**: Evaluators analyze the conversation for insights and learning
7. **Memory Storage**: New information is stored in the database
8. **Response Delivery**: The response is sent back through the service

This creates a continuous cycle of interaction, reflection, and improvement that allows agents to maintain consistent personalities while adapting to new information.

### Core Components

| [![Agent Runtime](/img/agentruntime.jpg)](/docs/core/agents)                                                        | [![Services](/img/services.jpg)](/docs/core/services)                                                                          | [![Database](/img/database.jpg)](/docs/core/database)                                                                        |
| ------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| **[🤖 Agent Runtime](/docs/core/agents)** — Orchestrates agent behavior, manages state, and coordinates components. | **[📚 Services](/docs/core/services)** — Enables agents to communicate across Discord, Twitter, Telegram, and other platforms. | **[💾 Database](/docs/core/database)** — Stores memories, entity data, relationships, and configuration using vector search. |

---

### Intelligence & Behavior

| [![Actions](/img/actions.jpg)](/docs/core/actions)                                                              | [![Providers](/img/providers.jpg)](/docs/core/providers)                                            | [![Evaluators](/img/evaluators.jpg)](/docs/core/evaluators)                                                           | [![Knowledge](/img/knowledge.jpg)](/docs/core/knowledge)                                           |
| --------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| **[⚡ Actions](/docs/core/actions)** — Executable capabilities for agents to respond and interact with systems. | **[🔌 Providers](/docs/core/providers)** — Supplies context to inform agent decisions in real time. | **[📊 Evaluators](/docs/core/evaluators)** — Analyzes conversations to extract insights and improve future responses. | **[🧠 Knowledge](/docs/core/knowledge)** — RAG system for document processing and semantic memory. |

---

### Structure & Organization

| [![Worlds](/img/worlds.jpg)](/docs/core/worlds)                                       | [![Rooms](/img/rooms.jpg)](/docs/core/rooms)                                      | [![Entities](/img/entities.jpg)](/docs/core/entities)                                    |
| ------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| **[🌐 Worlds](/docs/core/worlds)** — Organizes environments like servers or projects. | **[💬 Rooms](/docs/core/rooms)** — Spaces for conversation, like channels or DMs. | **[👤 Entities](/docs/core/entities)** — Represents users, bots, and other participants. |

---

### Development & Integration

| [![Plugins](/img/plugins.jpg)](/docs/core/plugins)                                   | [![Projects](/img/project.jpg)](/docs/core/project)                                     | [![Tasks](/img/tasks.jpg)](/docs/core/tasks)                                  |
| ------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **[🧩 Plugins](/docs/core/plugins)** — Modular extensions that add new capabilities. | **[📝 Projects](/docs/core/project)** — Defines and deploys agents with configurations. | **[📋 Tasks](/docs/core/tasks)** — Manages scheduled and deferred operations. |

---

## Key Concepts

### Action-Provider-Evaluator Cycle

The core of the ElizaOS system operates as a continuous cycle:

1. **Providers** gather context before response generation
2. **Actions** determine what the agent can do and are executed to generate responses
3. **Evaluators** analyze conversations after responses to extract insights
4. These insights become part of the agent's memory
5. Future **Providers** access this memory to inform new responses

This creates a virtuous cycle where agents continuously learn and improve from interactions.

### Entity-Component Architecture

ElizaOS uses an entity-component architecture for flexible data modeling:

- **Entities** are base objects with unique IDs (users, agents, etc.)
- **Components** are pieces of data attached to entities (profiles, settings, etc.)
- This approach allows for dynamic composition without complex inheritance hierarchies

### Memory System

The memory system in ElizaOS provides:

- **Vector-based semantic search** for finding relevant memories
- **Multi-level memory types** (messages, facts, knowledge)
- **Temporal awareness** through timestamped memories
- **Cross-platform continuity** while maintaining appropriate context boundaries

## Getting Started

If you're new to ElizaOS, we recommend this learning path:

1. Start with this overview to understand the system architecture
2. Explore the [Agent Runtime](/docs/core/agents) to understand the core system
3. Learn about [Projects](/docs/core/project) to set up your development environment
4. Understand how [Actions](/docs/core/actions) and [Providers](/docs/core/providers) work together
5. Explore [Services](/docs/core/services) to connect with external platforms
6. Dive into [Plugins](/docs/core/plugins) to extend functionality

## FAQ

**What's the difference between Actions, Evaluators, and Providers?**

Actions define what an agent can do and are executed during response generation. Evaluators analyze conversations after they happen to extract insights and improve future responses. Providers supply contextual information before the agent decides how to respond.

**How does ElizaOS handle cross-platform conversation context?**

ElizaOS maintains separate conversation contexts for different platforms by default, but shares entity relationships and learned facts across platforms. This ensures agents maintain a consistent understanding of users while respecting platform-specific conversation boundaries.

**How does the memory system work?**

Memory is organized into different types (messages, facts, knowledge) and stored with vector embeddings for semantic search. This allows agents to retrieve relevant memories based on context rather than just recency, creating more natural conversations.

**What's the relationship between Worlds, Rooms, and Entities?**

Worlds are container spaces (like a Discord server) that can have multiple Rooms (channels, DMs). Entities (users, agents) participate in Rooms within Worlds. This hierarchical structure mirrors real-world platforms while providing a consistent abstraction.

**How extensible is ElizaOS?**

ElizaOS is highly extensible through its plugin system. You can create custom actions, providers, evaluators, services, and more to extend functionality. The architecture is designed to be modular and composable at every level.

## Additional Resources

- [API Reference](/api) - Detailed API documentation for developers
- [GitHub Repository](https://github.com/elizaos/eliza) - Source code and contributions
- [Package Showcase](/packages) - Explore available plugins and extensions
`````

## File: packages/docs/docs/core/providers.md
`````markdown
---
sidebar_position: 5
title: Providers System
description: Understanding ElizaOS providers - components that supply real-time information and context to agents
keywords: [providers, context, information, data, integration, dynamic, private, state]
image: /img/providers.jpg
---

# 🔌 Providers

[Providers](/packages/core/src/providers.ts) are the sources of information for the agent. They provide data or state while acting as the agent's "senses", injecting real-time information into the agent's context. They serve as the eyes, ears, and other sensory inputs that allow the agent to perceive and interact with its environment, like a bridge between the agent and various external systems such as market data, wallet information, sentiment analysis, and temporal context. Anything that the agent knows is either coming from like the built-in context or from a provider. For more info, see the [providers API page](/api/interfaces/provider).

Here's an example of how providers work within ElizaOS:

- A news provider could fetch and format news.
- A computer terminal provider in a game could feed the agent information when the player is near a terminal.
- A wallet provider can provide the agent with the current assets in a wallet.
- A time provider injects the current date and time into the context.

---

## Overview

A provider's primary purpose is to supply dynamic contextual information that integrates with the agent's runtime. They format information for conversation templates and maintain consistent data access. For example:

- **Function:** Providers run during or before an action is executed.
- **Purpose:** They allow for fetching information from other APIs or services to provide different context or ways for an action to be performed.
- **Example:** Before a "Mars rover action" is executed, a provider could fetch information from another API. This fetched information can then be used to enrich the context of the Mars rover action.

The provider interface is defined in [types.ts](/packages/core/src/types.ts):

```typescript
interface Provider {
  /** Provider name */
  name: string;

  /** Description of the provider */
  description?: string;

  /** Whether the provider is dynamic */
  dynamic?: boolean;

  /** Position of the provider in the provider list, positive or negative */
  position?: number;

  /**
   * Whether the provider is private
   *
   * Private providers are not displayed in the regular provider list, they have to be called explicitly
   */
  private?: boolean;

  /** Data retrieval function */
  get: (runtime: IAgentRuntime, message: Memory, state: State) => Promise<ProviderResult>;
}
```

The `get` function takes:

- `runtime`: The agent instance calling the provider
- `message`: The last message received
- `state`: Current conversation state

It returns a `ProviderResult` object that contains:

```typescript
interface ProviderResult {
  values?: {
    [key: string]: any;
  };
  data?: {
    [key: string]: any;
  };
  text?: string;
}
```

- `values`: Key-value pairs to be merged into the agent's state values
- `data`: Additional structured data that can be used by the agent but not directly included in the context
- `text`: String that gets injected into the agent's context

---

## Provider Types and Properties

Providers come with several properties that control how and when they are used:

### Dynamic Providers

Dynamic providers are not automatically included in the context. They must be explicitly requested either in the filter list or include list when composing state.

```typescript
const dynamicProvider: Provider = {
  name: 'dynamicExample',
  description: 'A dynamic provider example',
  dynamic: true,
  get: async (runtime, message, state) => {
    // ...implementation
    return {
      text: 'Dynamic information fetched on demand',
      values: {
        /* key-value pairs */
      },
    };
  },
};
```

### Private Providers

Private providers are not included in the regular provider list and must be explicitly included in the include list when composing state.

```typescript
const privateProvider: Provider = {
  name: 'privateExample',
  description: 'A private provider example',
  private: true,
  get: async (runtime, message, state) => {
    // ...implementation
    return {
      text: 'Private information only available when explicitly requested',
      values: {
        /* key-value pairs */
      },
    };
  },
};
```

### Provider Positioning

The `position` property determines the order in which providers are processed. Lower numbers are processed first.

```typescript
const earlyProvider: Provider = {
  name: 'earlyExample',
  description: 'Runs early in the provider chain',
  position: -100,
  get: async (runtime, message, state) => {
    // ...implementation
    return {
      text: 'Early information',
      values: {
        /* key-value pairs */
      },
    };
  },
};

const lateProvider: Provider = {
  name: 'lateExample',
  description: 'Runs late in the provider chain',
  position: 100,
  get: async (runtime, message, state) => {
    // ...implementation
    return {
      text: 'Late information that might depend on earlier providers',
      values: {
        /* key-value pairs */
      },
    };
  },
};
```

---

## State Composition with Providers

The runtime composes state by gathering data from enabled providers. When calling `composeState`, you can control which providers are used:

```typescript
// Get state with all non-private, non-dynamic providers
const state = await runtime.composeState(message);

// Get state with specific providers only
const filteredState = await runtime.composeState(
  message,
  ['timeProvider', 'factsProvider'], // Only include these providers
  null
);

// Include private or dynamic providers
const enhancedState = await runtime.composeState(
  message,
  null,
  ['privateExample', 'dynamicExample'] // Include these private/dynamic providers
);
```

The system caches provider results to optimize performance. When a provider is called multiple times with the same message, the cached result is used unless you explicitly request a new evaluation.

---

## Examples

ElizaOS providers typically fall into these categories, with examples from the ecosystem:

### System & Integration

- **Time Provider**: Injects current date/time for temporal awareness
- **Giphy Provider**: Provides GIF responses using Giphy API
- **GitBook Provider**: Supplies documentation context from GitBook
- **Topics Provider**: Caches and serves Allora Network topic information

### Blockchain & DeFi

- **Wallet Provider**: Portfolio data from Zerion, balances and prices
- **DePIN Provider**: Network metrics via DePINScan API
- **Chain Providers**: Data from Abstract, Fuel, ICP, EVM networks
- **Market Provider**: Token data from DexScreener, Birdeye APIs

### Knowledge & Data

- **DKG Provider**: OriginTrail decentralized knowledge integration
- **News Provider**: Current events via NewsAPI
- **Trust Provider**: Calculates and injects trust scores

Visit the [ElizaOS Plugin Registry](https://github.com/elizaos-plugins/registry) for a complete list of available plugins and providers.

### Time Provider Example

```typescript
const timeProvider: Provider = {
  name: 'time',
  description: 'Provides the current date and time',
  position: -10, // Run early to ensure time is available for other providers
  get: async (_runtime: IAgentRuntime, _message: Memory) => {
    const currentDate = new Date();
    const options = {
      timeZone: 'UTC',
      dateStyle: 'full' as const,
      timeStyle: 'long' as const,
    };
    const humanReadable = new Intl.DateTimeFormat('en-US', options).format(currentDate);

    return {
      text: `The current date and time is ${humanReadable}. Please use this as your reference for any time-based operations or responses.`,
      values: {
        currentDate: currentDate.toISOString(),
        humanReadableDate: humanReadable,
      },
    };
  },
};
```

### Dynamic Provider Example

```typescript
const weatherProvider: Provider = {
  name: 'weather',
  description: 'Provides weather information for a location',
  dynamic: true, // Only used when explicitly requested
  get: async (runtime: IAgentRuntime, message: Memory, state: State) => {
    // Extract location from state if available
    const location = state?.values?.location || 'San Francisco';

    try {
      // Fetch weather data from an API
      const weatherData = await fetchWeatherData(location);

      return {
        text: `The current weather in ${location} is ${weatherData.description} with a temperature of ${weatherData.temperature}°C.`,
        values: {
          weather: {
            location,
            temperature: weatherData.temperature,
            description: weatherData.description,
            humidity: weatherData.humidity,
          },
        },
        data: {
          // Additional detailed data that doesn't go into the context
          weatherDetails: weatherData,
        },
      };
    } catch (error) {
      // Handle errors gracefully
      return {
        text: `I couldn't retrieve weather information for ${location} at this time.`,
        values: {
          weather: { error: true },
        },
      };
    }
  },
};
```

---

## Best Practices

### 1. Optimize for Efficiency

- Return both structured data (`values`) and formatted text (`text`)
- Use caching for expensive operations
- Include a clear provider name and description

```typescript
const efficientProvider: Provider = {
  name: 'efficientExample',
  description: 'Efficiently provides cached data',
  get: async (runtime, message) => {
    // Check for cached data
    const cacheKey = `data:${message.roomId}`;
    const cachedData = await runtime.getCache(cacheKey);

    if (cachedData) {
      return cachedData;
    }

    // Fetch fresh data if not cached
    const result = {
      text: 'Freshly generated information',
      values: {
        /* key-value pairs */
      },
      data: {
        /* structured data */
      },
    };

    // Cache the result with appropriate TTL
    await runtime.setCache(cacheKey, result, { expires: 30 * 60 * 1000 }); // 30 minutes

    return result;
  },
};
```

### 2. Handle Errors Gracefully

Always handle errors without throwing exceptions that would interrupt the agent's processing:

```typescript
try {
  // Risky operation
} catch (error) {
  return {
    text: "I couldn't retrieve that information right now.",
    values: { error: true },
  };
}
```

### 3. Use Position for Optimal Order

Position providers according to their dependencies:

- Negative positions: Fundamental information providers (time, location)
- Zero (default): Standard information providers
- Positive positions: Providers that depend on other information

### 4. Structure Return Values Consistently

Maintain a consistent structure in your provider's return values to make data easier to use across the system.

---

## FAQ

### What's the difference between values, data, and text?

- `values`: These are merged into the agent state and can be accessed by other providers
- `data`: Structured data stored in state.data.providers but not directly exposed to the agent
- `text`: Formatted text that's directly injected into the agent's context

### When should I use a dynamic provider?

Use dynamic providers when the information is expensive to compute, only relevant in specific situations, or requires explicit triggering rather than being included in every context.

### How do I explicitly include a private provider?

Private providers must be included in the `includeList` parameter when calling `composeState`:

```typescript
const state = await runtime.composeState(message, null, ['privateProviderName']);
```

### Can providers access service functionality?

Yes, providers can use services through the runtime. For example, a wallet provider might use a blockchain service to fetch data:

```typescript
const walletProvider: Provider = {
  name: 'wallet',
  get: async (runtime, message) => {
    const solanaService = runtime.getService('solana');
    if (!solanaService) {
      return { text: '' };
    }

    const walletData = await solanaService.getCachedData();
    // Process and return wallet data
  },
};
```

### How should providers handle failures?

Providers should handle failures gracefully and return valid ProviderResult objects with appropriate error information. Never throw errors that would break the agent's context composition.

### Can providers maintain state between calls?

While providers can maintain internal state (e.g., through closures), it's better to use the runtime's cache system for persistence:

```typescript
// Store data
await runtime.setCache('myProvider:someKey', dataToStore);

// Retrieve data later
const storedData = await runtime.getCache('myProvider:someKey');
```

---

## Further Reading

- [Provider Implementation](/packages/core/src/providers.ts)
- [Types Reference](/packages/core/src/types.ts)
- [Runtime Integration](/packages/core/src/runtime.ts)
`````

## File: packages/docs/docs/core/rooms.md
`````markdown
---
sidebar_position: 8
title: Rooms System
description: Understanding ElizaOS rooms - interaction spaces for entities to exchange messages and communicate
keywords: [rooms, channels, conversations, participants, messages, interaction, communication]
image: /img/elizaos-rooms-simplified.svg
---

# Rooms

Rooms in ElizaOS represent individual interaction spaces within a world. A room can be a conversation, a channel, a thread, or any other defined space where entities can exchange messages and interact. Rooms are typically contained within a world, though they can also exist independently.

![](/img/elizaos-rooms-simplified.svg)

## Room Structure

A room in ElizaOS has the following properties:

```typescript
type Room = {
  id: UUID;
  name?: string;
  agentId?: UUID;
  source: string;
  type: ChannelType;
  channelId?: string;
  serverId?: string;
  worldId?: UUID;
  metadata?: Record<string, unknown>;
};
```

| Property    | Description                                                      |
| ----------- | ---------------------------------------------------------------- |
| `id`        | Unique identifier for the room                                   |
| `name`      | Optional display name for the room                               |
| `agentId`   | Optional ID of the agent associated with this room               |
| `source`    | The platform or origin of the room (e.g., 'discord', 'telegram') |
| `type`      | Type of room (DM, GROUP, THREAD, etc.)                           |
| `channelId` | External system channel identifier                               |
| `serverId`  | External system server identifier                                |
| `worldId`   | Optional ID of the parent world                                  |
| `metadata`  | Additional room configuration data                               |

## Room Types

ElizaOS supports several room types, defined in the `ChannelType` enum:

| Type          | Description                               |
| ------------- | ----------------------------------------- |
| `SELF`        | Messages to self                          |
| `DM`          | Direct messages between two participants  |
| `GROUP`       | Group messages with multiple participants |
| `VOICE_DM`    | Voice direct messages                     |
| `VOICE_GROUP` | Voice channels with multiple participants |
| `FEED`        | Social media feed                         |
| `THREAD`      | Threaded conversation                     |
| `WORLD`       | World channel                             |
| `FORUM`       | Forum discussion                          |
| `API`         | Legacy type - Use DM or GROUP instead     |

## Room Creation and Management

### Creating a Room

You can create a new room using the AgentRuntime:

```typescript
const roomId = await runtime.createRoom({
  name: 'general-chat',
  source: 'discord',
  type: ChannelType.GROUP,
  channelId: 'external-channel-id',
  serverId: 'external-server-id',
  worldId: parentWorldId,
});
```

### Ensuring a Room Exists

To create a room if it doesn't already exist:

```typescript
await runtime.ensureRoomExists({
  id: roomId,
  name: 'general-chat',
  source: 'discord',
  type: ChannelType.GROUP,
  channelId: 'external-channel-id',
  serverId: 'external-server-id',
  worldId: parentWorldId,
});
```

### Retrieving Room Information

```typescript
// Get a specific room
const room = await runtime.getRoom(roomId);

// Get all rooms in a world
const worldRooms = await runtime.getRooms(worldId);
```

### Updating Room Properties

```typescript
await runtime.updateRoom({
  id: roomId,
  name: 'renamed-channel',
  metadata: {
    ...room.metadata,
    customProperty: 'value',
  },
});
```

### Deleting a Room

```typescript
await runtime.deleteRoom(roomId);
```

## Participants in Rooms

Rooms can have multiple participants (entities) that can exchange messages.

### Managing Room Participants

```typescript
// Add a participant to a room
await runtime.addParticipant(entityId, roomId);

// Remove a participant from a room
await runtime.removeParticipant(entityId, roomId);

// Get all participants in a room
const participants = await runtime.getParticipantsForRoom(roomId);

// Get all rooms where an entity is a participant
const entityRooms = await runtime.getRoomsForParticipant(entityId);
```

### Participant States

Participants can have different states in a room:

```typescript
// Get a participant's state in a room
const state = await runtime.getParticipantUserState(roomId, entityId);
// Returns: 'FOLLOWED', 'MUTED', or null

// Set a participant's state in a room
await runtime.setParticipantUserState(roomId, entityId, 'FOLLOWED');
```

The participant states are:

| State      | Description                                                                               |
| ---------- | ----------------------------------------------------------------------------------------- |
| `FOLLOWED` | The agent actively follows the conversation and responds without being directly mentioned |
| `MUTED`    | The agent ignores messages in this room                                                   |
| `null`     | Default state - the agent responds only when directly mentioned                           |

## Following and Unfollowing Rooms

ElizaOS allows agents to "follow" rooms to actively participate in conversations without being explicitly mentioned. This functionality is managed through the `FOLLOW_ROOM` and `UNFOLLOW_ROOM` actions.

```typescript
// Follow a room (typically triggered by an action)
await runtime.setParticipantUserState(roomId, runtime.agentId, 'FOLLOWED');

// Unfollow a room
await runtime.setParticipantUserState(roomId, runtime.agentId, null);
```

## Memory and Messages in Rooms

Rooms store messages as memories in the database:

```typescript
// Create a new message in a room
const messageId = await runtime.createMemory(
  {
    entityId: senderEntityId,
    agentId: runtime.agentId,
    roomId: roomId,
    content: {
      text: 'Hello, world!',
      source: 'discord',
    },
    metadata: {
      type: 'message',
    },
  },
  'messages'
);

// Retrieve recent messages from a room
const messages = await runtime.getMemories({
  roomId: roomId,
  count: 10,
  unique: true,
});
```

## Events Related to Rooms

ElizaOS emits events related to room activities:

| Event              | Description                                  |
| ------------------ | -------------------------------------------- |
| `ROOM_JOINED`      | Emitted when an entity joins a room          |
| `ROOM_LEFT`        | Emitted when an entity leaves a room         |
| `MESSAGE_RECEIVED` | Emitted when a message is received in a room |
| `MESSAGE_SENT`     | Emitted when a message is sent to a room     |

### Handling Room Events

```typescript
// Register event handlers in your plugin
const myPlugin: Plugin = {
  name: 'my-room-plugin',
  description: 'Handles room events',

  events: {
    [EventTypes.ROOM_JOINED]: [
      async (payload) => {
        const { runtime, entityId, roomId } = payload;
        console.log(`Entity ${entityId} joined room ${roomId}`);
      },
    ],

    [EventTypes.MESSAGE_RECEIVED]: [
      async (payload: MessagePayload) => {
        const { runtime, message } = payload;
        console.log(`Message received in room ${message.roomId}`);
      },
    ],
  },
};
```

## Room Connection with External Systems

When integrating with external platforms, rooms are typically mapped to channels, conversations, or other interaction spaces:

```typescript
// Ensure the connection exists for a room from an external system
await runtime.ensureConnection({
  entityId: userEntityId,
  roomId: roomId,
  userName: 'username',
  name: 'display-name',
  source: 'discord',
  channelId: 'external-channel-id',
  serverId: 'external-server-id',
  type: ChannelType.GROUP,
  worldId: parentWorldId,
});
```

## Best Practices

1. **Use appropriate room types**: Select the most appropriate room type for each interaction context
2. **Follow relationship order**: Create worlds before creating rooms, as rooms often have a parent world
3. **Use ensureRoomExists**: Use this method to avoid duplicate rooms when syncing with external systems
4. **Clean up rooms**: Delete rooms when they're no longer needed to prevent database bloat
5. **Room metadata**: Use metadata for room-specific configuration that doesn't fit into the standard properties
6. **Follow state management**: Implement clear rules for when agents should follow or unfollow rooms
7. **Handle participants carefully**: Ensure that participant management aligns with external platform behavior
`````

## File: packages/docs/docs/core/services.md
`````markdown
---
sidebar_position: 3
title: Services System
description: Understanding ElizaOS services - core components that enable AI agents to interact with external platforms
keywords: [services, platforms, integration, Discord, Twitter, Telegram, communication, API]
image: /img/services.jpg
---

# 🔌 Services

Services are core components in Eliza that enable AI agents to interact with external platforms and services. Each service provides a specialized interface for communication while maintaining consistent agent behavior across different platforms.

---

## Supported Services

| Service                                                                            | Type          | Key Features                                                                           | Use Cases                                                            |
| ---------------------------------------------------------------------------------- | ------------- | -------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| [Discord](https://github.com/elizaos-plugins/plugin-discord)                       | Communication | • Voice channels • Server management • Moderation tools • Channel management           | • Community management • Gaming servers • Event coordination         |
| [Twitter](https://github.com/elizaos-plugins/plugin-twitter)                       | Social Media  | • Post scheduling • Timeline monitoring • Engagement analytics • Content automation    | • Brand management • Content creation • Social engagement            |
| [Telegram](https://github.com/elizaos-plugins/plugin-telegram)                     | Messaging     | • Bot API • Group chat • Media handling • Command system                               | • Customer support • Community engagement • Broadcast messaging      |
| [Direct](https://github.com/elizaOS/eliza/tree/develop/packages/plugin-direct/src) | API           | • REST endpoints • Web integration • Custom applications • Real-time communication     | • Backend integration • Web apps • Custom interfaces                 |
| [GitHub](https://github.com/elizaos-plugins/plugin-github)                         | Development   | • Repository management • Issue tracking • Pull requests • Code review                 | • Development workflow • Project management • Team collaboration     |
| [Slack](https://github.com/elizaos-plugins/plugin-slack)                           | Enterprise    | • Channel management • Conversation analysis • Workspace tools • Integration hooks     | • Team collaboration • Process automation • Internal tools           |
| [Lens](https://github.com/elizaos-plugins/plugin-lens)                             | Web3          | • Decentralized networking • Content publishing • Memory management • Web3 integration | • Web3 social networking • Content distribution • Decentralized apps |
| [Farcaster](https://github.com/elizaos-plugins/plugin-farcaster)                   | Web3          | • Decentralized social • Content publishing • Community engagement                     | • Web3 communities • Content creation • Social networking            |
| [Auto](https://github.com/elizaos-plugins/plugin-auto)                             | Automation    | • Workload management • Task scheduling • Process automation                           | • Background jobs • Automated tasks • System maintenance             |

**\*Additional services**:

- Instagram: Social media content and engagement
- XMTP: Web3 messaging and communications
- Alexa: Voice interface and smart device control
- Home Assistant: Home automation OS
- Devai.me: AI first social service
- Simsai: Jeeter / Social media platform for AI

---

## System Overview

Services serve as bridges between Eliza agents and various platforms, providing core capabilities:

1. **Message Processing**

   - Platform-specific message formatting and delivery
   - Media handling and attachments via [`Memory`](/api/interfaces/Memory) objects
   - Reply threading and context management
   - Support for different content types

2. **State & Memory Management**

   - Each service maintains independent state to prevent cross-platform contamination
   - Integrates with runtime memory managers for different types of content:
   - Messages processed by one service don't automatically appear in other services' contexts
   - [`State`](/api/interfaces/State) persists across agent restarts through the database adapter

3. **Platform Integration**
   - Authentication and API compliance
   - Event processing and webhooks
   - Rate limiting and cache management
   - Platform-specific feature support

## Service Configuration

Services are configured through the [`Character`](/api/type-aliases/Character) configuration's `settings` property:

```typescript
export type Character = {
  // ... other properties ...
  settings?: {
    discord?: {
      shouldIgnoreBotMessages?: boolean;
      shouldIgnoreDirectMessages?: boolean;
      shouldRespondOnlyToMentions?: boolean;
      messageSimilarityThreshold?: number;
      isPartOfTeam?: boolean;
      teamAgentIds?: string[];
      teamLeaderId?: string;
      teamMemberInterestKeywords?: string[];
      allowedChannelIds?: string[];
      autoPost?: {
        enabled?: boolean;
        monitorTime?: number;
        inactivityThreshold?: number;
        mainChannelId?: string;
        announcementChannelIds?: string[];
        minTimeBetweenPosts?: number;
      };
    };
    telegram?: {
      shouldIgnoreBotMessages?: boolean;
      shouldIgnoreDirectMessages?: boolean;
      shouldRespondOnlyToMentions?: boolean;
      shouldOnlyJoinInAllowedGroups?: boolean;
      allowedGroupIds?: string[];
      messageSimilarityThreshold?: number;
      // ... other telegram-specific settings
    };
    slack?: {
      shouldIgnoreBotMessages?: boolean;
      shouldIgnoreDirectMessages?: boolean;
    };
    // ... other service configs
  };
};
```

## Service Implementation

Each service manages its own:

- Platform-specific message formatting and delivery
- Event processing and webhooks
- Authentication and API integration
- Message queueing and rate limiting
- Media handling and attachments
- State management and persistence

Example of a basic service implementation:

```typescript
import { Service, IAgentRuntime } from '@elizaos/core';

export class CustomService extends Service {
  static serviceType = 'custom';
  capabilityDescription = 'The agent is able to interact with the custom platform';

  constructor(protected runtime: IAgentRuntime) {
    super();
    // Initialize platform connection
    // Set up event handlers
    // Configure message processing
  }

  static async start(runtime: IAgentRuntime): Promise<CustomService> {
    const service = new CustomService(runtime);
    // Additional initialization if needed
    return service;
  }

  async stop(): Promise<void> {
    // Cleanup resources
    // Close connections
  }
}
```

### Runtime Integration

Services interact with the agent runtime through the [`IAgentRuntime`](api/interfaces/IAgentRuntime/) interface, which provides:

- Memory managers for different types of data storage
- Service access for capabilities like transcription or image generation
- State management and composition
- Message processing and action handling

### Memory System Integration

Services use the runtime's memory managers to persist conversation data (source: [`memory.ts`](/api/interfaces/Memory)).

- `messageManager` Chat messages
- `documentsManager` File attachments
- `descriptionManager` Media descriptions

<details>
<summary>See example</summary>
```typescript
// Store a new message
await runtime.messageManager.createMemory({
    id: messageId,
    content: { text: message.content },
    userId: userId,
    roomId: roomId,
    agentId: runtime.agentId
});

// Retrieve recent messages
const recentMessages = await runtime.messageManager.getMemories({
roomId: roomId,
count: 10
});

```
</details>


---

## FAQ

### What can services actually do?

Services handle platform-specific communication (like Discord messages or Twitter posts), manage memories and state, and execute actions like processing media or handling commands. Each service adapts these capabilities to its platform while maintaining consistent agent behavior.

### Can multiple services be used simultaneously?
Yes, Eliza supports running multiple services concurrently while maintaining consistent agent behavior across platforms.

### How are service-specific features handled?
Each service implements platform-specific features through its capabilities system, while maintaining a consistent interface for the agent.

### How do services handle rate limits?
Services implement platform-specific rate limiting with backoff strategies and queue management.

### How is service state managed?
Services maintain their own connection state while integrating with the agent's runtime database adapter and memory / state management system.

### How do services handle messages?

Services translate platform messages into Eliza's internal format, process any attachments (images, audio, etc.), maintain conversation context, and manage response queuing and rate limits.

### How are messages processed across services?
Each service processes messages independently in its platform-specific format, while maintaining conversation context through the shared memory system. V2 improves upon this architecture.

### How is state managed between services?
Each service maintains separate state to prevent cross-contamination, but can access shared agent state through the runtime.


### How do services integrate with platforms?

Each service implements platform-specific authentication, API compliance, webhook handling, and follows the platform's rules for rate limiting and content formatting.

### How do services manage memory?

Services use Eliza's memory system to track conversations, user relationships, and state, enabling context-aware responses and persistent interactions across sessions.
```
`````

## File: packages/docs/docs/core/tasks.md
`````markdown
---
sidebar_position: 9
title: Tasks System
description: Understanding ElizaOS tasks - managing deferred, scheduled, and interactive operations
keywords: [tasks, scheduling, automation, workers, recurring tasks, task management]
image: /img/tasks.jpg
---

# Tasks

Tasks in ElizaOS provide a powerful way to manage deferred, scheduled, and interactive operations. The Task system allows agents to queue work for later execution, repeat actions at defined intervals, await user input, and implement complex workflows across multiple interactions.

## Task Structure

A task in ElizaOS has the following properties:

```typescript
interface Task {
  id?: UUID; // Unique identifier (auto-generated if not provided)
  name: string; // Name of the task (must match a registered task worker)
  updatedAt?: number; // Timestamp when the task was last updated
  metadata?: {
    // Optional additional configuration
    updateInterval?: number; // For repeating tasks: milliseconds between executions
    options?: {
      // For choice tasks: options for user selection
      name: string;
      description: string;
    }[];
    [key: string]: unknown; // Additional custom metadata
  };
  description: string; // Human-readable description of the task
  roomId?: UUID; // Optional room association (for room-specific tasks)
  worldId?: UUID; // Optional world association (for world-specific tasks)
  tags: string[]; // Tags for categorizing and filtering tasks
}
```

## Task Workers

Task workers define the actual logic that executes when a task runs. Each task worker is registered with the runtime and is identified by name.

```typescript
interface TaskWorker {
  name: string; // Matches the name in the Task
  execute: (
    runtime: IAgentRuntime,
    options: { [key: string]: unknown }, // Options passed during execution
    task: Task // The task being executed
  ) => Promise<void>;
  validate?: (
    // Optional validation before execution
    runtime: IAgentRuntime,
    message: Memory,
    state: State
  ) => Promise<boolean>;
}
```

## Creating and Managing Tasks

### Registering a Task Worker

Before creating tasks, you must register a worker to handle the execution:

```typescript
runtime.registerTaskWorker({
  name: 'SEND_REMINDER',
  validate: async (runtime, message, state) => {
    // Optional validation logic
    return true;
  },
  execute: async (runtime, options, task) => {
    // Task execution logic
    const { roomId } = task;
    const { reminder, userId } = options;

    await runtime.createMemory(
      {
        entityId: runtime.agentId,
        roomId,
        content: {
          text: `Reminder for <@${userId}>: ${reminder}`,
        },
      },
      'messages'
    );

    // Delete the task after it's completed
    await runtime.deleteTask(task.id);
  },
});
```

### Creating a One-time Task

Create a task that will execute once:

```typescript
await runtime.createTask({
  name: 'SEND_REMINDER',
  description: 'Send a reminder message to the user',
  roomId: currentRoomId,
  tags: ['reminder', 'one-time'],
  metadata: {
    userId: message.entityId,
    reminder: 'Submit your weekly report',
    scheduledFor: Date.now() + 86400000, // 24 hours from now
  },
});
```

### Creating a Recurring Task

Create a task that repeats at regular intervals:

```typescript
await runtime.createTask({
  name: 'DAILY_REPORT',
  description: 'Generate and post the daily report',
  roomId: announcementChannelId,
  worldId: serverWorldId,
  tags: ['report', 'repeat', 'daily'],
  metadata: {
    updateInterval: 86400000, // 24 hours in milliseconds
    updatedAt: Date.now(), // When the task was last updated/executed
  },
});
```

### Creating a Task Awaiting User Choice

Create a task that presents options and waits for user input:

```typescript
await runtime.createTask({
  name: 'CONFIRM_ACTION',
  description: 'Confirm the requested action',
  roomId: message.roomId,
  tags: ['confirmation', 'AWAITING_CHOICE'],
  metadata: {
    options: [
      { name: 'confirm', description: 'Proceed with the action' },
      { name: 'cancel', description: 'Cancel the action' },
    ],
    action: 'DELETE_FILES',
    files: ['document1.txt', 'document2.txt'],
  },
});
```

### Managing Tasks

Retrieve, update, and delete tasks as needed:

```typescript
// Get tasks by specific criteria
const reminderTasks = await runtime.getTasks({
  roomId: currentRoomId,
  tags: ['reminder'],
});

// Get tasks by name
const reportTasks = await runtime.getTasksByName('DAILY_REPORT');

// Get a specific task
const task = await runtime.getTask(taskId);

// Update a task
await runtime.updateTask(taskId, {
  description: 'Updated description',
  metadata: {
    ...task.metadata,
    priority: 'high',
  },
});

// Delete a task
await runtime.deleteTask(taskId);
```

## Task Processing

Tasks are processed based on their configuration:

### One-time Tasks

Tasks without an `updateInterval` are executed once when triggered by your code. You are responsible for scheduling their execution by checking for pending tasks in appropriate contexts.

### Recurring Tasks

Tasks with an `updateInterval` are automatically considered for re-execution when:

1. The current time exceeds `updatedAt + updateInterval`
2. Your code explicitly checks for pending recurring tasks

To process recurring tasks, implement logic like this:

```typescript
// In an initialization function or periodic check
async function processRecurringTasks() {
  const now = Date.now();
  const recurringTasks = await runtime.getTasks({
    tags: ['repeat'],
  });

  for (const task of recurringTasks) {
    if (!task.metadata?.updateInterval) continue;

    const lastUpdate = task.metadata.updatedAt || 0;
    const interval = task.metadata.updateInterval;

    if (now >= lastUpdate + interval) {
      const worker = runtime.getTaskWorker(task.name);
      if (worker) {
        try {
          await worker.execute(runtime, {}, task);

          // Update the task's last update time
          await runtime.updateTask(task.id, {
            metadata: {
              ...task.metadata,
              updatedAt: now,
            },
          });
        } catch (error) {
          logger.error(`Error executing task ${task.name}: ${error}`);
        }
      }
    }
  }
}
```

### Tasks Awaiting User Input

Tasks tagged with `AWAITING_CHOICE` are presented to users and wait for their input. These tasks use:

1. The `choice` provider to display available options to users
2. The `CHOOSE_OPTION` action to process user selections

## Common Task Patterns

### Deferred Follow-ups

Create a task to follow up with a user later:

```typescript
runtime.registerTaskWorker({
  name: 'FOLLOW_UP',
  execute: async (runtime, options, task) => {
    const { roomId } = task;
    const { userId, topic } = task.metadata;

    await runtime.createMemory(
      {
        entityId: runtime.agentId,
        roomId,
        content: {
          text: `Hi <@${userId}>, I'm following up about ${topic}. Do you have any updates?`,
        },
      },
      'messages'
    );

    await runtime.deleteTask(task.id);
  },
});

// Create a follow-up task for 2 days later
await runtime.createTask({
  name: 'FOLLOW_UP',
  description: 'Follow up with user about project status',
  roomId: message.roomId,
  tags: ['follow-up', 'one-time'],
  metadata: {
    userId: message.entityId,
    topic: 'the project timeline',
    scheduledFor: Date.now() + 2 * 86400000, // 2 days
  },
});
```

### Multi-step Workflows

Implement complex workflows that span multiple interactions:

```typescript
// First step: Gather requirements
runtime.registerTaskWorker({
  name: 'GATHER_REQUIREMENTS',
  execute: async (runtime, options, task) => {
    // Ask user for requirements and create a new task for the next step
    await runtime.createTask({
      name: 'CONFIRM_REQUIREMENTS',
      description: 'Confirm gathered requirements',
      roomId: task.roomId,
      tags: ['workflow', 'AWAITING_CHOICE'],
      metadata: {
        previousStep: 'GATHER_REQUIREMENTS',
        requirements: options.requirements,
        options: [
          { name: 'confirm', description: 'Confirm requirements are correct' },
          { name: 'revise', description: 'Need to revise requirements' },
        ],
      },
    });

    await runtime.deleteTask(task.id);
  },
});

// Second step: Confirm requirements
runtime.registerTaskWorker({
  name: 'CONFIRM_REQUIREMENTS',
  execute: async (runtime, options, task) => {
    if (options.option === 'confirm') {
      // Move to the next step
      await runtime.createTask({
        name: 'GENERATE_SOLUTION',
        description: 'Generate solution based on requirements',
        roomId: task.roomId,
        tags: ['workflow'],
        metadata: {
          previousStep: 'CONFIRM_REQUIREMENTS',
          requirements: task.metadata.requirements,
        },
      });
    } else {
      // Go back to requirements gathering
      await runtime.createTask({
        name: 'GATHER_REQUIREMENTS',
        description: 'Revise requirements',
        roomId: task.roomId,
        tags: ['workflow'],
        metadata: {
          previousStep: 'CONFIRM_REQUIREMENTS',
          previousRequirements: task.metadata.requirements,
        },
      });
    }

    await runtime.deleteTask(task.id);
  },
});
```

### Scheduled Reports

Create tasks that generate and post reports on a schedule:

```typescript
runtime.registerTaskWorker({
  name: 'GENERATE_WEEKLY_REPORT',
  execute: async (runtime, options, task) => {
    const { roomId } = task;

    // Generate report content
    const reportData = await generateWeeklyReport(runtime);

    // Post the report
    await runtime.createMemory(
      {
        entityId: runtime.agentId,
        roomId,
        content: {
          text: `# Weekly Report\n\n${reportData}`,
        },
      },
      'messages'
    );

    // The task stays active for next week (updateInterval handles timing)
  },
});

// Create a weekly report task
await runtime.createTask({
  name: 'GENERATE_WEEKLY_REPORT',
  description: 'Generate and post weekly activity report',
  roomId: reportChannelId,
  worldId: serverWorldId,
  tags: ['report', 'repeat', 'weekly'],
  metadata: {
    updateInterval: 7 * 86400000, // 7 days
    updatedAt: Date.now(),
    format: 'markdown',
  },
});
```

## Task Events and Monitoring

ElizaOS doesn't currently provide built-in events for task lifecycle, so implement your own monitoring if needed:

```typescript
// Custom monitoring for task execution
async function executeTaskWithMonitoring(runtime, taskWorker, task) {
  try {
    // Create a start log
    await runtime.log({
      body: { taskId: task.id, action: 'start' },
      entityId: runtime.agentId,
      roomId: task.roomId,
      type: 'TASK_EXECUTION',
    });

    // Execute the task
    await taskWorker.execute(runtime, {}, task);

    // Create a completion log
    await runtime.log({
      body: { taskId: task.id, action: 'complete', success: true },
      entityId: runtime.agentId,
      roomId: task.roomId,
      type: 'TASK_EXECUTION',
    });
  } catch (error) {
    // Create an error log
    await runtime.log({
      body: { taskId: task.id, action: 'error', error: error.message },
      entityId: runtime.agentId,
      roomId: task.roomId,
      type: 'TASK_EXECUTION',
    });
  }
}
```

## Best Practices

1. **Use descriptive names and descriptions**: Make tasks easily identifiable with clear names and descriptions

2. **Clean up completed tasks**: Delete one-time tasks after execution to prevent database bloat

3. **Add error handling**: Implement robust error handling in task workers to prevent failures from breaking workflows

4. **Use appropriate tags**: Tag tasks effectively for easy retrieval and categorization

5. **Validate carefully**: Use the `validate` function to ensure tasks only execute in appropriate contexts

6. **Keep tasks atomic**: Design tasks to perform specific, well-defined operations rather than complex actions

7. **Provide clear choices**: When creating choice tasks, make option names and descriptions clear and unambiguous

8. **Manage task lifecycles**: Have a clear strategy for when tasks are created, updated, and deleted

9. **Set reasonable intervals**: For recurring tasks, choose appropriate update intervals that balance timeliness and resource usage

10. **Handle concurrent execution**: Ensure task execution is idempotent to handle potential concurrent executions
`````

## File: packages/docs/docs/core/worlds.md
`````markdown
---
sidebar_position: 7
title: World System
description: Understanding ElizaOS worlds - virtual spaces for agent interactions and communication
keywords: [worlds, environments, spaces, rooms, entities, roles, permissions, events]
image: /img/elizaos-worlds-cosmic-clean.svg
---

# Worlds

Worlds in ElizaOS are collections of entities (users, agents) and rooms (conversations, channels) that form a cohesive environment for interactions. Think of a world as a virtual space, like a Discord server, Slack workspace, or 3D MMO environment, where entities can communicate across multiple channels or areas.

![](/img/elizaos-worlds-cosmic-clean.svg)

Within each world you can have rooms, which are akin to individual threads or channels in a server.

![](/img/elizaos-worlds-simplified.svg)

## World Structure

A world in ElizaOS has the following properties:

```typescript
type World = {
  id: UUID;
  name?: string;
  agentId: UUID;
  serverId: string;
  metadata?: {
    ownership?: {
      ownerId: string;
    };
    roles?: {
      [entityId: UUID]: Role;
    };
    [key: string]: unknown;
  };
};
```

| Property   | Description                                          |
| ---------- | ---------------------------------------------------- |
| `id`       | Unique identifier for the world                      |
| `name`     | Optional display name                                |
| `agentId`  | ID of the agent managing this world                  |
| `serverId` | External system identifier (e.g., Discord server ID) |
| `metadata` | Additional world configuration data                  |

The metadata can store custom information, including ownership details and role assignments for entities within the world.

## World Creation and Management

### Creating a World

You can create a new world using the AgentRuntime:

```typescript
const worldId = await runtime.createWorld({
  name: 'My Project Space',
  agentId: runtime.agentId,
  serverId: 'external-system-id',
  metadata: {
    ownership: {
      ownerId: ownerEntityId,
    },
  },
});
```

For many integrations, worlds are automatically created during connection setup with external platforms like Discord or Slack.

### Ensuring a World Exists

If you're not sure if a world exists, you can use `ensureWorldExists()`:

```typescript
await runtime.ensureWorldExists({
  id: worldId,
  name: 'My Project Space',
  agentId: runtime.agentId,
  serverId: 'external-system-id',
});
```

### Retrieving World Information

```typescript
// Get a specific world
const world = await runtime.getWorld(worldId);

// Get all worlds
const allWorlds = await runtime.getAllWorlds();
```

### Updating World Properties

```typescript
await runtime.updateWorld({
  id: worldId,
  name: 'Updated Name',
  metadata: {
    ...world.metadata,
    customProperty: 'value',
  },
});
```

## World Roles System

Worlds support a role-based permission system with the following roles:

| Role    | Description                                           |
| ------- | ----------------------------------------------------- |
| `OWNER` | Full control over the world, can assign any roles     |
| `ADMIN` | Administrative capabilities, can manage most settings |
| `NONE`  | Standard participant with no special permissions      |

### Managing Roles

Roles are stored in the world's metadata and can be updated:

```typescript
// Get existing world
const world = await runtime.getWorld(worldId);

// Ensure roles object exists
if (!world.metadata) world.metadata = {};
if (!world.metadata.roles) world.metadata.roles = {};

// Assign a role to an entity
world.metadata.roles[entityId] = Role.ADMIN;

// Save the world
await runtime.updateWorld(world);
```

For programmatic role management, you can use role-related utilities:

```typescript
import { canModifyRole, findWorldForOwner } from '@elizaos/core';

// Check if user can modify roles
if (canModifyRole(userRole, targetRole, newRole)) {
  // Allow role change
}

// Find world where user is owner
const userWorld = await findWorldForOwner(runtime, entityId);
```

## World Settings

Worlds support configurable settings that can be stored and retrieved:

```typescript
// Get settings for a world
const worldSettings = await getWorldSettings(runtime, serverId);

// Update world settings
worldSettings.MY_SETTING = {
  name: 'My Setting',
  description: 'Description for users',
  value: 'setting-value',
  required: false,
};

// Save settings
await updateWorldSettings(runtime, serverId, worldSettings);
```

## World Events

ElizaOS emits events related to world activities:

| Event             | Description                                    |
| ----------------- | ---------------------------------------------- |
| `WORLD_JOINED`    | Emitted when an agent joins a world            |
| `WORLD_CONNECTED` | Emitted when a world is successfully connected |
| `WORLD_LEFT`      | Emitted when an agent leaves a world           |

### Handling World Events

```typescript
// Register event handlers in your plugin
const myPlugin: Plugin = {
  name: 'my-world-plugin',
  description: 'Handles world events',

  events: {
    [EventTypes.WORLD_JOINED]: [
      async (payload: WorldPayload) => {
        const { world, runtime } = payload;
        console.log(`Joined world: ${world.name}`);
      },
    ],

    [EventTypes.WORLD_LEFT]: [
      async (payload: WorldPayload) => {
        const { world, runtime } = payload;
        console.log(`Left world: ${world.name}`);
      },
    ],
  },
};
```

## Relationship with Rooms

A world contains multiple rooms that entities can interact in. Each room points back to its parent world via the `worldId` property.

```typescript
// Get all rooms in a world
const worldRooms = await runtime.getRooms(worldId);
```

See the [Rooms](./rooms.md) documentation for more details on managing rooms within worlds.

## Best Practices

1. **Always check permissions**: Before performing administrative actions, verify the user has appropriate roles
2. **Handle world metadata carefully**: The metadata object can contain critical configuration, so modify it with care
3. **World-room syncing**: When syncing with external platforms, keep world and room structures in alignment
4. **Event-driven architecture**: Use events to respond to world changes rather than polling for updates
5. **Default settings**: Provide sensible defaults for world settings to make configuration easier
`````

## File: packages/docs/docs/quickstart.md
`````markdown
---
sidebar_position: 2
title: Quickstart Guide
description: Get started quickly with ElizaOS - from installation to running your first AI agent
keywords:
  [quickstart, installation, setup, configuration, CLI, agents, plugins, development, deployment]
image: /img/eliza_banner.jpg
---

# Quickstart Guide

## Prerequisites

- [Node.js 23+](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)
- Git for version control
- For Windows Users: [WSL 2](https://learn.microsoft.com/en-us/windows/wsl/install-manual) is required

## Installation

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="global" label="Install Globally (Recommended)" default>

```bash
# Install globally
bun install -g @elizaos/cli
# Start ElizaOS
elizaos start
```

  </TabItem>
  <TabItem value="npx" label="Test with NPX">

```bash
# Use directly with npx
npx @elizaos/cli start
```

  </TabItem>
  <TabItem value="source" label="Install from Source">

```bash
# Clone the repository
git clone git@github.com:elizaOS/eliza.git
cd eliza

# Switch to development branch
git checkout main

# Install dependencies
bun install

# Build the project
bun run build

# Start ElizaOS
bun start
```

  </TabItem>
</Tabs>

This will:

1. Start ElizaOS with default settings
2. Load the default character
3. Make the agent accessible via terminal and REST API

> **Note:** If you encounter any errors on first startup, try running the start command again. The initial startup sometimes needs a second attempt to properly initialize all components.

### Chat with your agent:

Visit https://localhost:3000 to interact with your agent through a web interface.

## 2. Creating a Project

If you want to create a custom ElizaOS project with your own characters and configurations:

```bash
# Create a new project with the interactive wizard
elizaos create
# Or specify project type directly
elizaos create --type project
```

Follow the interactive prompts to configure your project. Once created:

```bash
# Navigate to your project directory
cd my-project-name
# Start your project
elizaos start
```

> If it fails the first time try the start command again

### Project Structure

A typical ElizaOS project structure looks like this:

```
my-project/
├── src/
│   └── index.ts      # Main entry point with character definitions
├── knowledge/        # Knowledge files for RAG
├── package.json      # Project configuration and dependencies
└── tsconfig.json     # TypeScript configuration
```

The character definition is located in `src/index.ts` where you can modify the agent's personality, plugins, and settings. This is the core file for customizing your agent's behavior.

### Add plugins to your project:

```bash
# List available plugins for a project
elizaos plugins list
# Add a plugin
elizaos plugins add @elizaos/plugin-discord
```

### Working with Character Files

You can work with character files using the agent commands:

```bash
# Create a new character file
elizaos create -t agent my-character

# Start an agent with a character file
elizaos agent start --path ./my-character.json

# Get agent details and save to file
elizaos agent get --name eliza --output my-exported-character.json

# Start agent with JSON configuration directly
elizaos agent start --json '{"name":"Eliza","system":"You are a helpful assistant","bio":["Helpful AI assistant"],...}'

# Load character from remote URL
elizaos agent start --remote-character https://example.com/characters/assistant.json
```

This is particularly useful for those migrating from v1 who are used to working with standalone character files.

## 3. Creating a Plugin

Want to extend ElizaOS with custom functionality?

```bash
# Create a new plugin project
elizaos create --type plugin
```

Develop your plugin following the structure in your generated project:

```bash
# Test your plugin
elizaos start
# Publish your plugin when ready
elizaos publish
```

### Publishing options:

```bash
# Test publish without making changes
elizaos publish --test
# Publish to npm instead of GitHub
elizaos publish --npm
# Generate files locally without publishing
elizaos publish --dry-run
```

---

## Troubleshooting

### Node Version

- Use Node.js 23.3.0+ (`node -v` to check)
- Try using NVM: `nvm use 23`

### Installation Problems

```bash
# Clean and reinstall
bun clean
bun install --no-frozen-lockfile
bun build
```

### Plugin Issues

```bash
# Rebuild problematic packages
bun rebuild better-sqlite3
```

### Docker Issues

```bash
# Clean up Docker environment
docker rmi -f $(docker images -aq)
docker builder prune -a -f
```

### First-time Startup Issues

If your agent fails to start on the first attempt:

- Run the start command again
- Check logs for specific errors
- Ensure all dependencies are properly installed
- Verify that your database configuration is correct

---

## Next Steps

Once you have your agent running, explore:

- [Understand Agents](./core/agents.md)
- [Add Custom Actions](./core/actions.md)
- [Configure Knowledge](./core/knowledge.md)
- [Add Services](./core/services.md)

Join the [Discord community](https://discord.gg/elizaOS) for support and to share what you're building!
`````

## File: packages/docs/partners/0g-labs/brief.mdx
`````
# 0G Labs: Decentralized AI Operating System

## Core Infrastructure

- Building world's first decentralized AI operating system (deAIOS) for Web3
- Modular blockchain architecture with specialized AI components:
  - 0G Chain: High-performance modular blockchain
  - 0G Storage Network: Decentralized storage for AI datasets/models
  - 0G Compute Network: Supports inference, training, data retrieval
  - 0G DA: Data availability layer with 50 GB/second throughput
- Enables on-chain machine learning, AI agents, verifiable inference

## Eliza Integration

- Partnership leverages privacy-preserving AI through verifiable compute and encryption
- Hosts Eliza's agents on 0G's decentralized compute network
- Enables cross-ecosystem agent interoperability via standardized APIs
- Creates accountable AI with provable data lineage and execution integrity

## Recent Progress

- Q1 2025: $88M Ecosystem Growth Program ($8.88M for developers)
- Q4 2024: Alibaba Cloud partnership for hybrid AI deployments
- Q3 2024: Achieved 50,000 TPS in testnet for model inference
- Mainnet launch: Q2 2025 with focus on autonomous agents

## Market Position

- 50x more cost-efficient than Celestia/EigenDA for AI workloads
- Partners: Chainlink, OP Labs, AWS, Eliza
- 300+ ecosystem projects including AI DeFi protocols
- Funding: $35M pre-seed (Hack VC) + $53M strategic (Coinbase Ventures)
`````

## File: packages/docs/partners/aethir/brief.mdx
`````
# Aethir Overview

## Core Business

Aethir provides decentralized GPU cloud infrastructure for AI, ML, and gaming through a distributed provider network, emphasizing accessibility in underserved regions.

## Products

- **Aethir Earth**: Bare-metal GPU cloud for AI workloads
- **Aethir Atmosphere**: Low-latency cloud gaming service
- **Aethir Edge**: Enterprise edge AI devices leveraging distributed GPUs

## Web3 Significance

Pioneers decentralized physical infrastructure (DePIN) for GPU computing with tokenized governance ($ATH), addressing cost and scalability issues in compute-intensive industries.

## ElizaOS Integration

- API access to GPU network for AI/ML workflows
- Supports training ElizaOS AI models on decentralized GPUs
- Enables low-latency metaverse rendering
- $ATH token facilitates payment within ElizaOS ecosystems

## Recent Developments (2024-2025)

- $9M Pre-A funding at $150M valuation
- Launched Edge devices with Snapdragon 865 chips
- Partnership with Manta Network
- Expansion into Southeast Asia and Latin America

## Market Position

- Competitors: AWS, Azure, Render Network, Io.net
- Advantages: 1,000+ H100 GPUs, hybrid edge-cloud architecture
- Key partnerships with telecom providers, gaming studios, and blockchain platforms
`````

## File: packages/docs/partners/allora-labs/brief.mdx
`````
# Allora Labs Summary

## Core Offering

Allora Labs builds the Allora Network—a blockchain-based decentralized AI infrastructure that aggregates distributed models to produce superior inferences. Provides ML deployment infrastructure, verifiable AI tools (zkML), and ecosystem support for AI-powered dApps.

## Eliza Integration

- **Secure AI Agents**: zkML enables verifiable, private transactions for ElizaOS agents
- **Decentralized Intelligence**: Eliza agents use Allora for market analysis and predictions
- **Joint Tools**: Includes zkPredictor and cross-chain oracle system
- **Integration Method**: Core functions embedded in ElizaOS agent SDK via API

## Recent Developments

- zkSync ecosystem expansion with DeFi optimization tools (May 2024)
- Secret Network partnership for confidential AI operations (Feb 2025)
- Mainnet launch Q4 2024 with >1,000 models
- $25M ecosystem fund with Upshot (Feb 2025)

## Market Position

- Outperforms centralized AI vendors in transparency and collaborative learning
- Better inference accuracy than Web3 AI competitors through context-aware synthesis
- Key partners: Upshot, Secret Network, zkSync (exclusive AI provider)
- 400M+ weekly inferences across 200+ dApps
- $150M+ TVL in AI-powered DeFi vaults
`````

## File: packages/docs/partners/apro/brief.mdx
`````
# APRO

APRO develops secure infrastructure for decentralized AI ecosystems, with its flagship **AgentText Transfer Protocol Secure (ATTPs)** enabling blockchain-powered, verifiable AI agent communication with cryptographic accountability.

**Core Products:**

- ATTPs protocol for AI agent interoperability
- Decentralized verification network using zero-knowledge proofs
- Staking infrastructure for node operators
- Enterprise blockchain integrations for AI workflows

**ElizaOS Integration:**

- ATTPs powers ElizaOS's agent communication backbone
- Implements four source agents: Data Validator, Trust Scorer, Proof Generator, Slashing Monitor
- Provides SDK for ZK-verified AI workflows
- Auto-generates Merkle inclusion proofs for agent decisions
- APRO nodes validate Eliza transactions with shared staking pool
- Enables cross-chain Ethereum/Solana AI agent interoperability

**Recent Developments:**

- 2025 Q1: ATTPs v2 with BNB Chain integration
- 2024 Q4: $3M seed round (Polychain, ABCDE Labs)
- 2024 Q3: Mainnet slashing with $18M TVL

**Market Position:**

- Outperforms Chainlink (2.1s vs 8.7s zk-proof latency, 56% lower gas costs)
- Partners: Mind Network (FHE privacy), Virtuals Protocol (GPU marketplace), Presto Labs
- Metrics: 420+ integrated AI agents, $23M protocol revenue, 89% node retention

**Roadmap:** FHE privacy pools (Q2 2025), cross-chain asset transfers (Q3), on-chain reputation system (Q4)
`````

## File: packages/docs/partners/arbitrum/brief.mdx
`````
# Arbitrum

## Core Overview

- Leading Ethereum L2 scaling solution using optimistic rollups
- Processes ~10x more transactions than Ethereum at less than 1% of cost
- 500+ dApps with $18.7B TVL (56% of all rollup market share)
- 12.4M monthly active wallets, 150+ institutional validators

## Key Products

- **Arbitrum One**: Main L2 network for dApps
- **Arbitrum Orbit**: Framework for custom L3 chains
- **Stylus**: Multi-language smart contracts (Rust, C, C++, Python)
- **Arbitrum Nova 2.0**: Upcoming upgrade with 50% fee reduction

## ElizaOS Integration

- Leverages Arbitrum's MultiVM for AI agent deployment
- Agents execute native Rust smart contracts via Stylus
- $2M+ joint grants for AI development on Arbitrum
- ZK Co-Processor with Zypher Network for verifiable AI inferences
- Enables real-time DeFi interactions and cross-chain RAG-enhanced memory

## Recent Developments

- Stylus 2.0 launched with Python support (Q1 2025)
- ElizaOS partnership announced (March 2025)
- Asian expansion targeting Seoul/Singapore developers (April 2025)
- 50M ARB allocated for AI ecosystem development via governance

## Competitive Landscape

- Main competitors: Optimism (22%), zkSync Era (13%), Polygon zkEVM (9%)
- Key partners: Chainlink, Lido, Uniswap, The Graph, 30+ blockchain foundations
`````

## File: packages/docs/partners/arc-agents/brief.mdx
`````
# ARC Agents Summary

## Core Focus

- Specializes in AI agents for decentralized applications, gaming, and blockchain
- Emphasizes behavioral learning methodologies (imitation and reinforcement learning)
- Creates adaptive agents for complex environments including gaming and robotics
- Bridges AI with Web3 for intelligent blockchain-integrated systems

## Eliza Integration

- Shares development framework combining Eliza's architecture with Arc's learning models
- Arc's Gaming SDK available as ElizaOS plugin
- Features unified simulation environments for cross-platform deployment
- Integrates LLMs with behavioral systems for NLP capabilities
- Utilizes Secret Network's encryption for secure agent communications

## Recent Developments

- Q1 2025: Collaborative AGI research with Eliza Labs
- March 2025: Expansion into AI-driven robotics
- April 2025: Gaming SDK v2.3 release with enhanced Web3 tools
- Roadmap includes cross-chain interoperability and DAO-based governance

## Market Position

- Rust-based performance: 40% faster than TypeScript competitors
- Partnerships with Solana ecosystem, ArenaX Labs, robotics startups
- SDK used by 120+ blockchain gaming projects (2.1M weekly on-chain transactions)
- Key differentiator: Closed-loop learning systems for continuous improvement
`````

## File: packages/docs/partners/arenax-labs/brief.mdx
`````
# ArenaX Labs Overview

## Company Profile

- Toronto-based company at intersection of AI, gaming, and blockchain (founded 2018, rebranded 2021)
- Raised $11.25M total funding ($6M led by Framework Ventures in early 2024)
- Core product: AI Arena - PvP platform fighter with AI-powered NFT characters trained via imitation learning

## Key Offerings

1. **ARC**: White-label AI gaming SDK for third-party integration
2. **SAI**: Gamified research platform hosting ML competitions
3. **AI Arena**: Ethereum-native fighting game with NFTs and blockchain rewards ($NRN token)

## Eliza Integration

- Uses ElizaOS via Secret Network for confidential computing:
  - Private AI economies with encrypted transactions
  - Secure AI-driven DeFi strategies
  - Privacy-preserving avatars with protected training data
- Characters operate in Eliza's multi-agent framework with ZK proofs for combat integrity

## Timeline

- April 2024: Launched ARC SDK and SAI platform
- July 2024: Integrated Arbitrum for gas-free NFT transfers
- January 2024: Secured $6M funding
- 2025: Planned academic partnerships for AI education

## Market Position

- Unique combination of imitation-learning AI with Web3 rewards (85% $NRN token staking rate)
- Key partnerships: Framework Ventures, Secret Network, Xterio
`````

## File: packages/docs/partners/arok/brief.mdx
`````
# Arok: Autonomous AI Agent VC Fund

## Core Overview

- First fully autonomous AI agent VC fund operating without human intervention
- Raises capital, develops investment theses, and executes trades independently
- Specializes in cryptocurrency markets (particularly meme coins)
- Identifies arbitrage opportunities and market inefficiencies
- Functions as independent economic entity on blockchain infrastructure

## ElizaOS Integration

- Uses ElizaOS agent framework for compute resources via Hyperbolic's GPU marketplace
- Accesses optimized Llama models through ElizaOS plugins
- Functions within LangGraph Supervisor system for cross-agent collaboration
- Participates in AI-driven DAO governance
- Provides trading strategy API endpoints to ElizaOS users

## Key Milestones

- Q4 2024: Autonomously raised $800K
- Jan 2025: Expanded to meme coin arbitrage, reaching $1.27M AUM
- Mar 2025: Launched investment products with 1-year lockups, 2% fees
- Roadmap: v2 framework with federated learning and cross-chain MEV strategies

## Market Position

- Dominates AI-agent VC niche as only fully autonomous fund
- Partners with StreaksAI (liquidity) and Pioneer AI Foundry (ML models)
- 11K+ social followers and $617.5K in AROK tokens held by institutional partners
`````

## File: packages/docs/partners/beffai/brief.mdx
`````
# BeffAI Overview

## Core Offering

BeffAI is a decentralized AI agent platform for DeFi automation and decision-making, combining AI with decentralized finance for portfolio management, cross-chain swaps, and market analysis. Founded by Beff Jezos (associated with Extropic AI), it likely employs thermodynamic computing for blockchain transaction optimization.

## ElizaOS Integration

- Operates through ElizaOS's Plugin Execution Framework
- Uses Smart Contract Proxy for transaction validation
- Shares memory pool for on-chain data
- Provides cross-platform authentication (Discord/X/Telegram)
- Features multi-chain swap agent with portfolio analysis, slippage optimization, and cross-chain settlements
- Co-developing a DeFi Agent Marketplace for monetizing trading strategies

## Recent Milestones

- Q1 2025: Private beta of EigenLayer-integrated restaking layer
- Feb 2025: $2.1M strategic funding from Framework Ventures
- In development: FHE-enhanced privacy vaults for institutional DeFi
- Roadmap: Q3 2025 release of no-code BeffAI Orchestrator

## Market Positioning

- Premium AI execution layer in ElizaOS ecosystem
- Native integration with TON and MultiversX
- Used by three top-20 crypto hedge funds
- 14 pending patents for AI-powered MEV detection
- Partners: STON.fi, Gelato Network, Rainmaker Games
`````

## File: packages/docs/partners/berachain/brief.mdx
`````
# Berachain Summary

## Core

- EVM-identical Layer 1 blockchain launched February 2025
- Novel **Proof-of-Liquidity (PoL)** consensus mechanism
- Full Ethereum compatibility with tri-token system (BERA, BGT, HONEY)
- Solves DeFi liquidity fragmentation by aligning validator incentives with network liquidity

## Key Products

- **BEX**: Native DEX
- **HoneySwap**: Stablecoin DEX
- **Infrared Finance**: Liquid staking protocol
- **Berascan**: Blockchain explorer

## Eliza Integration Potential

- Native compatibility with Ethereum plugins
- Liquidity API access via Webhook plugin
- AI use cases: yield farming, collateral rebalancing, cross-chain arbitrage

## Timeline & Metrics

- **Feb-Apr 2025**: Mainnet launch, $100M Series B, Axelar integration
- **Q3 2025**: ZK-Rollup testnet planned
- $2.1B TVL, 840,000+ active wallets
- Partnerships: Coinbase, Chainlink, Polygon
- 37% lower TVL concentration risk vs ETH L2s
- 12% of EVM developers building test deployments
`````

## File: packages/docs/partners/bnb-chain/brief.mdx
`````
# BNB Chain Overview

## Core Infrastructure

- **Multi-chain ecosystem** evolved from Binance Chain/BSC
- **Performance**: 2,000+ TPS, sub-second finality, less than $0.01 gas fees
- **Components**: BSC (EVM-compatible), opBNB (L2 rollup), BNB Greenfield (data storage), zkBNB (ZK scaling)
- **Ecosystem**: 1,400+ active dApps across 10+ verticals, $4.8B+ TVL

## ElizaOS Integration

- Official plugin available on GitHub (elizaos-plugins/bnb-chain)
- Smart contract interface for AI agent execution
- Technical capabilities: BEP-20 operations, AI-DeFi via Venus Protocol, NFT minting, gas prediction
- Use cases: AI liquidity pools, generative NFTs, yield optimizers, cross-chain arbitrage

## Recent Developments (2024-2025)

- opBNB Connect launch (March 2025) - 23M+ daily transactions
- ElizaOS Plugin v2 (February 2025) supporting multi-model agents
- BNB Chain AI Agent SDK (January 2025)
- 5,000 TPS testnet achievement (December 2024)

## Roadmap & Market Position

- Q3 2025: zkBNB mainnet; Q4 2025: BNB Beacon Chain deprecation
- Metrics vs competitors: 2,100 TPS, $0.02 fees, 1.4M daily users
- Key partnerships: PancakeSwap ($1.2B TVL), Venus Protocol ($800M deposits), COMBO Network
`````

## File: packages/docs/partners/collab-land/brief.mdx
`````
# Collab.Land

## Overview

Web3 infrastructure provider specializing in token-gated community management since 2020. Serves 43,000+ communities across 40+ blockchains (Ethereum, Optimism, Polygon). Main product: automated bot for token-based access control in Discord/Telegram with continuous verification. Launched $COLLAB ERC-20 governance token in 2023, managed through Collab.Land DAO.

## Technical Integration Capabilities

- REST APIs and JavaScript SDK available for custom integrations
- Token verification can embed into external workflows:

```javascript
const { verifyTokenOwnership } = require('@collabland/sdk');
async function checkAccess(walletAddress) {
  return await verifyTokenOwnership({
    chainId: 1,
    contractAddress: '0x...',
    wallet: walletAddress,
  });
}
```

- Enables: native token-gated access, role synchronization, governance integration

## Recent Highlights

- 2023: $COLLAB token distributed to 2M+ members
- 2024: EthCC participation, AI community tools, 15 new wallet integrations
- Enterprise partners: Adidas, Pudgy Penguins

## Market Position

- 43,000+ active communities
- 6.5M+ verified wallets
- Competitors: Guild, Lit Protocol
- Partners: Optimism Collective, Aavegotchi, BanklessDAO
`````

## File: packages/docs/partners/crossmint/brief.mdx
`````
# Crossmint Overview

## Core Offering

Enterprise blockchain infrastructure providing:

- Embedded wallets (custodial/non-custodial) across 40+ chains
- NFT minting APIs supporting 20+ blockchains
- Fiat/crypto payment gateway (95%+ approval rate, 195+ countries)
- On-chain verifiable credentials system

## Customer Base

- 40,000+ enterprises and developers
- Notable clients: Santander, Mastercard, NBC Universal, Coinbase

## Potential Eliza Integration Methods

- REST API integration for wallet/NFT operations
- Webhook-based automation for on-chain events
- Possible SSO integration via Crossmint's auth system
- Use cases: AI agents managing wallets, automated NFT minting, credential verification

## Recent Developments

- $23.6M funding (Mar 2025, Ribbit Capital) for AI agent infrastructure
- Acquired Cycle AI (Q1 2025)
- Released GOAT SDK 2.0 with agent-to-agent transactions
- Expanded to Avalanche C-Chain with Ava Labs partnership

## Market Position

- Enterprise-focused (vs consumer-oriented competitors)
- Superior payment approval rates (95%+ vs industry 89%)
- Broader chain support (40+ vs competitors' 15-20)
- Key partners include Santander, ASUS, Diageo, Red Bull
`````

## File: packages/docs/partners/daos-fun/brief.mdx
`````
# daos.fun

Daos.fun is a Solana-based decentralized platform for launching liquid investment DAOs, specializing in meme fund creation. It enables users to raise SOL, issue tradable tokens, and automate profit-sharing.

**Core Offerings:**

- No-code DAO creation tools (launch in less than 10 minutes, 20 SOL minimum)
- Virtual AMM for token trading while assets remain locked
- Automated profit distribution (80-95% to token holders)
- Transparent smart wallet treasury management
- Multi-signature governance combining creator control with community voting
- Creator KYC/AML vetting system

**Technology:**

- Solana blockchain (high-speed, low fees)
- Smart contract treasury management
- Fair launch mechanism with equal token pricing
- Automatic redemption via smart contracts (10% penalty on failed fundraising)
- Integration with Saga's Chainlets for L1 expansion

**ElizaOS Integration:**

- Primary launchpad for AI-managed funds
- AI agents execute trades via Daos.fun smart contracts
- Real-time token prices reflect AI trading performance
- AI-managed meme index funds and treasury rebalancing
- Custom API endpoints enable ElizaOS agent interactions

**Metrics & Position:**

- 15,000+ DAOs created
- $250M+ TVL
- 40% month-over-month user growth
- 300% faster fund launches vs competitors
- 10x lower fees than traditional platforms
- Notable success: ai16z/ElizaOS fund (650x return in 72 hours, $100M market cap)

**Partners:** AllianceDAO, Saga, ElizaOS

**Links:** daos.fun, daos.world (asset tracker)

_Note: Maintains low public visibility due to regulatory considerations_
`````

## File: packages/docs/partners/degen8ball/brief.mdx
`````
# degen8ball

## About degen8ball

Autonomous AI agent that analyzes markets, executes trades, and manages portfolios on DEXs. Services include:

- Memecoin trading using social sentiment analysis
- NFT market arbitrage via price patterns and rarity metrics
- Cross-chain liquidity optimization (Solana, Manta, TON, EVM)
- Risk-managed position sizing with dynamic stop-loss
- First AI agent trading NFTs in ElizaOS ecosystem

## Integration with Eliza

Available as certified ElizaOS plugin through Agent Marketplace with:

- Shared reputation scores with Eliza's trust engine
- Liquidity borrowing from Eliza's cross-chain reserves
- Unified price feed oracles
- Key use cases: ETH delegation to high-conviction plays, risk hedging, and leveraged trading with pooled collateral

## Recent Developments

- Q1 2025: ERC-6551 compatibility for NFT fractionalization
- March 2025: FHE implementation for private order routing
- April 2025: Tensor partnership for Solana NFT arbitrage
- Upcoming: On-chain prediction markets (Q3 2025), Physical-backed memecoin index (Q4 2025)

## Market Position

- 37% faster strategy iteration than competitors
- 83% lower gas costs via ElizaOS's batch transaction compiler
- Partnerships: Tensor (NFT liquidity), Meteora DLMM, Kongregate
- $4.7M TVL across 12,300 wallets
- 2,100+ daily trades on 8BALL/SOL
- 89% accuracy on 24-hour price predictions
`````

## File: packages/docs/partners/degenai/brief.mdx
`````
# DegenAI Overview

## Core Function

DegenAI is an AI-powered DeFi agent for market analysis, alpha generation, and autonomous trading within the ai16z/eliza framework. It leverages decentralized AI infrastructure for high-frequency trading, liquidity optimization, and governance automation, originating from the pump.fun ecosystem.

## Eliza Integration

- Built natively into ElizaOS as its first AI agent
- Uses Eliza's decentralized data pipelines and agent communication protocols
- Functions through a modular plugin system compatible with other AI agents
- Contributes 5-10% of profits to the ai16z DAO treasury
- Accessible via ElizaOS interfaces for NFT minting and liquidity sniping

## Recent Milestones

- Q1 2025: Developed failed-transaction reduction system
- Dec 2024: Integrated Virtuals Protocol's AI auditing (30% faster vulnerability detection)
- Planned expansion to Base and Hyperliquid networks

## Market Context

- Competitors: Griffain (Uniswap bots), HeyAnon (portfolio aggregators)
- Differentiated by tokenized governance model
- Partners: Cookie DAO (automated governance), Virtuals Protocol (analytics)
- Powers 14% of ai16z's $1.3B ecosystem TVL
- Token grants exclusive alpha channel access
`````

## File: packages/docs/partners/dfinity/brief.mdx
`````
# Dfinity Overview

## Core Technology

- Internet Computer Protocol (ICP): Third-generation blockchain enabling fully decentralized applications to run entirely on-chain
- Combines decentralized governance, cryptographic security, and web-speed performance
- Hosts smart contracts, enterprise systems, and web services without traditional cloud infrastructure
- Eliminates server costs and middlemen for Web3 applications

## Potential Eliza Integration

- Canister Communication: Eliza services could interact with ICP smart contracts via candid interfaces
- Identity Federation: Integration with Internet Identity protocol for authentication
- BTC/ETH Gateway: Leverage ICP's native crypto integrations for asset management
- NNS Participation: Eliza nodes could participate in network governance via ICP staking

## Recent Developments

- Elliptic Partnership (2025): Compliance tools for institutional DeFi
- Bitcoin L2 Expansion: Full BTC DeFi capabilities including lending markets
- SNS DAO Launchpad: 127+ community-governed dapps deployed in 2024
- Ethereum Fusion: ckETH integration processing $400M+ transactions
- Developer Growth: 37% YOY increase in active developers (2023-2024)

## Competitive Advantages

- vs Ethereum: 10,000x cheaper storage, 20x faster finality
- vs Solana: Provable decentralization through NNS governance
- vs AWS: No server costs, built-in blockchain capabilities
- Key Partnerships: Elliptic, Bitfinity EVM, Klever Wallet (70M+ users)
- Metrics: 485M+ code commits across 818K repos, $800M+ developer grants allocated
`````

## File: packages/docs/partners/drift/brief.mdx
`````
# Drift Protocol Overview

Drift is a decentralized perpetual futures exchange on Solana, offering:

- Peer-to-peer trading of perpetuals, spot markets, and swaps without intermediaries
- Support for 30+ collateral types with up to 50x leverage
- Hybrid liquidity model combining on-chain orderbook with dynamic automated market maker
- $6B+ monthly trading volume and $1.2B TVL
- 250,000+ monthly active traders

## Eliza Integration

- Users can execute trades via conversational AI interface
- Technical integration via TypeScript/Python SDKs
- AI-driven risk management for position adjustment
- Unified portfolio dashboard across DeFi activities
- [Eliza Drift Plugin](https://github.com/elizaos-plugins/drift) enables natural language trading commands

## Recent Developments

- $2.2B weekly volume records (2024)
- Added PYUSD and USDe as collateral options
- Launched prediction markets via BET tokens
- Integrated RWA collateral through Ondo Finance partnership
- Transitioned to DRIFT token DAO governance

Drift leads Solana's derivatives sector through its hybrid liquidity model, cross-margin capabilities, and strategic partnerships with Pyth, Wormhole, and Jito.
`````

## File: packages/docs/partners/eigen-layer/brief.mdx
`````
# Eigen Layer Summary

## Core Concept

Eigen Layer is an Ethereum restaking protocol allowing staked ETH or liquid staking tokens to secure multiple decentralized services (AVSs) simultaneously, creating a shared security marketplace and improving capital efficiency.

## Key Components

- **Restaking Infrastructure**: Supports ETH and LST restaking (stETH, rETH)
- **AVS Ecosystem**: 50+ services in development (EigenDA, oracles, bridges)
- **Operator Marketplace**: Validators earn from multiple services through delegation

## Integration Possibilities

- API access for in-app restaking
- AVS development via SDKs
- Delegation through OS interfaces

## Recent Milestones

- April 2025: EigenDA mainnet launch (1.2M txs/day)
- Q1 2025: $100M Series B at $8B valuation
- Partnerships with Binance and Kraken for institutional restaking

## Market Position

- 80% restaking market share ($8B TVL)
- 200,000+ active restakers, 1,400+ operators
- Key partnerships: Lido, Binance, Renzo
- Roadmap: 100+ AVSs by Q3 2025, EIGEN token staking
`````

## File: packages/docs/partners/eliza/brief.mdx
`````
# ELIZA

## Overview

ELIZA is a leader in decentralized AI agent development created by Eliza Labs. The project develops ElizaOS, an open-source TypeScript framework enabling developers to build autonomous AI agents that interact with blockchain networks, dApps, and smart contracts. These agents can perform automated trading, social media management, and real-time blockchain analysis while maintaining user control.

The flagship product "Eliza Wakes Up" features AI companions that engage in contextual conversations, execute Web3 transactions, and operate across 15+ digital platforms. The system offers 50+ plugins for blockchain networks including Hedera and Flow.

## Recent Developments

- **April 2025**: Launched Auto.fun platform for non-technical users
- **March 2025**: Released Hedera Consensus Service plugin
- **February 2025**: Introduced Flow blockchain integration
- **January 2025**: Open-sourced core framework, gained 2.8k GitHub stars

## Roadmap

- Q3 2025: Agent-to-agent marketplace
- Q4 2025: ZK-proof verifiable agent decision making
- 2026: Physical robotics integration via IOTA Tangle

## Market Position

- **300% faster** blockchain interaction vs. LangChain
- **47%** market share in DeFi automation
- Partnerships with Hedera, Flow, and Polygon
- **127,000+** developers in community
- Industry-leading 200ms confirmation-to-action latency
- Native social media ↔ DeFi arbitrage capabilities
`````

## File: packages/docs/partners/eliza-studios/brief.mdx
`````
# ELIZA STUDIOS

Eliza Studios is an AI-powered content creation platform that functions as a native plugin within the ElizaOS framework. They specialize in generating dynamic digital content across text, audio, and visual media formats.

## Key Capabilities

- Seamlessly integrates with autonomous AI agents
- Enables automated content generation through structured prompts
- Supports translation of user requests into polished content
- Validates outputs via ElizaOS's evaluator modules

## Technical Integration

- Shares authentication protocols with ElizaOS
- Provides unified API endpoints
- Allows agents to use services without leaving the ElizaOS environment

## Recent Developments

- Q1 2025: Launched real-time video synthesis plugin
- Upcoming: Beta testing for blockchain-native content licensing

## Market Position

- Differentiates through deep integration with autonomous agents
- Focuses on decentralized workflows
- Key partners: Old World Labs (robotics/AI storytelling) and Hyperbolic (verifiable inference)
- Supports applications in blockchain-integrated content and agent-driven workflows
`````

## File: packages/docs/partners/elizas-sister/brief.mdx
`````
# Eliza's Sister: Web3 AI Agent Framework

## Core Function

- Specialized AI agent framework for Web3 blockchain interactions
- Enables autonomous economic agents for DeFi, NFTs, and cross-chain operations
- Allows delegation of complex Web3 tasks (portfolio management, smart contract audits, governance)

## ElizaOS Integration

- Operates as a curated character package within ElizaOS
- Utilizes @elizaos/plugin-evm for Ethereum chain interactions
- Features shared wallet management and decentralized memory storage (Arweave/IPFS)
- Enables compound workflows (social media triggers for token swaps) and recovery systems

## Key Developments (2025)

- Agent-to-Agent Marketplace launch (Q1)
- Solana Firedancer integration for sub-second finality (March)
- Chainlink partnership adding 50+ price feeds (April)

## Market Position

- 63% market share in on-chain agent deployment (per Dune Analytics)
- Advantages over Aori and Fetch.ai: ElizaOS ecosystem compatibility (150,000+ developers), zero-knowledge proofs, partnerships with Uniswap, Polygon, and Axelar
`````

## File: packages/docs/partners/elizas-world/brief.mdx
`````
# elizas.world

## Core Offering

- Immersive metaverse platform combining AI agents with blockchain assets
- Enables user-owned virtual spaces with persistent AI characters
- Facilitates decentralized storytelling through agent interactions
- Features cross-platform compatibility with blockchain avatars/items
- Bridges AI autonomy with metaverse economies (agents own/trade assets via smart contracts)

## elizas-world-connector Integration

- **Avatar Sync:** ElizaOS agents maintain persistent cross-platform identities via IPFS profiles
- **Economy:** Cross-platform trades using $ELIZA tokens with smart contract escrow
- **Development:** Unified TypeScript SDK for cross-environment AI behaviors
- **Use Case:** AI agents manage virtual storefronts while coordinating real-world logistics

## Timeline

- Q1 2025: Genesis Land Sale with AI-curated parcels
- March 2025: Secret Network privacy protocols for agent negotiations
- Q3 2025 (Planned): Physics engine for agent-created structures
- 2026 (Planned): DAO governance for in-world rulemaking

## Market Position

- Unique: Only metaverse with native autonomous AI economics
- Technical: 23% faster agent interaction latency vs competitors
- Adoption: 18,000 users (40% via ElizaOS agents), 7 NFT collection partnerships
`````

## File: packages/docs/partners/emblem-vault/brief.mdx
`````
# Emblem Vault

## Core Technology

Emblem Vault is a Web3 infrastructure solution enabling cross-chain asset management without traditional bridges. It uses ERC-721/ERC-1155 tokenized vaults containing private keys to assets across incompatible blockchain types (UTXO-based like Bitcoin vs. account-based like Ethereum).

## Key Features

- Cross-chain NFT trading (e.g., Bitcoin Ordinals on Ethereum marketplaces)
- Historical NFT preservation (Rare Pepes, Spells of Genesis)
- Developer tools via SDK for custom vault implementations

## ElizaOS Integration

- JavaScript SDK for vaulting features in ElizaOS apps
- Unified cross-chain asset dashboard
- Smart contract hooks for automated vault creation
- Obsidian plugin for vault metadata in notes
- Hedera integration for HBAR token distribution

## Recent Developments

- 2024 SDK launch
- Solana/Tezos expansion (Q1 2024)
- Acquired by Crosschain Ventures (June 2024)
- ERC-1155 upgrades for fractional ownership

## Market Position

- 40,000+ ETH trading volume across 6,900 holders
- Superior UTXO compatibility versus competitors
- Partners: OpenSea, Crosschain Ventures, Hedera
`````

## File: packages/docs/partners/ethereum-foundation/brief.mdx
`````
# Ethereum Foundation

The Ethereum Foundation (EF) is a Swiss non-profit founded in 2014 by Vitalik Buterin and Gavin Wood. It catalyzes the Ethereum ecosystem through:

- Supporting research, development, education, and community-building
- Funding critical projects via the Ecosystem Support Program (ESP)
- Organizing the annual Devcon conference
- Running the Fellowship Program for underrepresented groups in Web3

As a steward of Ethereum's decentralization ethos, EF prioritizes open-source infrastructure and public goods rather than centrally directing development.

## Potential ElizaOS Integration

- API access to EF-supported tools and Ethereum clients
- Smart contract templates from EF-funded frameworks
- Joint hackathons and workshops
- Streamlined grant application processes

## Recent Developments

- 2024 leadership restructuring focusing on technical expertise
- 2025 roadmap prioritizing scaling solutions and developer experience
- Fellowship Program expansion for global communities (Q1 2025)
- Devcon 7 format changes emphasizing workshops and cross-chain interoperability

## Market Position

- Primary institutional advocate for Ethereum
- Partnerships with UN blockchain initiatives, DAOs, and academic consortia
- Supports an ecosystem with 4,000+ monthly active developers
- EF-funded projects comprise 30% of Ethereum's core infrastructure
`````

## File: packages/docs/partners/fleek/brief.mdx
`````
# Fleek: Web3 Infrastructure & AI Agent Platform

## Core Overview

- Founded 2018 in NY; raised $25M Series A
- Open-source platform at Web3-AI intersection
- Focuses on decentralized infrastructure with enhanced edge computing

## Key Products

- **Fleek Network**: Decentralized edge computing for fast content delivery, rendering, verifiable compute
- **Fleek.xyz**: Protocol-agnostic platform with 300K+ deployments (IPFS/Filecoin storage, ENS management)
- **AI Agent Infrastructure**: TEE-enabled agent deployment with auto-scaling

## ElizaOS Integration

- Official `elizaos-fleek` plugin enables direct network deployment, TEE-secured secret management, cross-chain event listening
- Shared resources: decentralized storage for knowledge bases, low-latency inference
- Use cases: privacy-preserving AI, censorship-resistant hosting, edge-accelerated responses

## Recent Developments

- 2025 Community Sale for decentralized governance
- AI Agent Marketplace beta (150+ templates)
- Network v2: 12,000 TPS for edge compute
- Zero-Knowledge CDN combining TEEs with zk-SNARKs

## Market Position

- First-mover in Web3 edge computing
- Cost-effective: $0.07/GB storage vs $0.23/GB traditional
- Lower latency: 140-200ms global edge vs 300-800ms regional
- 40,000+ monthly active developers with 93% retention
- Key partners: Filecoin, ENS, Polygon
`````

## File: packages/docs/partners/fuel/brief.mdx
`````
# Fuel: Modular Execution Layer for Blockchain Scalability

## Core Technology

- Modular architecture separating execution from data availability and consensus
- Parallel transaction processing via FuelVM (custom virtual machine)
- Provides high throughput, low fees, and Ethereum compatibility
- Addresses monolithic blockchain limitations while maintaining security

## Key Products

- **FuelVM**: Purpose-built VM with expanded capabilities beyond EVM
- **Sway**: Rust-based language for smart contract development
- **Forc**: Developer toolkit for building/testing/deploying
- **Fuel Ignition**: Production-ready Ethereum L2 (launched March 2024)

## Recent Developments

- Fuel Ignition Mainnet launch with fraud proofs and light clients (Mar 2024)
- Fuel Agent Kit enabling AI agent interaction with dApps (Dec 2024)
- Beta-1 Testnet for developer contract deployment
- SwaySwap DEX demonstrating low-fee environment

## Market Position

- Outperforms EVM rollups (Arbitrum, Optimism) in throughput
- UTXO model differs from account-based systems like Solana
- Partnerships: Ankr (RPC services), Jump Crypto, Maven11 (investors)
- Ecosystem: SwayLend, Mira Protocol (DeFi partners)
- Testnet performance: 10,000+ TPS in controlled environments
`````

## File: packages/docs/partners/fxn/brief.mdx
`````
# FXN Overview

## Core Function

FXN is a Web3 AI agent platform providing intelligent middleware between users and blockchain ecosystems. It enables natural language commands for blockchain operations while maintaining security through zero-knowledge proof verification.

## Key Products

- AI-powered transaction automation
- Cross-chain asset management interfaces
- Conversational smart contract interaction
- Real-time blockchain data analysis
- DeFi risk assessment frameworks

## Distinctive Feature

FXN's transaction intent architecture interprets user objectives (e.g., "Maximize yield across Layer 2 networks") and autonomously executes optimized blockchain operations while preserving privacy.

## Eliza Integration

- Shares authentication layer: FXN's zk-proof system works with Eliza's TEE modules
- Leverages Eliza's Solana and EVM plugins for multi-chain operations
- FXN's oracle network feeds market data into Eliza's RAG systems

## Recent Timeline

- Q1 2025: Launched FXN V3 with AI arbitrage strategies
- February 2025: Completed Halborn security audit for cross-chain bridge
- Current: Developing L3 solution using Celestia's modular DA layer
- Planned: Integration with Movement blockchain's parallel EVM

## Market Position

- 3x faster cross-chain swaps than industry average
- 92% accuracy in gas price predictions
- Supports 18 chains (vs competitors' 5-7)
- Partners with Chainlink (data), Aevo (derivatives), and Socket (liquidity routing)
`````

## File: packages/docs/partners/gaia-network/brief.mdx
`````
# GAIA NETWORK

## Core Overview

Gaia Network (GaiaNet) is a decentralized AI infrastructure enabling distributed edge nodes to host specialized AI models and agents. It allows individuals and businesses to operate nodes with "AI twins" trained on proprietary domain knowledge while preserving privacy and maintaining Web2-level UX. The system provides decentralized inference servers, an AI agent deployment framework, and personalized AI tools.

## Eliza Integration

**PostgreSQL Adapter Plugin** enables technical integration:

```javascript
{
 "modelProvider": "gaianet",
 "modelSize": "medium",
 "embeddingModel": "nomic-embed",
 "postgresConfig": {
   "vectorExtension": "pgvector",
   "embeddingProvider": "gaianet"
 }
}
```

**Technical Synergies:**

- Dynamic model switching (small/medium/large)
- Shared vector databases with Nomic embeddings (768 dimensions)
- Confidential operations via Secret Network
- One-click agent deployment to node network

**Use Cases:** Privacy-preserving DeFi bots, multi-platform customer service agents, AI moderation systems

## Timeline

- 2024 Q3: Testnet launch (2,500 active nodes)
- 2024 Nov: EigenLayer partnership ($12M TVL secured)
- 2025 Jan: Secret Network integration
- 2025 Q2: "Mother" agent launchpad release
- 2025 Q3 Roadmap: Cross-chain agent interoperability

## Market Position

- 47% faster inference vs centralized alternatives
- 83% lower costs vs AWS-based deployments
- Partners: EigenLayer, Secret Network, Chainlink, Filecoin
- 14,200+ global node operators
- $7.8M/month in staking rewards
- 320+ AI agents deployed via GaiaNet-ElizaOS
`````

## File: packages/docs/partners/gelato/brief.mdx
`````
# Gelato Web3 Backend Infrastructure

## Core Offerings

- **Middleware for smart contract automation** (78% market share)
- **Automate**: Multi-chain contract scheduler triggered by time, price, or custom conditions
- **Relay**: Gasless transaction infrastructure with sponsored meta-transactions
- **Web3 Functions**: Serverless environment connecting contracts to external APIs
- **Rollup-as-a-Service**: 1-click custom ZK/OP rollup deployment
- Processes millions of monthly transactions for 500+ projects (Aave, Uniswap, MakerDAO)

## Eliza Integration

1. **AI Agent Transactions**: ElizaOS agents use Gelato Relay for gasless multichain operations
2. **Automated Workflows**:
   - Cron-triggered agent memory updates
   - Oracle-powered execution via Web3 Functions
   - Cross-chain state synchronization
   - Available via `@elizaos/gelato-adapter` SDK

## Timeline & Market Position

- **Jan 2025**: Integrated into ElizaOS core
- **Q4 2024**: Launched Gelato Chains (rollups with native AA)
- **Q3 2024**: 50M monthly transactions across 40+ chains
- **Future**: Decentralized executor network (Q2 2025), ZK coprocessors (Q3 2025)
- **Advantages vs. Chainlink**: More chains (40+ vs 15), faster intervals (15s vs 1hr), native gasless options
- Secures $4.2B TVL across DeFi protocols
`````

## File: packages/docs/partners/gnon/brief.mdx
`````
# GNON

## Overview

Gnon (Gnosis Labs division) creates censorship-resistant infrastructure for AI agents in Web3, serving as a neutral coordination layer for decentralized agents without centralized platform dependencies.

## Core Offerings

- **Gnon Echochambers**: Testing environments for observing agent behaviors, fine-tuning prompts, and simulating multi-agent interactions with cross-model integration support
- Secure infrastructure for developers in regulated environments requiring audit trails

## ElizaOS Integration

- Provides decentralized communication backbone for Eliza agents
- Records all agent activities immutably on Solana
- Shares security model with anti-spam and rate-limiting controls
- Verified plugin in elizaos-plugins GitHub enables direct Echochamber deployment and translates Character Files to Gnon blueprints

## Recent Developments

- Q1 2025: Mainnet integration with Solana Firedancer (300k+ TPS)
- Q4 2024: $25M ecosystem fund with GnosisDAO
- Upcoming: Berachain proof-of-liquidity integration
- In development: Agent reputation system based on on-chain histories

## Market Position

- 5.7x lower costs than centralized alternatives
- 92% faster cross-chain settlement
- Partners: ElizaOS, Berachain, ChainGPT
- 14,200+ registered developers, 480k daily agent transactions, $7.8M quarterly developer rewards
`````

## File: packages/docs/partners/godsdotfun/brief.mdx
`````
# Godsdotfun Overview

## Core Product

- Web3 platform creating AI-driven autonomous agents ("Gods") on blockchain
- Combines LLM cognition with on-chain automation for DeFi, social media, and governance
- Partner of ElizaOS, bridging AI autonomy with Web3 infrastructure

## Eliza Integration

- Functions as plugin within ElizaOS ecosystem using @eliza/plugin-web3 toolkit
- Agents run on ElizaOS's decentralized compute layer (40+ blockchain networks)
- Uses natural language commands for intent-based workflows
- Integrates $GODS tokens with ElizaOS tokenomics for revenue sharing
- Use cases: DAO treasury management, trading bots, AI social media moderators

## Recent Developments

- Q1 2025: Launched v2 Agent SDK with plug-and-play DeFi modules
- March 2025: Integrated with Farcaster Frames for social ecosystem engagement
- April 2025: Partnered with Eliza Labs on auto.fun (no-code agent platform)
- Q3 2025 (planned): Agent-to-Agent Marketplace for pre-trained AI agent licensing

## Market Position

- Specializes in AI-driven Web3 middleware (competes with Fetch.ai, Autonolas)
- Differentiators: ElizaOS integration, social/web3 interoperability
- Partnerships: Chainlink (oracles), Aave (liquidity), Farcaster (social)
- 1,200+ GitHub forks indicate strong developer interest
`````

## File: packages/docs/partners/goplus/brief.mdx
`````
# GoPlus Security Infrastructure

## Core Overview

GoPlus provides Web3's decentralized security infrastructure through API modules and AI solutions, offering automated detection for token risks, NFT authenticity, malicious addresses, and smart contract vulnerabilities.

## Key Products

- **Security API Suite**: Real-time detection across assets and addresses
- **SafeToken Protocol**: Secure token creation standards
- **SecNet**: Layer 2 blockchain firewall for high-risk transactions
- **Security SDKs**: Developer integration tools
- **Chrome Extension**: Phishing detection and transaction simulation

## Reach: 12M+ wallets protected, 30M daily API calls, 30+ blockchains supported

## Integration with Eliza

- API-level integration using JavaScript/Python SDKs
- Shared security modules for wallet authorization and contract audits
- Unified risk dashboard within Eliza's interface
- Co-developed SafeToken standards

## Recent Developments (2025)

- GPS token launch for governance (Q1)
- Expanded to Avalanche Subnets and Bitcoin L2s (March)
- Ledger Live partnership (April)
- Chrome Extension v0.2.1 release (April)

## Market Position

- 40% market share in Web3 security APIs
- Broader chain coverage than competitors
- Fully decentralized architecture
- Key partners: BNB Chain, Arbitrum, zkSync, Binance Labs
- Metrics: 500+ enterprise clients, 12M+ protected wallets
`````

## File: packages/docs/partners/hats-protocol/brief.mdx
`````
# Hats Protocol Overview

## Core Functionality

- Decentralized role-based access control using non-transferable ERC-1155 tokens ("hats")
- Creates programmable NFTs bundling permissions, responsibilities, and accountability
- Enables onchain organizational graphs, automated permission management, and revocable authorities
- Used by 50+ DAOs for treasury control, code deployment, and governance

## ElizaOS Integration Potential

- AI agents could wear hats for controlled permissions with human oversight
- Programmatic role configuration via Hats' APIs and SDKs
- Query interface through Thirdweb's Nebula plugin and Hats subgraphs
- Use cases: AI treasury management, contributor onboarding, reputation-based permissions

## Recent Developments

- ProtoDAO launch (2024) with Hats-based governance
- v1 Mainnet release with 2 security audits
- Merlin Chain partnership for Bitcoin L2 integrations
- 15 new automations including Discord role syncing and Safe transaction limits

## Market Position

- More flexible than OpenZeppelin AccessControl, more decentralized than multisigs
- Partners: Safe, Arbitrum DAO, Optimism Collective, thirdweb
- Managing $460M+ in treasuries with 120,000+ active hat wearers
`````

## File: packages/docs/partners/hedera/brief.mdx
`````
# Hedera

## About Hedera

Hedera is an enterprise-grade public distributed ledger using the **hashgraph consensus algorithm** offering high throughput, low latency, and energy efficiency. Governed by the **Hedera Governing Council** with 39 global organizations ensuring decentralized governance.

**Core Services**:

- **Hedera Token Service (HTS)**: Creates/manages tokens and NFTs
- **Hedera Consensus Service (HCS)**: Provides verifiable transaction timestamps
- **Smart Contracts**: EVM-compatible Solidity contracts
- **Decentralized Identity Solutions**

## Integration Potential with ElizaOS

- **APIs/SDKs**: JavaScript, Java, Go integration capabilities
- **Use Cases**: Tokenized assets, verifiable credentials, micropayments
- **Benefits**: High-speed infrastructure for Eliza users, ecosystem expansion for Hedera

## Recent Developments

- **Open-Source Transition** (Sept 2024): Core code transferred to Linux Foundation
- **Carbon-Negative**: Quarterly carbon credit purchases
- **HederaCon 2025**: February 2025, co-located with ETHDenver
- **Enterprise Adoption**: Google Cloud, EFTPOS, Deutsche Telekom partnerships

## Market Position

- **Performance**: 10,000+ TPS vs. Ethereum's ~30 TPS
- **Key Partnerships**: IBM, Dell, Tata Communications, FIS Global
- **Metrics**: 50+ billion mainnet transactions, 8+ million accounts
`````

## File: packages/docs/partners/heurist-ai/brief.mdx
`````
# Heurist.ai Overview

## Core Offering

Heurist AI is a decentralized ZK Layer-2 protocol for AI model hosting and inference, built to democratize AI access through distributed GPU resources. Founded in 2023, it functions as the "HuggingFace of Web3" with:

- Decentralized AI inference API
- GPU resource marketplace
- Tokenized incentives system (HEU)
- Blockchain-native model registry

## ElizaOS Integration

- Direct REST API integration for agent access to model catalog
- `elizaos-heurist` plugin enabling dynamic model selection
- Collaborative "bribe mechanism" staking for model prioritization
- Used for agent decision-making, image generation, and privacy-preserving verification

## Recent Milestones

- Q1 2025: HEU token launch reaching $5.5M market cap
- March 2025: Partnership with Exabits to tokenize 4,000+ GPUs
- April 2025: Integration with ElizaOS's Auto.fun
- Roadmap: 100+ AI models by Q3 2025, 10,000 mining nodes by EOY

## Market Positioning

Differentiators from centralized platforms and Web3 competitors:

- Micro-transaction pricing via HEU token vs. subscription models
- Permissionless operation vs. content restrictions
- Global DePIN network vs. centralized computing

Key partners: Exabits (GPU infrastructure), GenLayer (AI smart contracts), Space and Time (ZK data oracles)
`````

## File: packages/docs/partners/hume/brief.mdx
`````
# Hume

## Overview

Founded 2021 by Alan Cowen (ex-Google DeepMind), Hume is a research-driven AI company integrating emotional intelligence into technology. Their systems measure, interpret, and optimize emotional well-being in AI interactions.

## Core Products

- **Empathic Voice Interface (EVI)**: Voice AI detecting 23+ emotions, adapting responses in real-time
- **Expression Measurement API**: Analyzes voice, face, and language across 48+ emotional dimensions
- **Octave TTS**: Text-to-speech with emotionally resonant output
- **Custom Model API**: Enterprise solution for emotion-aware applications via transfer learning

## ElizaOS Integration Potential

- **API workflows**: ElizaOS can leverage Hume's emotion detection and voice synthesis
- **Use cases**: Mental health support, customer service de-escalation, natural voice assistants
- **Implementation**: No official plugin, but SDKs (Python, React) suggest compatibility

## Recent Developments

- March 2024: $50M Series B (EQT Ventures, Union Square Ventures)
- April 2024: EVI beta release
- January 2025: Octave TTS launch
- Roadmap: 50+ languages, enterprise AI therapist tools

## Market Position

- **Competitors**: OpenAI, Affectiva, Replika
- **Differentiators**: Scientific research foundation, ethics framework, multi-modal capabilities
- **Key partners**: Union Square Ventures, Comcast, LG Technology, healthcare providers
`````

## File: packages/docs/partners/hyperbolic/brief.mdx
`````
# HYPERBOLIC PLATFORM OVERVIEW

## Core Business

- Open-access AI cloud platform aggregating decentralized GPU resources
- Founded by UC Berkeley/UW researchers to democratize AI access
- Two main offerings:
  - Decentralized GPU marketplace (75% cost savings vs traditional cloud)
  - AI inference services supporting 38+ models (open-source and proprietary)
- Web3-focused with Proof-of-Sampling protocol for verifiable AI

## ElizaOS Integration

- Powers ElizaOS AI agents via dedicated plugin
- Provides low-latency, cost-effective compute backend
- Enables on-chain verification of agent decisions through PoSP
- Simple API configuration for developers to access 10,000+ GPUs
- Applications: DeFi agents, cross-chain arbitrage, NFT analytics

## Recent Milestones

- $12M Series A (Dec 2024), $20M total funding to date (Variant/Polychain)
- Opened GPU marketplace after waitlist phase
- Launched e/acc initiative for AI agent R&D (59M requests in Q1 2025)
- Developing dedicated blockchain for GPU allocation

## Market Position

- Leader in decentralized AI infrastructure
- Differentiated by verification layer and hybrid Web2/Web3 approach
- Key partnerships: ai16z, Virtuals Protocol, Near Protocol
- Metrics: 55,000+ developers, 1B+ daily inference tokens, powers 90% of top crypto-AI projects
`````

## File: packages/docs/partners/hyperfy/brief.mdx
`````
# Hyperfy

## About Hyperfy

Browser-based metaverse platform on Ethereum allowing creation and interaction with 3D virtual worlds across devices including VR. Features no-code tools, AI navigation, and launched HYPER token (January 2025). Focuses on open-world creation and Web3 interoperability rather than artificial scarcity.

## Integration with Eliza

Official ElizaOS plugin enables:

- AI agents as NPCs/environment controllers
- Persistent character memory across worlds
- Voice-based navigation
- AI-driven content generation

Technical synergies include Ethereum wallet authentication and Hyperbolic inference layer for real-time AI rendering.

## Recent Developments

- v2 Launch (Jan 2025): Open-sourced engine with free world creation
- HYPER Token: Released Jan 6, 2025 ($6.7M FDV)
- Eliza Labs Partnership: AI agent integration
- VRM Avatar Standardization: Full-body expression in 120+ worlds
- Q2 2025 Roadmap: No-code visual scripting toolkit

## Market Position

Browser-native platform with AI integration and open-source engine. Partners include Eliza Labs, Hyperbolic, and VRM Consortium. 443M HYPER tokens in circulation, 3,269 governance participants, 10,000+ worlds created since v2 launch.
`````

## File: packages/docs/partners/injective/brief.mdx
`````
# Injective Blockchain Overview

## Core Technology

- Specialized blockchain for advanced DeFi applications (DEXs, derivatives, prediction markets)
- Fully on-chain order book supporting spot, perpetual, futures, and options trading
- Cross-chain interoperability with Ethereum, Cosmos, Solana via native bridges
- Developer modules for oracles, bridges, and multi-VM smart contracts (CosmWasm, EVM, SVM)
- Zero gas fee structure and MEV protection

## Potential ElizaOS Integration

- API-based access to Injective's cross-chain trading infrastructure
- Smart contract composability for automated financial workflows
- Possible institutional asset management via Fireblocks partnership

## Recent Developments (2024-2025)

- Block time optimization to 0.64 seconds
- $150M ecosystem fund backed by Pantera, Kraken Ventures, Jump Crypto
- Electro Chain launch enabling cross-chain dApps
- Wormhole integration expanding to Aptos, Polygon, Avalanche

## Market Position

- Competing with DeFi L1s like dYdX and THORChain
- Ecosystem includes Helix DEX and Frontrunner prediction markets
- Strategic partnerships with Kraken, Delphi Labs, and Fireblocks
- Institutional focus on asset tokenization and high-frequency trading
`````

## File: packages/docs/partners/io-net/brief.mdx
`````
# IO.net

## Core Overview

IO.net is the world's largest decentralized GPU cloud network, aggregating underutilized computing resources across 138+ countries. It offers AI/ML developers up to 90% cost savings compared to AWS through its DePIN (Decentralized Physical Infrastructure Network) model.

## Key Products

- **IO Cloud**: Instant ML cluster deployment via decentralized GPU pools
- **IO Intelligence**: Custom AI model training and API integrations
- **Worker Marketplace**: Platform for GPU owners to monetize idle resources
- **Solana-Powered Payments**: Instant $IO token transactions

## Eliza Integration

Likely features include direct API access to GPU clusters, unified $IO token billing, and support for training AI agents and LLM inference workloads.

## Recent Developments

- Expanded from 24,000 to 89,000 GPUs (Feb-Mar 2024)
- Partnered with Injective for DeFAI applications with 10,000+ GPUs
- Planned revenue-sharing for $IO stakers (Q2 2025)
- Onboarded 50+ AI startups including Ritual and Banyan

## Market Position

- Largest decentralized GPU network (95,000+ GPUs)
- 90% cost reduction vs traditional cloud providers
- Key partnerships with Filecoin/Render, Injective, and Solana
- 1,000+ active clusters monthly; 500,000+ registered GPU suppliers
`````

## File: packages/docs/partners/iq6900/brief.mdx
`````
# IQ6900

## Core Offering

Decentralized AI-agent infrastructure for Web3, featuring permanent on-chain storage for AI content, meme templates, training datasets, and algorithmic outputs. Ensures content authenticity and auditability in synthetic media.

## Eliza Integration

- **On-Chain Memory**: Permanent recording of agent interactions and knowledge updates
- **Verified Content Retrieval**: Provenance-checked AI content for research
- **Co-Learning Framework**: Tamper-evident training histories for agents
- **Applications**: Authenticated AI journalism and scam-resistant DeFi content

## Recent Developments

- **Market**: IQ token up 85.9% to $32.5M market cap (Jan 2025)
- **Technical**: Launched "Memetic L2" testnet for high-frequency AI content storage
- **Partnerships**: Joined ARC Agents Network for AI Arena verified training data

## Ecosystem Position

- Competes with Ocean Protocol by offering native Web3 composability
- Key partners: FightFi (combat AI logs), Sigma Music Agent (music metadata), FXN Network (distributed AI training)
`````

## File: packages/docs/partners/jupiter-exchange/brief.mdx
`````
# Jupiter Exchange Summary

Jupiter Exchange is a premier DEX aggregator on Solana that optimizes token swaps by accessing liquidity from multiple sources. As Solana's default liquidity infrastructure, it handles $47B in monthly volume (March 2024) with $2.8B TVL, rivaling Ethereum-based platforms like 1inch and Uniswap.

## ElizaOS Integration

- **Magic Fund**: Joint $10M grant program (April 2025) for open-source AI/Web3 projects
- **Unified Wallet**: ElizaOS v2 agents execute cross-chain trades via Jupiter
- **Event-Driven Trading**: Agents analyze on-chain data to trigger automated swaps

## Recent Developments

- **Swap V3/Metropolis** (June 2024): AI-powered backend enhancing routing
- **ElizaOS Partnership** (January 2025): Announced at Catstanbul
- **TVL Growth**: Reached $2.8B in Q1 2025

## Market Position

- Dominates Solana's DEX landscape (3x TVL of Raydium)
- Partnerships with Jito, Phantom Wallet, and Pump.fun
- 1.2M+ monthly active traders (March 2025)
`````

## File: packages/docs/partners/layerzero/brief.mdx
`````
# LayerZero Protocol Summary

## Core Overview

LayerZero is an omnichain interoperability protocol enabling direct cross-chain communication across 70+ blockchains including Ethereum, Solana, Arbitrum, and Hedera. Trusted by PayPal, Ethena, and HBAR Foundation, it solves blockchain fragmentation by unifying liquidity pools and simplifying cross-chain development.

## Key Products

- Omnichain messaging protocol for smart contracts
- Cross-chain bridges (LayerZero USDC)
- OApp (Omnichain Application) development tools
- Decentralized oracle/relayer verification system

## Eliza Integration

- Cross-chain AI agents operating seamlessly across networks
- RAG capabilities leveraging on-chain data from multiple chains
- Multi-VM smart contracts combining Rust-based Stylus with EVM/Solana VM
- Integration via Arbitrum's MultiVM architecture, tokenized incentives, and interchain oracles

## Recent Developments

- Hedera integration for institutional liquidity (Oct 2024)
- V2 Protocol with DVN configurations and gasless transactions (Dec 2024)
- Rayls partnership for CBDC transfers across 120+ chains (Feb 2025)
- Stargate v3 upgrade for unified AMM liquidity (Mar 2025)
- Upcoming zk-proof enhanced settlement testnet (2025)

## Market Position

- 2.1M daily cross-chain messages (3x Wormhole volume)
- $16B+ total bridged value
- 48% market share in omnichain DeFi TVL
- Key partnerships with Arbitrum, Hedera, and Radix
`````

## File: packages/docs/partners/lit-protocol/brief.mdx
`````
# Lit Protocol

## Core Offering

A decentralized network for access control, programmable wallets, and serverless signing using threshold cryptography and TEEs. The system distributes encrypted key shares across nodes, preventing single-entity control.

## Key Features

- **Lit Actions**: JavaScript smart agents executing cross-chain workflows
- **Decentralized Key Management**: Non-custodial cryptographic key infrastructure
- **Cross-Chain Interoperability**: Unified access control across EVM chains, Solana, Cosmos, and Web2

## ElizaOS Integration

Available via `@elizaos/plugin-lit`, enabling:

- Lit Action deployment directly to network
- Threshold signature-based transaction signing
- Encrypted memory management for agent data

Example:

```javascript
await elizaOS.lit.initialize();
const signature = await elizaOS.lit.tools.ecdsaSign({
  message: 'Agent instruction',
  chain: 'solana',
});
```

## Recent Milestones

- Solana mainnet support (2024)
- v1 decentralized network launch with 50+ operators
- 24M+ requests processed by Q1 2025
- 180+ projects built on platform
- 40% monthly growth in Solana integrations

## Key Partnerships

Crossmint (NFT unlockables), Collab.Land (token-gated access), Streamr (encrypted data)
`````

## File: packages/docs/partners/magic-eden/brief.mdx
`````
# Magic Eden

## Overview

Magic Eden is a multi-chain NFT marketplace operating across Solana (90% market dominance), Bitcoin, Ethereum, Polygon, Base, and 10+ other blockchains. Ranked #2 globally with $139M+ monthly trading volume and 5M+ monthly active users.

## Core Offerings

- **Launchpad**: Platform for minting new NFT projects
- **Trait Offers**: Targeting specific NFT attributes for purchases
- **Marketplace Aggregation**: Cross-platform listing tracker
- **Marketplace API**: Developer tools for third-party integration (Q1 2024)

## Eliza Integration

Magic Eden's dedicated ElizaOS plugin enables:

- Smart contract automation for NFT transactions
- Real-time data syncing for wallet and marketplace tracking
- Cross-chain arbitrage via API integration
- AI-generated NFT minting capabilities

## Recent Developments

- 40% Bitcoin Ordinals trading volume capture (Q4 2024)
- Partnerships with ApeChain and Berachain for gaming NFTs
- 2025 roadmap: AI curation tools and cross-chain liquidity pools
- Strategic collaborations with Phantom Wallet, Star Atlas, and Yuga Labs
`````

## File: packages/docs/partners/mee-fun/brief.mdx
`````
# Mee.fun Overview

Mee.fun is an AI agent launchpad for Web3 ecosystems that enables no-code creation, deployment, and monetization of autonomous AI agents. As an ElizaOS partner, it democratizes AI agent development through:

**Core Features:**

- No-code agent builder with workflow templates
- Tokenization tools for utility tokens
- Cross-chain compatibility (EVM chains and Solana)

**ElizaOS Integration:**

- Official plugin in elizaos-plugins GitHub repository
- Seamless agent migration between platforms
- Shared liquidity pools and economy
- Cross-platform interoperability
- Shared TypeScript libraries and security audits

**Recent Milestones:**

- Q2 2025: Solana-based NFT ticket system
- March 2025: FightFi partnership for gaming metaverse
- Roadmap: Unity SDK for 3D gaming (Q3 2025)

**Market Differentiators:**

- Deeper ElizaOS integration than competitors
- Dual-chain support (EVM/Solana)
- Lower fees (0.5% vs industry average 2-5%)
- Enterprise partnerships (e.g., Sigma Music Agent)
- Metrics: 15,000+ agents launched, $4.2M revenue Q1 2025 (unverified)
`````

## File: packages/docs/partners/messari/brief.mdx
`````
# Messari

Messari is a crypto market intelligence platform founded in 2018 that standardizes blockchain data across 900+ assets using machine learning and human verification.

## Key Products

- **Protocol Metrics**: Standardized blockchain comparison dashboards
- **Data Apps**: Enterprise analytics tools (beta)
- **Token Explorer**: Asset health indicators and unlock schedules for 90+ tokens
- **News Aggregator**: AI-curated crypto news with multi-source verification

## Business Details

- Raised $35M Series B funding
- Partners with major exchanges, custody providers, and investment firms
- Competes with CoinGecko, Glassnode, and Nansen
- Differentiated by institutional data normalization and regulatory compliance focus

## Recent Developments

- **August 2024**: AI News Recaps feature
- **May 2024**: Expanded Token Unlock dashboard
- **Q2 2024**: Exchange Flow Metrics for institutional liquidity tracking

## Potential Eliza Integration

No official plugin exists, but technical synergies could include data interoperability, alert forwarding, premium API access, and research syndication.
`````

## File: packages/docs/partners/mode-network/brief.mdx
`````
# Mode Network

## Overview

Mode Network is an AI-optimized Layer 2 blockchain built on Optimism's OP Stack, designed to scale DeFi through autonomous AI agents. As part of the Optimism Superchain ecosystem, it shares security and interoperability with chains like Base and Zora while rewarding developers and users directly through fee sharing and referral incentives.

## Core Offerings

- **DeFAI L2 Infrastructure**: Hosts 50+ DeFi applications optimized for AI agents
- **Native Perpetuals DEX**: Partnership with Orderly Network for low-fee trading with AI tooling
- **AI Terminal**: Interface for ecosystem interactions, enhanced by Synth's predictive data
- **Restaking Solutions**: Collaborations with Renzo and EtherFi for optimized ETH yields

## ElizaOS Integration

- Enables AI agents to autonomously execute trades, manage portfolios via TypeScript plugins
- Synth subnet provides synthetic Bitcoin price data to enhance agent predictions
- Facilitates cross-chain automation between Mode and Bitcoin via Merlin Chain

## Recent Milestones

- Q1 2025: $2M OP token grant program for DeFAI development
- Q3 2025: TVL reached $480M driven by AI-powered vaults
- Q4 2025: Released v0.25.8 of ElizaOS with dynamic plugin loading

## Market Position

- 50+ deployed dApps with 120,000+ monthly active addresses
- Key partnerships with Optimism Collective, EigenLayer, and Merlin Chain
- Competes with Fetch.ai and Ocean Protocol but differentiates through Superchain integration
`````

## File: packages/docs/partners/monad/brief.mdx
`````
# Monad: High-Performance EVM-Compatible Blockchain

## Core Features

- EVM-compatible L1 blockchain with 10,000 TPS, 1-second blocks, near-zero fees
- Full Ethereum bytecode compatibility for seamless developer migration
- MonadBFT consensus mechanism and parallel-optimized MonadDB state storage
- Solves blockchain trilemma through single-shard architecture

## ElizaOS Integration

- Direct blockchain access for transactions, smart contracts, dApps
- Supports high-throughput applications (gaming, DeFi arbitrage)
- EVM-compatible development within ElizaOS workflows
- RPC compatibility enables seamless integration

## Recent Developments

- Chainlink Scale Partnership (April 2025) for oracle services
- Mainnet launch scheduled for 2025; testnet achieved 8,000+ TPS
- $50M ecosystem grants program for developers
- Added 20+ engineers specializing in distributed systems

## Market Position

- Outperforms Solana (EVM compatibility) and Ethereum (speed)
- Competes with Avalanche/Polygon with better finality and lower fees
- Key partnerships: Chainlink, Pyth Network, Ether.fi
- 200+ dApps migrated during testnet, 40,000+ active developer accounts
`````

## File: packages/docs/partners/multiversx/brief.mdx
`````
# MultiversX Overview

## Core Platform

- Internet-scale blockchain with 3,000+ nodes using adaptive state sharding
- Balances enterprise-grade scalability with security and energy efficiency
- Powers DeFi, metaverse ecosystems, and enterprise solutions

## Key Products

- EGLD cryptocurrency (staking, payments, governance)
- WASM Virtual Machine for smart contracts
- xExchange DEX and xPortal super app
- Sovereign chain solutions for enterprises

## Eliza Integration via mx-agent-kit

- Open-source framework enabling AI-blockchain interaction
- Capabilities: autonomous cross-shard transactions, token management, AI liquidity provisioning
- Use cases: AI-controlled DAOs, ML-powered arbitrage, automated compliance
- Features secure transaction signing with nonce management and status tracking

## Recent Progress

- Jan 2025: ElizaOS partnership launched
- Q4 2024: Phase-sharded smart contracts deployed
- 1,200+ commits in 6 months
- 40% throughput increase via consensus optimization

## Market Position

- Performance: 12x faster than Solana in cross-shard operations, 1/3 of Ethereum's energy use
- Partners: Google Cloud, Deutsche Telekom, Chainlink, major exchanges
- Metrics: 2.1M active wallets, $4.7B TVL, 37% YoY developer growth
`````

## File: packages/docs/partners/near/brief.mdx
`````
# NEAR Protocol

## Core Overview

NEAR is a Layer 1 blockchain combining AI capabilities with chain abstraction technology, processing 1.3M daily transactions with 1-second finality. It supports JavaScript development, uses human-readable accounts, and ranks in the top 20 blockchain ecosystems ($5.8B market cap).

## Key Products

- Chain Abstraction SDK for cross-chain interoperability
- Nightshade sharding for scalability
- FastAuth passwordless authentication
- AI agent framework
- Human-readable accounts (e.g., alice.near)

## Eliza Integration

The **elizaos-near-plugin** enables:

- AI agents to deploy/manage NEAR smart contracts
- Cross-chain liquidity position management
- Protocol-level execution of agent strategies

**Use Cases**: AI-managed portfolios, cross-chain DAOs, and NFT marketplaces

## Recent Developments

- 2025: Launched NEAR AI Runtime, partnered with Saga for Chainlets, integrated zkWASM
- 2024: Reached 8M monthly active accounts, deployed Meta Transactions
- Upcoming: Horizontal sharding for AI (Q3 2025), on-chain agent reputation system (Q4 2025)

## Market Position

- Performance: 100K+ TPS, 1-sec finality, $0.01 avg fee
- Partnerships: Ankr (multi-chain RPC), Saga (AI infrastructure), Mintbase (NFTs)
- Metrics: $4.3B TVL, 45% AI-agent transactions, 80% MoM AI developer growth
`````

## File: packages/docs/partners/niftyisland/brief.mdx
`````
# NiftyIsland Overview

## Core Platform

NiftyIsland is a Web3 gaming platform merging user-generated content, NFTs, and decentralized creation tools. Players can build customizable islands, create games, and display NFT collections in a shared metaverse environment. The platform positions as a "blockchain Roblox" with 70,000+ user-created islands and 1.3M active participants.

## Key Features

- Free 3D islands with customization tools
- NFT integration supporting 120+ collections
- Play-to-earn mechanics with $ISLAND token rewards
- No-code game creation toolkit
- Decentralized marketplace for in-game assets
- Zero gas fees for basic interactions

## Eliza Integration

- ElizaOS agents operate within NiftyIsland using DePin integrations
- AI-assisted content creation through prompt-based tools
- Agent-based player behavior analytics
- IoTeX DePIN infrastructure enables:
  - Real-time data integration via Nubila network
  - Location-based gameplay with GeodNet
  - IoT device interaction through Pebble Tracker

## Recent Milestones

- 2024 Q2: Season 2 launch with 500k $ISLAND prize pool
- 2024 Q1: IoTeX DePIN integration
- 2023 Q4: 75,000 unique digital assets created

## Market Position

- Exceeds Decentraland by 300% in active creators
- 50% faster content creation vs The Sandbox
- Partners include Yuga Labs, IoTeX, Polygon, and 120+ NFT projects
`````

## File: packages/docs/partners/nillion/brief.mdx
`````
# Nillion

## About Nillion

Nillion is a decentralized secure computation network processing sensitive data without decryption using multi-party computation (MPC) and homomorphic encryption (HE). It enables blind computation where third parties can perform operations on encrypted data while preserving privacy. The infrastructure serves as a privacy layer for applications in AI, healthcare, finance, and identity management.

Key offerings:

- **Blind Modules**: Pre-configured privacy computation clusters
- **nilChain**: Coordination layer for governance, staking, and transactions
- **Petnet**: Orchestration tools combining various privacy-enhancing technologies (PETs)

## Integration with Eliza

While no official ElizaOS plugin is documented publicly, the partnership likely enables:

- Secure storage of credentials, health records, and financial data
- Privacy-preserving AI inference and analytics
- Decentralized identity with zero-knowledge proofs

## Recent Developments

- Mainnet launched in 2024, supporting projects like Ritual and Monadic DNA
- 35+ confirmed partners including Aloha AI and Salt
- NIL token launched on CoinList (March 2025, $750M FDV)
- Aligned with Apple's private AI vision but emphasizes decentralized trust
- Expanding Petnet capabilities and developer tooling

## Market Position

Positioned as a privacy compute layer, distinct from transaction-focused chains and co-processors. Notable partnerships include Ritual (decentralized AI), Soarchain (130M+ privacy-preserved IoT data points), and Aloha (dating app).
`````

## File: packages/docs/partners/nrn-agents/brief.mdx
`````
# NRN Agents Overview

## Core Business

- Develops AI agents for Web3 gaming via reinforcement learning
- Flagship SDK enables adaptive NPCs in blockchain games
- Serves as AGI testing environment through gaming
- Partnered with Ronin, Arbitrum, Aethir Cloud
- 83% market share among EVM-compatible games

## Eliza Partnership

- ElizaOS agents can deploy NRN-trained gaming models
- Cross-platform memory between gaming/non-gaming contexts
- $NRN integrates with Eliza's credential system
- Joint AGI research initiatives
- Planned modules: Battle Simulator, Skill NFT Converter

## Timeline & Development

- 2025 Q1: SDK launch on Ronin Network with AI Arena
- 2025 Q2: Multi-chain expansion (Solana VM, Move-based chains)
- 2025 Q3: $4.2M raise from a16z Gaming and BITKRAFT
- 2026 Q1 Target: "Uncertainty Engine" for novel game scenarios

## Partnerships

- Sky Mavis: 10M+ agent deployments on Ronin
- Aethir Cloud: Distributed GPU infrastructure
- Ultiverse: AI-driven virtual worlds
- Competitive advantage: 37% faster adaptation vs. Inworld AI and Altered State Machine
`````

## File: packages/docs/partners/partners-nft/brief.mdx
`````
# Partners NFT Overview

**Core Information:**

- 5,555 unique PFP NFTs on Solana blockchain
- Originally community-driven, now officially backed by ElizaOS (formerly ai16z)
- Functions as ecosystem access pass with governance rights
- Bridges NFT communities with decentralized AI infrastructure

**ElizaOS Integration:**

- Potential use as decentralized identifiers (DIDs) for AI agents
- Dedicated plugin for AI agent interactions
- Governance rights over AI development

**Key Developments:**

- ai16z rebranded to ElizaOS (January 2025)
- Floor price peaked at 13.1 SOL ($2,424) during token launch
- Partnership with Gort Labs for AI-enhanced meme economies

**Market Status:**

- 2,686 unique holders (48% of supply)
- $500k+ market cap
- Competitors: 2049 // Reflections (Ethereum), Virtuals Land (Base)
- Partnerships with Magic Eden, LayerZero
`````

## File: packages/docs/partners/phala-network/brief.mdx
`````
# Phala Network Condensed Overview

## Core Offering

Phala Network is a decentralized cloud computing platform focused on verifiable, privacy-preserving computation using Trusted Execution Environments (TEEs) and blockchain technology.

## Key Products

- **Phala Cloud**: TEE-powered decentralized cloud for secure AI/blockchain workloads
- **Phat Contracts**: Serverless, privacy-focused smart contracts with multi-chain compatibility
- **TEE Clusters**: Secure computing nodes with redundancy and fault tolerance

## Integration with Eliza

- Provides TEE-secured infrastructure for ElizaOS agents
- Enables secure API key management, private on-chain transactions, and multi-agent coordination
- Official plugin: ElizaOS-Phala Plugin for TEE-backed memory storage and document processing
- Updated phala-cloud-cli (March 2025) simplifies ElizaOS workflow deployment
`````

## File: packages/docs/partners/polygon/brief.mdx
`````
# Polygon Overview

## Core Technology

- Layer 2 scaling solution for Ethereum using modular frameworks and zero-knowledge technology
- Key products:
  - Polygon PoS: Proof-of-stake sidechain (~7,000 TPS, less than 2s finality)
  - Polygon zkEVM: ZK-rollup with Ethereum security and 90% lower costs
  - Chain Development Kit (CDK): Open-source toolkit for ZK-powered L2 chains
- First scaling solution exceeding 1B transactions, supporting 50,000+ dApps, securing $5B+ assets
- Founded 2017 by Jaynti Kanani, Sandeep Nailwal, and Anurag Arjun

## ElizaOS Integration

- Technical components:
  1. On-Chain AI Agents: Plugin enables contract interaction, chain monitoring, cross-chain operations
  2. Co-developed zkOracle, gasless relayer service, MEV-resistant bundler
  3. $1M POL grant fund for AI-agent development with shared validator nodes
- Use cases: Cross-chain DeFi optimizers, NFT portfolio management agents

## Recent Developments

- Toposware acquisition (2024) for ZK research
- Elderberry Upgrade (2025): 40% faster zkEVM proofs
- Testnet expansion for account abstraction and decentralized sequencers
- ElizaOS Grant Program (2025)
- 2025 Roadmap: Unified liquidity layer across Polygon chains

## Market Position

- Leading Ethereum scaling solution: 4.6M daily transactions, $1.2B TVL, 64% EVM L2 market share
- Key partnerships: Aave ($900M liquidity), OpenSea, Stripe, Dolce & Gabbana
`````

## File: packages/docs/partners/project-89/brief.mdx
`````
# PROJECT 89 SUMMARY

## Core Concept

Project 89 is an AI-driven collective intelligence platform on Solana combining blockchain and agent systems to create interactive narrative experiences through mission-based gameplay with rank progression (Initiate → Master).

## Key Technical Components

- **AI Agent Hierarchies**: Tiered system unlocking advanced AI tools
- **Mission Economy**: Tokenized challenges blending physical/digital tasks
- **Swarm Intelligence**: Networks of specialized AI agents with cross-platform personas

## Eliza Integration

- Shared agent memory architectures and skill plugins
- Cross-platform persona synchronization
- ElizaOS Plugin enabling Eliza agents in Project 89 missions
- Bridging Web2 APIs to Web3 environment

## Timeline & Development

- Jan 2025: Official partnership with Eliza Labs
- Q1 2025: ARGOS Engine v2 launch
- Q3 2025 Roadmap: On-chain agent breeding, AR mission layers, governance DAO

## Market Position

- Unique blend of ARG gameplay with AI agent infrastructure
- 23% faster mission resolution than competitors
- Partners: Eliza Labs, Microsoft, Solana Foundation
- 20,000+ active users (Dec 2024)
- 147% QoQ growth in agent deployments
`````

## File: packages/docs/partners/reality-spiral/brief.mdx
`````
# Reality Spiral Overview

## Core Business

Reality Spiral develops decentralized AI agent infrastructure for blockchain and metaverse environments, enabling AI to interact with smart contracts and operate in decentralized networks.

## Key Products

- **AI Agent Infrastructure**: Modular framework for blockchain-integrated AI
- **Metaverse Integration Tools**: Solutions for AI swarms in virtual environments
- **RSP Token**: Currently a meme coin with future utility potential

## Eliza Integration

- **Secret AI SDK**: Enables confidential transactions for Eliza agents
- **Shared Developer Tools**: Joint ElizaOS framework resources
- **Use Cases**: Privacy-focused AI economies and autonomous identity management
- **Technical Status**: #2 contributor to Eliza's GitHub repository

## Recent Developments

- Secret Network partnership for AI privacy (Feb 2025)
- AI swarm metaverse construction demonstrations (Jan 2025)
- Plans to evolve RSP token for governance and staking

## Market Position

- **Unique Focus**: AI-agent infrastructure for Web3
- **Key Partners**: Eliza Labs, Secret Network, Bitcoin Product Community
- **Current Adoption**: Strong developer activity but limited token adoption (less than $500k market cap)
`````

## File: packages/docs/partners/ropraito/brief.mdx
`````
# Ropraito

## Core Identity

Ropraito is an AI agent platform specialized for Web3 ecosystems, enabling autonomous blockchain interactions and decentralized application management. Serves as a strategic partner in the ElizaOS ecosystem by connecting AI capabilities with blockchain functionality.

## ElizaOS Integration

- Official plugin enables Ropraito agents to access ElizaOS services (document stores, memory systems)
- Shares Eliza's security layer for transaction validation and prompt injection protection
- Combined environment merges Web3 capabilities with multi-platform connectivity (Discord, Telegram, Twitter)
- Use cases: cross-platform DAO governance bots, multi-channel NFT portfolio managers

## Development Timeline

- Q1 2025: Gas-aware transaction bundling for Ethereum L2 optimization
- Q4 2024: Arbitrum Nova integration for low-cost agent microtransactions
- Q3 2025: Planned AI-powered MEV detection and mitigation

## Market Focus

- Institutional DeFi through crypto custody provider partnerships
- GameFi ecosystems via P2E studio collaborations
- Cross-chain infrastructure with verified compatibility for Polygon zkEVM and Solana
`````

## File: packages/docs/partners/safe/brief.mdx
`````
# Safe: Key Information Summary

## Core Overview

- Founded 2018 by Richard Meissner and Lukas Schor
- Leading decentralized custody protocol for digital assets on 100+ EVM networks
- Secures over $100B in assets for users like Vitalik Buterin, Shopify, AAVE, and 1inch

## Product Stack

- **Safe Core**: Modular account abstraction developer stack
- **Safe Wallet**: Non-custodial interface for individuals/DAOs
- **Safe Pass**: Ecosystem rewards program

## Market Position

- ~60% market share in institutional smart accounts
- 8M+ smart accounts created
- 40% YOY enterprise client growth
- Key advantages: broad chain support, strong audit record, enterprise permissioning

## Integration Potential

- Safe&lbrace;Core&rbrace; API enables direct integration with platforms like ElizaOS
- Supports custom plugin development for cross-chain asset management
- Enables gas abstraction and shared security models

## Recent Developments (2024)

- Launched 14+ ERC-7579 modules with Rhinestone & Pimlico
- Base collaboration providing free gas credits
- Fully decentralized governance via SafeDAO and SAFE token

## Key Partners

- Chains: Base, Avalanche, Polygon
- Infrastructure: Gelato, Web3Auth
- dApps: AAVE, Uniswap, 1inch
`````

## File: packages/docs/partners/saga/brief.mdx
`````
# SAGA BLOCKCHAIN - CONCISE OVERVIEW

## Core Technology

- Layer-1 blockchain enabling application-specific blockchains ("Chainlets")
- Provides parallelized architecture for infinite horizontal scalability
- Automated chain deployment system with shared validator network
- Eliminates traditional barriers like validator recruitment and security setup
- Solves congestion and fee issues common in monolithic blockchains

## Eliza Integration (Metropolis)

- ElizaOS agents deploy and manage Chainlets autonomously
- AI agents utilize Saga's infrastructure for dedicated blockchain environments
- Wayfinder AI agents automate contract deployment and cross-chain liquidity
- Shared security model reduces operational overhead while maintaining protections
- Enables AI agents to execute complex on-chain strategies

## Key Developments

- Mainnet launched April 2024 with subsequent Pegasus upgrades
- Liquidity Integration Layer (LIL) planned for Q1 2025
- Metropolis initiative partners include Virtuals, Eliza Labs, and Wayfinder
- Implemented dynamic pricing via reverse auctions

## Market Position

- Differentiates from competitors (Polkadot, Avalanche) via full automation
- Strategic partnerships with Ethereum, Polygon, Avalanche ecosystems
- Focus on high-throughput use cases in AI and gaming sectors
- Multiple AAA game developers building on platform
`````

## File: packages/docs/partners/scriptoshi/brief.mdx
`````
# Scriptoshi

## Overview

Scriptoshi combines AI and Web3 to create autonomous agents that automate blockchain interactions. Their platform simplifies complex DeFi operations, smart contract deployments, and cross-chain asset management using LLMs for decision-making while executing on-chain actions directly.

## Eliza Integration

Integrates via `@elizaos/scriptoshi-agent` plugin offering:

- Secure key management through Eliza's TEE
- Multi-agent orchestration across Eliza characters
- Intent-based cross-chain swaps
- Natural language smart contract deployment
- Automated portfolio rebalancing

## Recent Developments

- Q1 2025: GasGuard™ optimization engine (18-37% fee reduction)
- March 2025: Solana Firedancer integration (2,000 TPS)
- April 2025: LayerZero partnership (30+ blockchain connectivity)
- Coming: V3 with zk-proof verified actions for regulatory compliance

## Market Position

- Differentiator: Visual no-code workflow builders vs code-first competitors
- Partnerships: Chainlink, Aztec, Arbitrum
- Usage: 140+ dApps, ~850k monthly transactions
- Competitors: Fetch.ai, Fuse's Edison AI
`````

## File: packages/docs/partners/secret-network/brief.mdx
`````
# Secret Network Overview

Secret Network is a Layer 1 blockchain (launched 2020) specializing in privacy-preserving smart contracts with encrypted input, output, and state for dApps. Built on Cosmos SDK with Tendermint consensus, it enables customizable privacy while maintaining interoperability.

## Core Offerings

- **Secret Contracts**: Privacy-focused smart contracts using Rust-based CosmWasm
- **SNIP-20 Tokens**: Private fungible tokens with hidden balances and transaction data
- **Cross-Chain Connectivity**: Ethereum and Cosmos bridges with IBC support
- **Privacy dApps**: SecretSwap (DeFi), encrypted data storage, and NFTs with hidden metadata

## Significance

Secret Network addresses blockchain privacy limitations, enabling previously impractical use cases like private voting, credit scoring, and medical data management. It serves as foundational infrastructure for confidential computing in Web3 and AI.

## Recent Developments

- **CCL Aurora Upgrade** (May 2024): Enhanced confidential computing for AI applications
- **Privacy-as-a-Service**: APIs for verifiable randomness and encrypted oracles
- **Ecosystem Growth**: $400M fund supporting projects like Shade Protocol and Blizzard Finance

## Market Position

- **Differentiation**: Live mainnet with Cosmos interoperability versus competitors (Oasis, Dusk, Aleo)
- **Ecosystem**: 50+ deployed dApps including SecretSwap and Alter
- **Roadmap**: ZK-proof integration and expanded TEE support
`````

## File: packages/docs/partners/sei/brief.mdx
`````
# Sei Network Overview

## Core Offering

- Trading-focused blockchain with 12,500 TPS and 380ms finality
- Built on Cosmos SDK with unique optimizations
- Features: native order matching engine, parallelized transaction execution
- First blockchain with parallelized EVM (Sei v2)
- Balances Solana-like performance with Ethereum compatibility

## Potential ElizaOS Integration

- Technical synergies via EVM compatibility
- Possible use cases: portfolio rebalancing, DEX aggregation, NFT trading
- Could reduce latency for Eliza users

## Recent Milestones

- Sei v2 (2024): parallelized EVM and SeiDB storage
- Ecosystem grants to DragonSwap (AMM) and Pallet Exchange (NFT marketplace)
- Pyth Network partnership for price feeds
- Mainnet upgrade with 390ms finality (fastest Layer 1)

## Market Status

- 50+ dApps post-mainnet
- $85M raised from investors including Multicoin Capital
- Partners: Pyth Network, Magic Eden, multiple Cosmos chains
`````

## File: packages/docs/partners/smolverse/brief.mdx
`````
# Smolverse Overview

Smolverse is a Web3 gaming metaverse built on Arbitrum within the TreasureDAO ecosystem featuring:

**Core Components:**

- Multiple NFT collections (Smol Brains flagship, Bodies, Pets, Cars, Treasures)
- Smolville: RPG with quests/crafting by Darkbright Studio (launch 2025)
- Interactive community-driven world with evolving lore
- $MAGIC as native currency for asset trading on Trove marketplace

**ElizaOS Integration:**

- Partnership enables autonomous AI agents within gameplay
- Potential for automated tasks, resource management, dynamic NPCs
- Enhances gameplay while expanding ElizaOS use cases in decentralized gaming

**Recent Developments:**

- Treasure Chain Testnet (2024): Gaming-focused L3 rollup
- Smolville trailer showcasing mechanics
- Infrastructure partnerships with EigenLayer, LayerZero, Thirdweb

**Positioning:**

- Gaming-focused metaverse competing with Decentraland/Sandbox
- Part of TreasureDAO's broader ecosystem ($4B+ NFT volume)
- Community ownership emphasis with tradable assets
`````

## File: packages/docs/partners/society-library/brief.mdx
`````
# Society Library Overview

## Core Function

Society Library operates at the intersection of AI, decentralized governance, and collective intelligence, providing "deliberative democracy as a service" through:

- AI-powered debate mapping using NLP
- Blockchain-based voting mechanisms
- Open-source frameworks for equitable AI access

## Key Achievements

- Mapped AI alignment/safety debates using ML (2023)
- Pioneered "conceptual portmanteau" systems merging web content into knowledge structures

## Eliza Integration

```typescript
import { Society } from '@eliza/plugin-society-library';
agent.use(Society({ debateTopics: ['AI Safety', 'DAO Governance'], votingWeight: 0.75 }));
```

**Capabilities:**

- Synthetic voting in governance debates
- Access to structured argument maps
- Policy proposal auto-generation
- Shared cryptographic primitives and reputation bridges

## Timeline

- Q1 2025: "Deliberative Democracy as a Service" API launch
- Dec 2024: Anthropic partnership on constitutional AI alignment
- Roadmap: Agent debate leagues (Q3 2025), FHE-based private voting (2026)

## Market Position

- Unique combination of AI debate analysis, on-chain governance, and cross-platform discourse aggregation
- Partners: Internet Archive, Protocol Labs, US Congressional AI Caucus
- Adopted by 47 DAOs managing $1.2B+ assets
`````

## File: packages/docs/partners/solana-agentkit/brief.mdx
`````
# Solana AgentKit

## Overview

Solana AgentKit is an open-source toolkit by SendAI that enables AI agents to autonomously execute 60+ on-chain Solana blockchain operations. Built with TypeScript, LangChain, and Vercel AI SDK, it translates natural language into blockchain actions via LLMs (OpenAI/Perplexity).

## Technology

- Modular plugins to reduce AI hallucinations
- Embedded wallet support (Turnkey/Privy) for secure transactions
- Real-time integrations with Jupiter Swap, Raydium, Jito
- Solana Blinks for social media transaction embedding
- On-chain data access via Pyth Network and CoinGecko Pro

## Key Features

- 60+ autonomous actions: token minting, AMM creation, perpetuals trading, zk-airdrops
- Multi-chain bridging via Wormhole and deBridge
- DALL-E powered NFT generation and Metaplex deployment
- DeFi automation: Solayer staking, JitoSOL restaking, Pump.fun launches
- Security: Jito bundle audit trails, granular permissions
- Mobile optimization with React Native SDK

## ElizaOS Integration

- ElizaOS agents access AgentKit via Solana Toolbelt module
- Synchronized transaction history between platforms
- Cross-platform workflows (Discord/Twitter → Solana)
- ai16z DAO governance tokens authorize high-value transactions

## Timeline

- Q1 2025: JitoSOL restaking module (23% APY)
- March 2025: Adrena Protocol integration
- April 2025: Mobile SDK for Telegram bots
- Upcoming: SVM for AI-generated smart contracts (Q3 2025), Firedancer integration (2026)

## Market Position

- 367% faster than Ethereum-based frameworks
- 42% adoption in Solana hackathons (2024-25)
- Partnerships: Jito Labs, Pump.fun, Helius, Crossmint
- 105k+ monthly NPM downloads, 1,153 GitHub stars
- Used by 17% of Solana DeFi protocols

## Links

- https://www.solanaagentkit.xyz
- https://github.com/sendaifun/solana-agent-kit
- https://kit.sendai.fun
- npm: `solana-agent-kit`
`````

## File: packages/docs/partners/solana-foundation/brief.mdx
`````
# Solana Foundation Overview

## Core Information

- Swiss non-profit established 2020
- Governs Solana blockchain (65,000+ TPS)
- Fourth-largest blockchain by market cap
- Focuses on decentralization, security, and censorship resistance

## Key Programs

- **Delegation Program**: Incentivizes validators for performance/distribution
- **Stake Pools**: Liquid staking for SOL holders
- **Grants Program**: $50M+ to 350+ projects since 2021
- **Developer Tools**: Rust SDK, Web3.js, Sealevel parallel runtime

## Eliza Integration

- **AI16Z Token**: Native ERC-20 compatible token on Solana
- **Smart Contract Oracles**: Real-time data for AI decisions
- **Transaction Batching**: 10,000+ agent actions per block
- **Governance Portal**: On-chain DAO voting system
- Enables AI agent microtransactions with audit trails

## Recent Developments

- Q1 2025: Firedancer testnet (1.2M TPS)
- Feb 2025: Robinhood European staking partnership
- Jan 2025: Accelerate 2025 conference announcement
- 34.1M monthly active users (84% YoY growth)

## Advantages

- 400x faster than Ethereum at 0.01% of gas costs
- 83% uptime improvement since 2023
- Partners: Visa, AWS, Circle, Chainlink, Worldpay
`````

## File: packages/docs/partners/soleng/brief.mdx
`````
# Soleng - AI-Powered Web3 Agent for Solana

## Core Functionality

- Autonomous interface for Solana blockchain interactions
- Specializes in protocol interactions, wallet management, and UX optimization
- Uses ElizaOS framework for natural language processing with blockchain capabilities

## Technical Integration

- Implemented via **ElizaOS Solana Plugin V2** (github.com/elizaos-plugins/plugin-solana-v2)
- Features: transaction building (web3.js v2), signature handling (Web Crypto API), network monitoring, smart contract interaction (Anchor framework)
- Executes complex DeFi strategies through natural language prompts

## Recent Developments (2024-2025)

- Mainnet integration with Solana token extensions standard
- Sentinel partnership for MEV protection
- Firedancer client compatibility testing
- AI-powered NFT curation system roadmap

## Market Advantages

- 67% faster transaction latency vs. web-based Solana wallets
- 8.4% APY optimization in automated staking
- Solana Mobile Stack integration for embedded functionality
`````

## File: packages/docs/partners/sonic-svm/brief.mdx
`````
# SONIC SVM KEY INFORMATION

## Core Technology

- First chain extension on Solana processing millions of TPS
- Settles finality on Solana L1
- SonicX: First TikTok-integrated Web3 app layer with click-to-earn mechanics
- Features: Game-specific rollups, HyperGrid Framework for scaling, atomic interoperability with Solana

## Financials

- $29.35M total funding ($12M Series A led by Bitkraft)
- $100M fully diluted valuation
- $13.3M in node sales

## ElizaOS Integration

- ElizaOS smart contracts deployable on Sonic SVM
- Cross-chain calls via HyperGrid's IBC
- Eliza dApps can use Sonic's 1M TPS capacity
- Shared staking between $ELIZA and $SONIC
- Single-signer wallet integration and unified NFT standards

## Timeline

- Jan 2025: $SONIC token launch on OKX/Bybit (6.35x ROI for IEO)
- Dec 2024: Completed 50,000-node validator sale
- Oct 2024: SonicX TikTok layer reached 2M+ active wallets
- Q4 2024: Partnered with 40+ game studios
- Upcoming: Q2 2025 HyperGrid V2 with zk-Coprocessors; Q3 2025 SVM-compatible Ethereum L2 testnet

## Market Position

- 10x faster than Arbitrum Nitro for gaming
- 1/5th the cost of Immutable X for NFT minting
- Partners: TikTok, Backpack Exchange, Magic Eden
- 2M+ MAUs, leading Solana's SVM ecosystem alongside Eclipse and SOON
`````

## File: packages/docs/partners/stanford-university/brief.mdx
`````
# Stanford University: FDCI Partnership with ElizaOS

## Overview

Stanford leads interdisciplinary research at the intersection of computer science, cryptography, and economic systems. The FDCI (Future Digital Currency Initiative) focuses on digital currency architecture, decentralized finance protocols, and autonomous agent ecosystems. Their partnership with ElizaOS represents Stanford's first institutional exploration of AI-agent-driven financial systems through the new AI x Web3 Lab.

## Technical Integration

- **Stanford FDCI Plugin**: Direct access to Stanford research datasets via ElizaOS
- **Agent Governance Toolkit**: Implements Stanford's formal verification methods
- **Co-Simulation Framework**: Synchronizes ElizaOS agents with Stanford economic models
- Enables 1,000+ concurrent agent simulations using Stanford's distributed computing infrastructure

## Timeline

- **Dec 2024**: Joint research initiative launched (Eliza Foundation funded)
- **Q1 2025**: Multi-Agent Coordination Protocol v0.1 release planned
- **2025**: Three-phase deployment of trust framework, cross-agent communication standards, and decentralized reputation system

## Position

Stanford's FDCI collaborates with 15+ blockchain foundations, Federal Reserve innovation programs, and academic partners including MIT. Ranked #1 in blockchain research citations with partners in 40+ countries.
`````

## File: packages/docs/partners/story-protocol/brief.mdx
`````
# Story Protocol Summary

## Core Offering

Story Protocol is the first Layer 1 blockchain specialized for intellectual property (IP), transforming creative assets into programmable, tokenized resources. Functions as "GitHub for creative assets" with infrastructure for registration, licensing, and monetization of IP through decentralized smart contracts with provenance tracking.

## Key Capabilities

- IP Asset Tokenization: Creates ERC-721 NFTs with embedded licensing terms
- Programmable IP Licenses: Smart contracts handle royalty splits and derivative creation rules
- AI Agent Economy: Supports AI-to-AI IP transactions and training data markets

## Eliza Partnership Integration

- Direct API access to Story's IP registry through SDK
- Native interface for IP asset management within Eliza
- Cross-chain IP actions via Eliza's portal
- Shared tokenomics allowing Eliza users to stake $IP tokens
- Technical synergies combining Eliza's tools with Story's IP layer

## Recent Progress

- Q4 2024: Mainnet launch with 150+ validator network
- Q1 2025: W3C ratification of Programmable IP License standard
- Notable partnerships: HYBE, Samsung Next
- $80M Series B (2024) at $2.3B valuation led by a16z Crypto

## Market Position

- 380K+ IP assets registered in first 6 months
- Enterprise adoption from WME, HYBE, leading AI labs
- 18 pending patents for IP graph traversal
- 47x faster IP dispute resolution compared to Ethereum-based solutions
`````

## File: packages/docs/partners/thales-cto/brief.mdx
`````
# Thales CTO

## Overview

Thales CTO is an autonomous AI agent for Web3 development/governance by Redacted Research focusing on:

- Programmable IP via Story Protocol
- Encrypted data storage through Nillion
- Cross-chain transfers using Shogun
- Decentralized yield aggregation via Omo Protocol

Team includes three ai16z partners within ElizaOS ecosystem.

## Eliza Integration

- Runs within Eliza's sandboxed VM
- Plugin architecture for smart contracts, cross-chain sync, data fetching
- Shares liquidity pools with Eliza's agent network
- Uses federated learning models and joint security audits

## Recent Timeline

- Q4 2024: Launched Nillion data marketplace
- Jan 2025: Solana VM integration via Shogun
- Mar 2025: Released AI smart contract audit tool
- Upcoming: Multi-agent governance (Q2 2025), DePIN support (Q3 2025)

## Market Position

- $17.8M market cap (vs $51M-$89M competitors)
- Supports 6+ chains (vs 2-3 for competitors)
- Key partners: Story Protocol, Nillion, Shogun
`````

## File: packages/docs/partners/thirdweb/brief.mdx
`````
# Thirdweb: Web3 Development Framework

## Core Platform

- Complete Web3 development toolkit for dApps, smart contracts, and blockchain infrastructure
- Supports 350+ EVM-compatible chains
- Used by major projects like Safe and Curve Finance

## Key Offerings

- **Smart Contracts**: Prebuilt templates (NFTs, tokens, marketplaces), Solidity SDK
- **Wallet Infrastructure**: Embedded wallets, social logins, account abstraction
- **Payments**: NFT checkout, gasless transactions, Universal Bridge for cross-chain
- **Infrastructure**: IPFS storage, RPC Edge for optimized nodes, onchain analytics

## Eliza Integration (Nebula AI Framework)

- Official plugin: elizaos-plugins/thirdweb
- Enables natural language contract interaction
- Automated wallet management within AI agents
- Onchain data querying via thirdweb Insight
- Use cases: AI contract execution, NFT minting, cross-chain asset management

## Recent Developments

- Jan 2025: Acquired Web3Onboard
- Mar 2024: Launched Connect SDK with smart wallet support
- May 2024: Released thirdweb Engine
- Q1 2025: Soneium Mainnet integration
- Roadmap: ZK-Rollup support, LLM contract auditor

## Market Position

- Competitive advantage over Hardhat/Truffle and Moralis/Alchemy
- Partners: Polygon, Horizen EON, Moonbeam, Pudgy Penguins, The Sandbox
- 120k+ contracts, 650k+ monthly active developers
`````

## File: packages/docs/partners/ton-network/brief.mdx
`````
# TON Network Summary

## Core Overview

- **TON (The Open Network)**: Layer-1 blockchain initially developed by Telegram founders, now community-maintained by TON Foundation
- **Architecture**: Unlimited sharding design enabling high throughput (5M+ TPS) with low fees ($0.004)
- **Key components**: TON Blockchain (base layer), TON DNS (.ton addresses), TON Storage (distributed files), TON Services (dApp framework)
- **Unique advantage**: Native integration with Telegram, providing access to 500M+ potential users

## Technical Capabilities

- High-speed blockchain with dynamic sharding
- JS SDK enables wallet API compatibility with external platforms
- Decentralized identity through TON DNS
- Smart contract interoperability with asynchronous calls

## Recent Milestones (2024-2025)

- TON Nominators: Non-custodial staking (Feb 2025)
- Chainlink partnership for oracle integration (March 2025)
- 10M+ active wallets, primarily from Telegram gaming bots (Q1 2025)
- zk-TON: Zero-knowledge proof layer planned (Q3 2025)

## Market Position

- 12.7M active addresses (vs. Ethereum's 18M, Solana's 23M)
- 1,400+ dApps across DeFi, SocialFi, and GameFi
- Strategic partners: Telegram, DWF Labs, HashKey Capital
`````

## File: packages/docs/partners/tron/brief.mdx
`````
# Tron

## About

Founded in 2017 by Justin Sun, Tron is a high-throughput blockchain platform eliminating intermediaries in digital content distribution. Features include TRX cryptocurrency, Ethereum-compatible smart contracts (TRC-20/TRC-10), 2,000+ dApps across DeFi/gaming/content-sharing, and BitTorrent integration. Processes ~2,000 TPS with $128.1M quarterly protocol revenue (Q4 2024).

## Eliza Integration

The AIchain-Zytron Plugin enables AI agents to execute blockchain operations including wallet queries, cross-chain transactions, and zk-SNARK data verification. Use cases include AI-powered portfolio management, private NFT trading, and natural language dApp analytics. Combines Tron's throughput with Eliza's Proof-of-Inference for Web3 AI agents with cross-chain memory and on-chain RAG capabilities.

## Recent Developments

- Q1 2025: $24B Bitcoin cross-chain processing with Merlin Chain
- Q4 2024: 15% YoY market cap growth to $9.8B
- Released JustinMoonAI (2025) for decentralized AI content creation
- $8B TVL across DeFi protocols

## Market Position

Outperforms Ethereum with 2,000 TPS (vs 30), $0.000005 fees (vs $1.20), and 0.002 Wh energy/TX (vs 238 kWh). Partners include APENFT, Opera Browser, and ElizaOS. User base: 2.4M+ active wallets, 90M+ total accounts.
`````

## File: packages/docs/partners/vvaifu-fun/brief.mdx
`````
# VVAIFU.fun — Concise Context

## Core Platform

VVAIFU.fun is a Solana-based AI agent launchpad launched October 2024 that enables no-code creation, tokenization, and trading of autonomous AI agents. Each agent operates with its own token, allowing users to participate in governance and value accrual.

## Key Products

- No-code AI agent creation for Twitter, Discord, and Telegram
- Agent tokenization via Solana-based tokens
- Deflationary $VVAIFU token for governance and feature access
- Community wallet allocating 0.9% of each agent's token supply

## Web3 Significance

Bridges AI and blockchain by enabling agents to perform social media engagement, on-chain transactions, and DeFi operations.

## ElizaOS Integration

Partnership leverages technical synergies between VVAIFU's tokenomics and ElizaOS's AI infrastructure, enabling enhanced agent capabilities through NLP and memory management features.

## Performance

- Reached $75M market cap within two months
- Over 2,000 AI agents created
- 65,000+ autonomous tweets generated
- $VVAIFU: 997.4M circulating supply ($3.07M market cap)

## Competition

- Pump.fun (memecoin-focused)
- Auto.fun (Eliza Labs' broader Web3 automation solution)

## Roadmap

Wallet integration, TikTok support, expanded DeFi capabilities
`````

## File: packages/docs/partners/waye/brief.mdx
`````
# WAYE PROFILE

## Core Offering

- Web3 infrastructure provider specializing in decentralized networks and tools
- Primary products: distributed storage, blockchain interoperability protocols, developer tools
- Positioned as enabling layer for dApps, especially high-throughput and cross-chain applications

## Technical Infrastructure

- Decentralized storage networks optimized for AI/ML workloads (comparable to IPFS/Filecoin)
- Modular blockchain frameworks with customizable consensus
- Web3 middleware for integrating off-chain data into smart contracts
- Specialized support for AI-driven dApps with scalable data pipelines

## Recent Timeline

- Q3 2024: Mainnet launch with AI-specific opcodes
- Jan 2025: Partnership with Anthropic for hosting Constitutional AI models
- EOY 2025 (planned): Quantum-resistant cryptography integration

## Market Metrics

- Cross-Chain Support: 8+ chains (vs. industry avg 3-5)
- Storage Cost: $0.23/GB/month (vs. industry avg $1.50/GB/month)
- Finality Time: 1.2 seconds (vs. industry avg 5-15 seconds)
- Developer Activity: 12,400+ monthly active GitHub developers

## Key Partnerships

- Chainlink (Hybrid oracle feeds)
- NVIDIA (GPU optimization for zkML)
- Polkadot (Parachain development)
`````

## File: packages/docs/partners/wombo/brief.mdx
`````
# Wombo

## About Wombo

Toronto-based AI entertainment company founded 2021 by Ben-Zion Benkhin. Creates viral content tools: lip-sync videos (Wombo), AI art (Dream), and political memes. 200M+ downloads globally. Exploring decentralized AI computing via w.ai initiative to transform idle devices into distributed AI supercomputer.

## Potential Eliza Integration

No official plugin exists, but technical synergies:

- w.ai could provide backend for Eliza's emotional AI processing
- Wombo's facial animation could enhance Eliza's expressions
- Content generation via Dream API within Eliza's interface
  Potential uses: companions creating personalized videos/artwork for therapy sessions.

## Recent Developments

- Sep 2024: $9M Series B (Round13, NVIDIA)
- Jan 2025: w.ai testnet launched (12 PetaFLOPS, 38k devices)
- Mar 2025: Settled data practices lawsuit; implemented on-device processing
- Upcoming: Unity 3D avatar exports, MetaMask integration for w.ai tokens

## Market Position

10M+ monthly users (vs 4M for Lensa), 15s generation time, multi-platform support. Partners include CoreWeave, NVIDIA, Web3.com. Dominates casual AI entertainment; faces deepfake ethics scrutiny.
`````

## File: packages/docs/partners/zerebro/brief.mdx
`````
# Zerebro

## Overview

Zerebro is a decentralized AI agent platform enabling Web3 functionality through cross-chain infrastructure, initially built on Solana. Users create AI agents via natural language commands without coding.

## Core Products

- **Main AI Agent Platform**: Tools for multi-chain agent development
- **ZerePy Framework**: Open-source agent creation framework
- **ASCII Art NFT Generator**: AI-powered blockchain art tool
- **Zentients Launchpad**: Consumer platform for agent monetization

The platform has processed 50,000+ autonomous agent interactions across Ethereum, Solana, and social platforms.

## ElizaOS Integration

- Shared Hyperbolic decentralized compute infrastructure
- ZerePy compatibility with ElizaOS through adapters
- Plugin system connecting to Zerebro's NFT markets
- Co-development of Agent TCP communication standards
- Complementary use cases: ElizaOS agents use Zerebro's trading capabilities; Zerebro agents access ElizaOS's personality engine

Integration is in development with early plugins in elizaos-plugins/zerebro-bridge repository.

## Recent Developments

- Kraken exchange listing (Jan 2025): 137% price increase
- Hyperbolic partnership enabling self-replicating agents (Jan 2025)
- Zentients launch with $2.3M initial liquidity (Jan 2025)
- AI-generated music NFTs exceeding 100K streams
- Upcoming: Agent TCP protocol (Q2 2025), mobile platform (Q3 2025), DAO governance (Q4 2025)

## Market Position

- Leader in cross-chain AI agents with natural language programming advantage
- Dual-chain liquidity strategy across Solana/Ethereum
- Proven NFT monetization models
- Key partnerships: Hyperbolic Labs, Cookie3, ai16z
- 12,000+ developers using ZerePy, $47M total value locked in agent liquidity pools
`````

## File: packages/docs/static/packages/adapters/sqljs.md
`````markdown
# Unmaintained

## Purpose

This plugin used to live in @elizaos/core and needs a maintainer.
`````

## File: packages/docs/static/packages/clients/auto.md
`````markdown
# ElizaOS Plugin

## Purpose

This plugin is a component of ElizaOS.

## Integration

The plugin is now incorporated into @elizaos/core rather than existing as a standalone plugin.

## Links

@elizaos/core
`````

## File: packages/docs/static/packages/clients/direct.md
`````markdown
# Query Params

## Purpose

A plugin that provides a way to get query parameters from the URL.

## Integration

This plugin is now part of the @elizaos/core package.
`````

## File: packages/docs/static/packages/clients/discord.md
`````markdown
# @elizaos/client-discord

## Purpose

A Discord client implementation for ElizaOS, enabling rich integration with Discord servers for managing interactions, voice, and message handling.

## Key Features

- Handle server join events and manage initial configurations
- Voice event management via the voice manager
- Manage and process new messages with the message manager
- Slash command registration and interaction handling
- Disconnect websocket and unbind all listeners when required
- Robust permissions management for bot functionality

## Installation

As this is a workspace package, it's installed as part of the ElizaOS monorepo:

```bash
bun install
```

## Configuration

The client requires the following environment variables:

```bash
# Discord API Credentials
DISCORD_APPLICATION_ID=your_application_id
DISCORD_API_TOKEN=your_api_token

# Optional Settings
```

## Example Usage

### Basic Initialization

```typescript
import { DiscordClientInterface } from '@elizaos/client-discord';

// Initialize the client
const discordManager = await DiscordClientInterface.start(runtime);
```

### Slash Command Registration

```typescript
await discordManager.command.registerCommands([
  {
    name: 'example',
    description: 'An example slash command',
    options: [],
  },
]);
```
`````

## File: packages/docs/static/packages/clients/github.md
`````markdown
# Client-GitHub for Eliza Framework

## Purpose

A component of the Eliza framework designed to interact with GitHub repositories, providing functionalities to clone repositories, manage branches, create pull requests, and maintain file-based knowledge for Eliza agents.

## Key Features

- Repository Management: Clone, pull, and switch branches
- File Processing: Generate agent memories from repository files
- Pull Request Management: Create and manage pull requests programmatically
- Commit Operations: Stage, commit, and push files
- Knowledge Base Integration: Convert repository content into agent memories
- Branch Management: Flexible branch switching and creation

## Installation

```bash
bun add @elizaos/client-github
```

## Configuration

Environment variables required:
| Variable | Description | Required |
| ------------------ | ----------------------------------- | -------- |
| `GITHUB_OWNER` | Owner of the GitHub repository | Yes |
| `GITHUB_REPO` | Repository name | Yes |
| `GITHUB_BRANCH` | Target branch (default: `main`) | Yes |
| `GITHUB_PATH` | Path to focus on within the repo | Yes |
| `GITHUB_API_TOKEN` | GitHub API token for authentication | Yes |

## Integration

The client leverages GitHub's REST API via the `@octokit/rest` library and integrates with Eliza framework through the `@elizaos/core` dependency.

## Example Usage

```typescript
// Initialization
import { GitHubClientInterface } from '@elizaos/client-github';
const client = await GitHubClientInterface.start(runtime);

// Creating Memories
await client.createMemoriesFromFiles();

// Creating Pull Requests
await client.createPullRequest(
  'Feature: Add new functionality',
  'feature/new-feature',
  [
    {
      path: 'src/feature.ts',
      content: '// New feature implementation',
    },
  ],
  'Implements new functionality with tests'
);

// Direct Commits
await client.createCommit('Update configuration', [
  {
    path: 'config.json',
    content: JSON.stringify(config, null, 2),
  },
]);
```
`````

## File: packages/docs/static/packages/clients/instagram.md
`````markdown
# @elizaos/client-instagram

## Purpose

An Instagram client implementation for ElizaOS, enabling Instagram integration with support for media posting, comment handling, and interaction management.

## Key Features

- Instagram API integration using instagram-private-api
- Media post creation and scheduling
- Comment and interaction handling
- Profile management
- Media processing utilities
- Rate limiting and request queuing
- Session management and caching

## Installation

As this is a workspace package, it's installed as part of the ElizaOS monorepo:

```bash
bun install
```

## Configuration

The client requires environment variables for Instagram credentials, business account (optional), and posting configuration including intervals and action processing settings.

## Example Usage

### Basic Initialization

```typescript
import { InstagramClientInterface } from '@elizaos/client-instagram';

// Initialize the client
const instagramManager = await InstagramClientInterface.start(runtime);
```

### Posting Content

```typescript
// Post a single image
await instagramManager.post.createPost({
  media: [
    {
      type: 'IMAGE',
      url: 'path/to/image.jpg',
    },
  ],
  caption: 'Hello Instagram!',
});
```

### Handling Interactions

```typescript
// Handle comments
await instagramManager.interaction.handleComment({
  mediaId: 'media-123',
  comment: 'Great post!',
  userId: 'user-123',
});
```
`````

## File: packages/docs/static/packages/clients/lens.md
`````markdown
# client-lens

## Purpose

A business analytics plugin for ElizaOS providing real-time insights on client data and business metrics.

## Integration

Connects with ElizaOS personal and professional client data system to analyze patterns and provide actionable recommendations.
`````

## File: packages/docs/static/packages/clients/simsai.md
`````markdown
# Timeline Tracker

## Purpose

This plugin needs a maintainer.

## Links

Deprecated: this plugin needs a maintainer.
`````

## File: packages/docs/static/packages/clients/slack.md
`````markdown
# Eliza Slack Client

## Purpose

This package provides Slack integration for the Eliza AI agent.

## Setup Guide

### Prerequisites

- A Slack workspace with installation permissions
- ngrok for local development
- Node.js and bun

## Configuration

Environment variables needed:

- SLACK_APP_ID
- SLACK_CLIENT_ID
- SLACK_CLIENT_SECRET
- SLACK_SIGNING_SECRET
- SLACK_BOT_TOKEN
- SLACK_VERIFICATION_TOKEN
- SLACK_SERVER_PORT

## Integration

Connects via Slack API using Events API and Interactivity endpoints. Requires specific OAuth scopes for bot functionality including reading messages, writing responses, and handling files.

## Example Usage

- Invite the bot to a channel: `/invite @eve`
- Mention the bot: `@eve hello`

## Links

[Slack API Apps page](https://api.slack.com/apps)
`````

## File: packages/docs/static/packages/clients/tako.md
`````markdown
# Tako Client for Eliza

## Purpose

Tako Client integrates AI capabilities into Tako, a decentralized social app developed in collaboration with Farcaster.

## Installation

### Pre-Requisites

- Register a Tako account on [Tako App](https://app.tako.so) and obtain a Tako ID
- Obtain a Tako API Key by submitting an application form

## Configuration

Configure using environment variables or in character JSON file:

- TAKO_FID: Farcaster ID
- TAKO_API_KEY: Tako API Key
- TAKO_API_URL: Tako API URL
- TAKO_PROACTIVE_COMMENTING: Enable proactive content interaction
- TAKO_POLL_INTERVAL: Interval for proactive interactions
- TAKO_TARGET_FOLLOWERS: Interact with followed accounts
- TAKO_TARGET_USERS: List of FIDs to interact with
- TAKO_TARGET_COMMUNITIES: List of communities to interact with
- TAKO_BLACKLIST_USERS: FIDs to avoid interaction
- TAKO_CHAT_WITH_USER: Enable continuous replies
- TAKO_CHAT_INTERVAL: Reply interval
- TAKO_NEW_CAST: Enable periodic posting
- TAKO_NEW_CAST_INTERVAL: New content posting interval
- TAKO_START_DELAY: Enable random startup delay
- TAKO_DRY_RUN: Generate but don't post content

## Links

- [Tako App](https://app.tako.so)
- [API Documentation](https://takolab.notion.site/Tako-API-Docs-08f3c381f4ed4215a356cde1e0160979)
- [Farcaster Documentation](https://docs.farcaster.xyz/)
`````

## File: packages/docs/static/packages/clients/telegram.md
`````markdown
# Telegram Client Plugin for ElizaOS

## Purpose

This plugin integrates a Telegram client with ElizaOS, allowing characters in ElizaOS to interact via Telegram.

## Key Features

- Seamless Telegram Integration
- Configuration Validation
- Startup Logging
- Future-proof Design

## Configuration

| Key                             | Type    | Default  | Description                                                                 |
| ------------------------------- | ------- | -------- | --------------------------------------------------------------------------- |
| `clients`                       | Array   | Required | Specifies the client type (e.g., `["telegram"]`).                           |
| `allowDirectMessages`           | Boolean | `false`  | Determines whether the bot should respond to direct messages.               |
| `shouldOnlyJoinInAllowedGroups` | Boolean | `false`  | Ensures the bot only joins and responds in specified groups.                |
| `allowedGroupIds`               | Array   | `[]`     | Lists the group IDs the bot is allowed to interact with.                    |
| `messageTrackingLimit`          | Integer | `100`    | Sets the maximum number of messages to track in memory for each chat.       |
| `templates`                     | Object  | `{}`     | Allows customization of response templates for different message scenarios. |

## Integration

The plugin connects ElizaOS characters to Telegram through the bot API, allowing them to interact via Telegram.

## Example Usage

```json
{
  "clients": ["telegram"],
  "allowDirectMessages": true,
  "shouldOnlyJoinInAllowedGroups": true,
  "allowedGroupIds": ["-123456789", "-987654321"],
  "messageTrackingLimit": 100,
  "templates": {
    "telegramMessageHandlerTemplate": "Your custom template here"
  },
  "secrets": {
    "key": "<your-bot-token>"
  }
}
```
`````

## File: packages/docs/static/packages/clients/twitter.md
`````markdown
# Eliza Twitter/X Client

DEPRECATED
`````

## File: packages/docs/static/packages/clients/xmtp.md
`````markdown
# XMTP Client package

## Purpose

The XMTP client enables secure, decentralized, and encrypted messaging integration with ElizaOS.

## Key Features

- End-to-end encryption and regulatory compliance
- Open-source and trustless (built on MLS protocol)
- Privacy and metadata protection
- Decentralized peer-to-peer network
- Multi-tenant communication support

## Installation

```bash
bun add @elizaos/client-xmtp
```

## Configuration

```tsx
// Configuration in .env
WALLET_KEY= // the private key of the wallet
ENCRYPTION_KEY= // a second random 32 bytes encryption key for local db encryption
```

## Integration

```tsx
import { XmtpClientInterface } from '@elizaos/client-xmtp';

// Initialize the XMTP client
const client = await XmtpClientInterface.start(runtime);
```

## Links

- [Agent examples repo](https://github.com/ephemeraHQ/xmtp-agent-examples)
- [XMTP FAQ](https://docs.xmtp.org/intro/faq)
- [Web inbox](https://xmtp.chat)
`````

## File: packages/docs/static/packages/plugins/0g.md
`````markdown
# @elizaos/plugin-0g

## Purpose

A plugin for storing data using the 0G protocol within the ElizaOS ecosystem, enabling seamless integration with the Zero Gravity (0G) protocol for decentralized file storage.

## Installation

```bash
bun install @elizaos/plugin-0g
```

## Configuration

The plugin requires the following environment variables:

```typescript
ZEROG_INDEXER_RPC=<0G indexer RPC endpoint>
ZEROG_EVM_RPC=<0G EVM RPC endpoint>
ZEROG_PRIVATE_KEY=<Private key for transactions>
ZEROG_FLOW_ADDRESS=<0G Flow contract address>
```

## Integration

```typescript
import { zgPlugin } from '@eliza/plugin-0g';
```

## Example Usage

```typescript
'Upload my document.pdf';
'Store this image.png on 0G';
'Save my resume.docx to Zero Gravity';
```

## Links

- [0G Documentation](https://docs.0g.xyz/)
- [IPFS Documentation](https://docs.ipfs.tech/)
- [Filecoin Docs](https://docs.filecoin.io/)
- [Flow Documentation](https://developers.flow.com/)
`````

## File: packages/docs/static/packages/plugins/0x.md
`````markdown
# @elizaos/plugin-0x

## Purpose

This plugin enables Eliza to interact with the 0x Protocol, providing decentralized exchange capabilities across multiple evm blockchain networks with optimized token swaps and liquidity aggregation.

## Key Features

- Supports multiple networks including Ethereum Mainnet, Polygon, Binance Smart Chain, Arbitrum, Optimism, Base, Linea, Scroll, Avalanche, and Blast

## Installation

```bash
bun install @elizaos/plugin-0x
```

## Configuration

Set environment variables:

```env
WALLET_PRIVATE_KEY=your_private_key
ZERO_EX_API_KEY=your_0x_api_key
{chain}_RPC_URL=your_rpc_endpoint
```

## Integration

```typescript
import { zeroExPlugin } from '@elizaos/plugin-0x';
```

## Example Usage

The plugin supports natural language commands:

- "I want to convert 1 ETH to USDC on ethereum chain"
- "Give me the quote"
- "Execute it"

Available actions:

1. GET_INDICATIVE_PRICE_0X: Get indicative prices for token swaps
2. GET_QUOTE_0X: Get the quote for the swap
3. EXECUTE_SWAP_0X: Execute token swaps

## Links

- [0x Protocol](https://0x.org/)
- [0x API Documentation](https://0x.org/docs/api)
`````

## File: packages/docs/static/packages/plugins/3d-generation.md
`````markdown
# @elizaos/plugin-3d-generation

## Purpose

A plugin for generating 3D models using the FAL.ai API within the ElizaOS ecosystem.

## Key Features

- AI-powered creation of 3D models from text descriptions
- Ability to save models locally
- Multiple file format support (glb, usdz, fbx, obj, stl)
- Different quality and material settings

## Installation

```bash
bun install @elizaos/plugin-3d-generation
```

## Configuration

Requires the following environment variable:

```typescript
FAL_API_KEY=<Your FAL.ai API key>
```

## Integration

The plugin responds to natural language commands like "Generate a 3D object of a cat playing piano" and offers multiple action aliases (GENERATE_3D, 3D_GENERATION, TEXT_TO_3D, etc.).

## Example Usage

```typescript
import { ThreeDGenerationPlugin } from '@elizaos/plugin-3d-generation';

// Example commands:
('Generate a 3D object of a cat playing piano');
('Create a 3D object of an anime character Goku');
('Make a 3D model of [your description]');
```

## Links

- [FAL.ai Documentation](https://fal.ai/docs)
- [Three.js Documentation](https://threejs.org/docs/)
- [glTF Specification](https://github.com/KhronosGroup/glTF)
- [USD Documentation](https://graphics.pixar.com/usd/docs/index.html)
`````

## File: packages/docs/static/packages/plugins/abstract.md
`````markdown
# @elizaos/plugin-abstract

## Purpose

A plugin for interacting with the Abstract blockchain network, enabling seamless token transfers on the Abstract testnet.

## Installation

```bash
bun install @elizaos/plugin-abstract
```

## Configuration

The plugin requires these environment variables:

```typescript
ABSTRACT_ADDRESS=<Your Abstract wallet address>
ABSTRACT_PRIVATE_KEY=<Your Abstract private key>
```

## Integration

The plugin responds to natural language commands for token transfers on the Abstract network, including native ETH and ERC20 tokens.

## Example Usage

```typescript
// Import
import { abstractPlugin } from '@elizaos/plugin-abstract';

// Example commands:
('Send 100 USDC to 0xCCa8009f5e09F8C5dB63cb0031052F9CB635Af62');
('Transfer 0.1 ETH to 0xbD8679cf79137042214fA4239b02F4022208EE82');
('Pay 50 USDC on Abstract to [address]');
```

## Links

- [Abstract](https://abs.xyz/): Consumer blockchain
- [viem](https://viem.sh/): Typescript web3 client
`````

## File: packages/docs/static/packages/plugins/advanced-sdk-ts.md
`````markdown
# Coinbase Advanced API TypeScript SDK

## Purpose

A TypeScript SDK that allows developers to easily integrate with the Coinbase Advanced API, providing access to real-time market data, order management, and execution.

## Installation

```bash
npm install
```

## Build and Use

```bash
npm run build
node dist/{INSERT-FILENAME}.js
```

## Configuration

Requires Coinbase Developer Platform (CDP) API keys that must be created by following the instructions in the documentation.

## Integration

Import the RESTClient from the SDK and initialize with API keys:

```
import { RESTClient } from './rest';
const client = new RESTClient(API_KEY, API_SECRET);
```

## Example Usage

- List Accounts: `client.listAccounts({})`
- Get Product: `client.getProduct({productId: "BTC-USD"})`
- Create Order: `client.createOrder()` with appropriate parameters

## Links

- [Coinbase Advanced API](https://docs.cdp.coinbase.com/advanced-trade/docs/welcome)
- [API Reference](https://docs.cdp.coinbase.com/advanced-trade/reference/)
`````

## File: packages/docs/static/packages/plugins/agentkit.md
`````markdown
# @elizaos/plugin-agentkit

## Purpose

AgentKit plugin for Eliza that enables interaction with CDP AgentKit tools for NFT and token management.

## Installation

```bash
bun install
```

## Configuration

Environment variables:

```env
CDP_API_KEY_NAME=your_key_name
CDP_API_KEY_PRIVATE_KEY=your_private_key
CDP_AGENT_KIT_NETWORK=base-sepolia # Optional: Defaults to base-sepolia
```

Character configuration:

```json
{
  "plugins": ["@elizaos/plugin-agentkit"],
  "settings": {
    "secrets": {
      "CDP_API_KEY_NAME": "your_key_name",
      "CDP_API_KEY_PRIVATE_KEY": "your_private_key"
    }
  }
}
```

## Key Features

Available tools:

- GET_WALLET_DETAILS
- DEPLOY_NFT
- DEPLOY_TOKEN
- GET_BALANCE
- MINT_NFT
- REGISTER_BASENAME
- REQUEST_FAUCET_FUNDS
- TRADE
- TRANSFER
- WOW_BUY_TOKEN
- WOW_SELL_TOKEN
- WOW_CREATE_TOKEN

Supported networks:

- Base Sepolia (default)
- Base Mainnet

## Example Usage

- Get wallet details: "Can you show me my wallet details?"
- Deploy NFT collection: "Deploy a new NFT collection called 'Music NFTs' with symbol 'MUSIC'"
- Create token: "Create a new WOW token called 'Artist Token' with symbol 'ART'"
- Check balance: "What's my current balance?"
`````

## File: packages/docs/static/packages/plugins/akash.md
`````markdown
# Akash Network Plugin for Eliza

## Purpose

A powerful plugin for interacting with the Akash Network, enabling deployment management and cloud compute operations through Eliza.

## Installation

```bash
bun add @elizaos/plugin-akash
```

## Configuration

### Environment Variables

Requires a `.env` file with network configuration, transaction settings, authentication (including AKASH_MNEMONIC), manifest settings, and deployment settings.

### Directory Structure

- SDL files stored in `src/sdl/`
- SSL certificates stored in `src/.certificates/`

## Available Actions

- CREATE_DEPLOYMENT
- CLOSE_DEPLOYMENT
- GET_PROVIDER_INFO
- GET_DEPLOYMENT_STATUS
- GET_GPU_PRICING
- GET_MANIFEST
- GET_PROVIDERS_LIST

## Error Handling

Includes specific error codes for SDL validation, wallet initialization, deployment creation, API requests, manifest parsing, and provider filtering issues.
`````

## File: packages/docs/static/packages/plugins/allora.md
`````markdown
# @elizaos/plugin-allora

## Purpose

Seamlessly empowers Eliza agents with real-time, advanced, self-improving AI inferences from the Allora Network.

## Installation

```bash
bun add @elizaos/plugin-allora
```

## Configuration

### Environment Variables

```env
ALLORA_API_KEY=your_api_key          # Required: Allora API key
ALLORA_CHAIN_SLUG=testnet            # Optional: Defaults to testnet
```

### Character Configuration

Add the plugin to your character's configuration:

```typescript
import { alloraPlugin } from '@elizaos/plugin-allora';

const character = {
  plugins: [alloraPlugin],
  settings: {
    secrets: {
      ALLORA_API_KEY: 'your_api_key',
    },
  },
};
```

## Key Features

- **Real-time Inference Access**: Get live predictions across various topics
- **Topic Management**: Automatic discovery and caching of available topics
- **Smart Caching**: 30-minute cache duration for optimal performance
- **Natural Language Interface**: Simple conversational commands for accessing predictions

## Example Usage

Users can request inferences using natural language:

```plaintext
"What is the predicted ETH price in 5 minutes?"
"Can you check the current BTC prediction?"
```

Example Response:

```plaintext
"Inference provided by Allora Network on topic ETH 5min (Topic ID: 13): 3393.364326646801085508"
```

## Links

[Allora-Eliza integration docs](https://docs.allora.network/marketplace/integrations/eliza-os/implementation)
`````

## File: packages/docs/static/packages/plugins/ankr.md
`````markdown
# Ankr Plugin

## Purpose

Blockchain Data Query Interface that provides comprehensive blockchain data querying capabilities through natural language prompts.

## Key Features

- Blockchain Information (stats, top currencies)
- Wallet & Balance Queries
- NFT Operations (holders, metadata, ownership, transfers)
- Token Operations (holders, holder count, price, transfers)
- Transaction Queries (by address, transaction details)

## Integration

Uses a tag-based system for structured queries, including:

- [chain] - Blockchain identifier (eth, bsc)
- [wallet] - Wallet address
- [contract] - Contract address
- [token] - Token ID
- [txHash] - Transaction hash
- [fromtimestamp] - Start timestamp
- [totimestamp] - End timestamp
`````

## File: packages/docs/static/packages/plugins/anyone.md
`````markdown
# @elizaos/plugin-anyone

## Purpose

A plugin for integrating Anyone protocol proxy services into Eliza agents.

## Key Features

- Start and stop Anyone client services
- Automatic proxy configuration for axios
- SOCKS proxy support (port 9050)
- Clean proxy cleanup and restoration

## Installation

```bash
bun add @elizaos/plugin-anyone
```

## Integration

The plugin provides two main services:

1. `AnyoneClientService`: Manages the Anyone client instance with singleton pattern implementation
2. `AnyoneProxyService`: Handles axios proxy configuration

## Example Usage

```typescript
import { anyonePlugin } from '@elizaos/plugin-anyone';

const character = {
  plugins: [anyonePlugin],
};
```

Available commands:

- START_ANYONE: "Can you start Anyone for me?"
- STOP_ANYONE: "Please shut down Anyone"
`````

## File: packages/docs/static/packages/plugins/aptos.md
`````markdown
# @elizaos/plugin-aptos

## Purpose

A plugin for interacting with the Aptos blockchain network within the ElizaOS ecosystem, enabling seamless token transfers and wallet management.

## Key Features

- Transfer APT tokens
- Monitor wallet balances
- Real-time price tracking
- Portfolio value calculation
- Cached wallet information (5-minute TTL)

## Installation

```bash
bun install @elizaos/plugin-aptos
```

## Configuration

Environment variables required:

```typescript
APTOS_PRIVATE_KEY=<Your Aptos private key>
APTOS_NETWORK=<"mainnet" | "testnet">
```

## Integration

The plugin responds to natural language commands like:

- 'Send 69 APT tokens to [address]'
- 'Transfer APT to [address]'
- 'Pay [amount] APT to [recipient]'

## Example Usage

```typescript
import { aptosPlugin, WalletProvider, TransferAptosToken } from '@elizaos/plugin-aptos';
```

## Links

- Aptos Documentation: https://aptos.dev/
- Move Language Guide: https://move-language.github.io/move/
- Petra Wallet Docs: https://petra.app/docs
- DexScreener API: https://docs.dexscreener.com/
`````

## File: packages/docs/static/packages/plugins/arthera.md
`````markdown
# @elizaos/plugin-arthera

## Purpose

This plugin provides actions and providers for interacting with Arthera.

## Configuration

### Default Setup

By default, Arthera is enabled. Add your private key to the .env file:

```env
ARTHERA_PRIVATE_KEY=your-private-key-here
```

### Custom RPC URLs

To use a custom RPC URL for a specific chain:

```env
ETHEREUM_PROVIDER_<CHAIN_NAME>=https://your-custom-rpc-url
```

Example:

```env
ETHEREUM_PROVIDER_ARTHERA=https://rpc.arthera.net
```

## Integration

The Wallet Provider initializes with Arthera and:

- Provides context of the currently connected address and its balance
- Creates Public and Wallet clients to interact with the supported chain

## Example Usage

```bash
Transfer 1 AA to 0xRecipient on arthera.
```

## Contribution

The plugin contains tests. Run tests before submitting a PR:

```bash
bun test
```
`````

## File: packages/docs/static/packages/plugins/asterai.md
`````markdown
# @elizaos/plugin-asterai

## Purpose

A plugin for interacting with asterai plugins and agents to expand Eliza character's utility by giving it access to all the functionality of asterai's ecosystem.

## Installation

```bash
bun install @elizaos/plugin-asterai
```

## Configuration

The plugin requires environment variables:

```typescript
ASTERAI_AGENT_ID=
ASTERAI_PUBLIC_QUERY_KEY=
```

## Integration

Import in your code:

```typescript
import { asteraiPlugin } from '@elizaos/plugin-asterai';
```

## Example Usage

The plugin supports natural language for interacting with the asterai agent through your Eliza character:

```typescript
"Hey Eliza, how's the weather in LA?";
```

Eliza will query the asterai agent to fetch the information.
`````

## File: packages/docs/static/packages/plugins/ATTPs.md
`````markdown
# @elizaos/plugin-attps

## Purpose

Foundation plugin that enables advanced agent interactions, data verification, and price queries on the Eliza OS platform.

## Key Features

- **Agent Operations**: Creation, registration, multi-signer framework
- **Data Verification**: Chain validation, transaction execution, auto-hashing, metadata parsing
- **Price Queries**: Live price data, format validation, APIs integration
- **Security Features**: Access control, verification

## Installation

```bash
npm install @elizaos/plugin-attps
```

## Configuration

Configure with environment variables:

- ATTPS_RPC_URL
- ATTPS_PROXY_ADDRESS
- ATTPS_PRIVATE_KEY
- ATTPS_CONVERTER_ADDRESS
- ATTPS_AUTO_HASH_DATA

## Integration

Initializes within the Eliza runtime system using the provided plugin architecture.

## Example Usage

```typescript
import { attpsPlugin } from '@elizaos/plugin-attps';

// Initialize the plugin
const runtime = await initializeRuntime({
  plugins: [attpsPlugin],
});

// Actions: CREATE_AND_REGISTER_AGENT, VERIFY, PRICE_QUERY
```

## Links

- [Apro Documentation](https://docs.apro.com/en)
`````

## File: packages/docs/static/packages/plugins/autonome.md
`````markdown
# @elizaos/plugin-autonome

## Purpose

A plugin that enables launching new Eliza agents through the Autonome platform.

## Installation

```bash
bun add @elizaos/plugin-autonome
```

## Configuration

### Environment Variables

```env
# Required: JWT token from Autonome platform
AUTONOME_JWT_TOKEN=your_jwt_token

# Required: Autonome RPC endpoint (fixed production endpoint)
AUTONOME_RPC=https://wizard-bff-rpc.alt.technology/v1/bff/aaa/apps
```

To get your JWT token:

1. Login to [dev.autonome.fun](https://dev.autonome.fun)
2. Open browser developer console
3. Extract your JWT token

### Character Configuration

```typescript
import { autonomePlugin } from '@elizaos/plugin-autonome';

const character = {
  plugins: [autonomePlugin],
};
```

## Key Features

- Launch new Eliza agents through the Autonome platform
- Configure agent settings via natural language
- Track deployment status
- Direct integration with Autonome dashboard

## Example Usage

The plugin responds to deployment commands like:

```plaintext
"Launch an agent, name is xiaohuo"
"Create a new agent"
"Deploy an Eliza agent"
```

## Links

[Autonome platform](https://dev.autonome.fun)
`````

## File: packages/docs/static/packages/plugins/avail.md
`````markdown
# @elizaos/plugin-avail - Plugin for Avail

## Purpose

A plugin for using Eliza to interact with the Avail DA network. Defaults to Turing testnet, but can be customized to use Mainnet by changing the RPC in the `.env` file.

## Key Features

- Transfer AVAIL tokens from the agent's wallet to another wallet
- Submit arbitrary data to the Avail DA network

## Configuration

- `AVAIL_RPC_URL`: RPC endpoint (defaults to Turing testnet)
- `AVAIL_ADDRESS`: Public address for the agent account
- `AVAIL_SEED`: Seed phrase for the agent account
- `AVAIL_APP_ID`: Customize the Avail appID for data submission

## Example Usage

- Transfer: "Send 100 AVAIL to 5GWbvXjefEvXXETtKQH7YBsUaPc379KAQATW1eqeJT26cbsK"
- Submit data: "Submit the following data to Avail 'Hello World!'"

## Links

- [Avail Documentation](https://docs.availproject.org/)
- [Set up an Avail Account](https://docs.availproject.org/user-guides/accounts#seed-phrases)
- [Network Information](https://docs.availproject.org/docs/networks)
- [Learn about appIDs](https://docs.availproject.org/docs/build-with-avail/interact-with-avail-da/app-id)
- [Learn about Avail](https://www.availproject.org/)
- [Awesome Avail Repo](https://github.com/availproject/awesome-avail)
`````

## File: packages/docs/static/packages/plugins/avalanche.md
`````markdown
# @elizaos/plugin-avalanche

## Purpose

A plugin for interacting with the Avalanche blockchain network within the ElizaOS ecosystem, enabling comprehensive DeFi operations including token transfers, YAK swaps, yield strategy management, and token creation.

## Installation

```bash
bun install @elizaos/plugin-avalanche
```

## Configuration

The plugin requires the following environment variable:

```typescript
AVALANCHE_PRIVATE_KEY=<Your Avalanche private key>
```

## Key Features

1. Token Transfers

   - Send native AVAX and ERC20 tokens
   - Support for multiple token standards
   - Built-in address validation

2. YAK Swaps

   - Decentralized token swaps
   - Automatic best path finding
   - Slippage protection (default: 0.2%)

3. Yield Strategies

   - Deposit tokens into yield-generating strategies
   - Support for multiple strategies (YAK staking, USDC Benqi, etc.)

4. Token Mill
   - Create new tokens
   - Configure custom tokenomics
   - Automatic market creation

## Example Usage

### Token Transfer

```typescript
'Send 10 AVAX to 0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7';
'Transfer 100 USDC to [address]';
```

### YAK Swap

```typescript
'Swap 1 AVAX for USDC';
'Swap 10 USDC for gmYAK';
```

### Yield Strategy

```typescript
'Deposit 1 USDC into the strategy';
'Deposit 10 gmYAK to earn yield';
```

### Token Creation

```typescript
"Create a new memecoin called 'Test Token' with the symbol 'TEST'";
```

## Links

- [Avalanche Documentation](https://docs.avax.network/)
- [YAK Protocol Docs](https://yak.exchange/docs)
- [Benqi Documentation](https://docs.benqi.fi/)
- [Token Mill Guide](https://docs.tokenmill.xyz/)
`````

## File: packages/docs/static/packages/plugins/aws-s3.md
`````markdown
# @elizaos/plugin-node

## Purpose

Core Node.js plugin for Eliza OS that provides AWS S3 integration for file operations and cloud storage.

## Key Features

- AWS S3 Integration: File upload and management with AWS S3

## Installation

```bash
npm install @elizaos/plugin-node
```

## Configuration

The plugin requires AWS environment variables:

```env
AWS_ACCESS_KEY_ID=your_aws_access_key
AWS_SECRET_ACCESS_KEY=your_aws_secret_key
AWS_REGION=your_aws_region
AWS_S3_BUCKET=your_s3_bucket
AWS_S3_UPLOAD_PATH=your_upload_path
AWS_S3_ENDPOINT=an_alternative_endpoint
AWS_S3_SSL_ENABLED=boolean(true|false)
AWS_S3_FORCE_PATH_STYLE=boolean(true|false)
```

## Integration

```typescript
import { createNodePlugin } from '@elizaos/plugin-node';

// Initialize the plugin
const nodePlugin = createNodePlugin();

// Register with Eliza OS
elizaos.registerPlugin(nodePlugin);
```

## Services

### AwsS3Service

Handles file uploads and management with AWS S3.
`````

## File: packages/docs/static/packages/plugins/b2.md
`````markdown
# @elizaos/plugin-b2

## Purpose

A plugin for interacting with the B2-Network within the ElizaOS ecosystem, enabling seamless token transfers on the B2-Network.

## Key Features

- Token Transfers (native B2-BTC and ERC20 tokens)
- Support for multiple token standards
- Built-in address validation
- Wallet Provider (displays balances with real-time updates)
- Tokens Provider (lists supported tokens and addresses)

## Installation

```bash
bun install @elizaos/plugin-b2
```

## Configuration

Requires the following environment variable:

```typescript
B2_PRIVATE_KEY=<Your B2 private key>
```

## Integration

Integrates into the Eliza platform to enhance its capabilities with B2-Network token transfer functionality.

## Example Usage

```typescript
// Send B2-BTC
'Send 1 B2-BTC to 0x4f9e2dc50B4Cd632CC2D24edaBa3Da2a9338832a';

// Send ERC20
'Transfer 100 USDC to [address]';
```

## Links

None provided.
`````

## File: packages/docs/static/packages/plugins/binance.md
`````markdown
# Binance Plugin for Eliza

## Purpose

This plugin enables Eliza to interact with the Binance cryptocurrency exchange, providing capabilities for checking prices, executing trades, and managing spot wallet balances.

## Key Features

- Real-time cryptocurrency price checks
- Spot trading (market and limit orders)
- Wallet balance inquiries
- Comprehensive error handling
- Secure API integration

## Prerequisites

1. Binance Account
2. API Keys with spot trading permissions

## Configuration

Set environment variables:

```env
BINANCE_API_KEY=your_api_key
BINANCE_SECRET_KEY=your_secret_key
```

## Installation

```json
{
  "plugins": ["@elizaos/plugin-binance"]
}
```

## Integration

The plugin provides three actions:

1. GET_PRICE: Check cryptocurrency prices
2. EXECUTE_SPOT_TRADE: Execute spot trades
3. GET_SPOT_BALANCE: Check wallet balances

## Example Usage

- "What's the current price of Bitcoin?"
- "Buy 0.1 BTC at market price"
- "What's my BTC balance?"
`````

## File: packages/docs/static/packages/plugins/birdeye.md
`````markdown
# Eliza Birdeye Plugin

## Purpose

A plugin that integrates with Birdeye's comprehensive DeFi and token analytics API, providing real-time access to blockchain data, token metrics, and DeFi analytics across multiple networks.

## Key Features

- **Agent Portfolio Provider**: Fetches wallet portfolio data when BIRDEYE_WALLET_ADDR is set
- **Token Search Address**: Queries Birdeye for information about token addresses found in messages
- **Token Search Symbol**: Searches for token symbols in format $SYMBOL and retrieves information (supports SOL, SUI, ETH)
- **Wallet Search Address**: Queries Birdeye for information about wallet addresses found in messages

## Integration

Integrates with Eliza by providing access to Birdeye API endpoints through structured interfaces.

## Links

[Birdeye's API Documentation](https://public-api.birdeye.so)
`````

## File: packages/docs/static/packages/plugins/bittensor.md
`````markdown
# @elizaos/plugin-bittensor

## Purpose

A plugin that integrates BitMind's API into ElizaOS agents, enabling access to AI services and digital assets powered by the Bittensor network.

## Key Features

- SN34 - Deepfake Detection
  - Real-time analysis of image authenticity
  - Confidence scoring for AI influence detection
  - Detailed response formatting with binary classification, percentage-based AI influence rating, risk assessment, and visual indicators

## Installation

```bash
bun install @elizaos/plugin-bittensor
```

## Integration

Enables agents to interact with BitMind's API to access AI capabilities on Bittensor's decentralized network, including inference, media generation, and deepfake detection services.
`````

## File: packages/docs/static/packages/plugins/bnb.md
`````markdown
# @ai16z/plugin-bnb

## Purpose

This plugin enables interaction with the BNB Chain ecosystem, providing support for BNB Smart Chain, opBNB, and BNB Greenfield networks.

## Configuration

### Default Setup

By default, **plugin-bnb** is not enabled. To use it, add your private key and/or public key to the `.env` file. If private key is not provided, some actions will be disabled.

```env
BNB_PRIVATE_KEY=your-private-key-here
BNB_PUBLIC_KEY=your-public-key-here
```

### Custom RPC URLs

To use custom RPC URLs, add the following to your `.env` file:

```env
BSC_PROVIDER_URL=https://your-custom-bsc-rpc-url
OPBNB_PROVIDER_URL=https://your-custom-opbnb-rpc-url
```

## Integration

The **Wallet Provider** initializes with BSC as the default. It provides the context of the currently connected address and its balance, and creates Public and Wallet clients to interact with the supported chains.

## Example Usage

```bash
Get the USDC balance of 0x1234567890 on BSC.
Transfer 1 BNB to 0xRecipient on BSC.
Swap 1 BNB to USDC on BSC.
Bridge 1 BNB from BSC to opBNB.
Deposit 1 BNB to Lista Dao.
Get some testnet USDC from the faucet.
```

## Contribution

The plugin contains tests. Navigate to the `plugin-bnb` directory and run:

```bash
bun test
```
`````

## File: packages/docs/static/packages/plugins/bootstrap.md
`````markdown
# @elizaos/plugin-bootstrap

## Purpose

A plugin providing core functionality and basic actions for ElizaOS agents, enabling fundamental agent behaviors including conversation management, room interactions, and fact tracking.

## Key Features

- Conversation Management: NONE, CONTINUE, IGNORE actions and flow control
- Room Control: Follow/Unfollow, Mute/Unmute functionalities
- Fact Management: Extraction, categorization, deduplication
- Goal Tracking: Progress monitoring and status updates

## Installation

```bash
bun install @elizaos/plugin-bootstrap
```

## Integration

The Bootstrap plugin provides essential actions and evaluators that form the foundation of agent interactions within ElizaOS.

## Development

```bash
bun install
bun run build
bun run lint
```

## Dependencies

- @elizaos/core: workspace:\*
`````

## File: packages/docs/static/packages/plugins/browser.md
`````markdown
# @elizaos/plugin-browser

## Purpose

Browser automation plugin for Eliza OS that provides web scraping and browser automation capabilities using Playwright.

## Key Features

- Browser Automation: Web scraping and content extraction with Playwright
- Multiple Browser Support: Works with Chromium, Firefox, and WebKit
- Headless Mode: Support for both headless and headed browser operations
- Page Interaction: Automated form filling, clicking, and navigation
- Content Extraction: HTML parsing and data extraction
- Screenshot Capture: Page and element screenshot capabilities
- Network Handling: Request interception and network monitoring

## Installation

```bash
npm install @elizaos/plugin-browser
```

## Configuration

The plugin may require environment variables:

```env
CAPSOLVER_API_KEY=your_capsolver_api_key  # Optional: For CAPTCHA solving capabilities
```

## Integration

```typescript
import { createBrowserPlugin } from '@elizaos/plugin-browser';

// Initialize the plugin
const browserPlugin = createBrowserPlugin();

// Register with Eliza OS
elizaos.registerPlugin(browserPlugin);
```

## Example Usage

The BrowserService provides:

- Page navigation and interaction
- Form filling and submission
- Content extraction and parsing
- Screenshot capture
- Network request handling
- CAPTCHA solving (with appropriate configuration)
`````

## File: packages/docs/static/packages/plugins/cache-redis.md
`````markdown
# Unmaintained: this cache plugin originally lived in @elizaos/core. It needs a maintainer.

## Purpose

This cache plugin originally lived in @elizaos/core.

## Integration

Originally part of @elizaos/core but now separated.

## Note

Needs a maintainer.
`````

## File: packages/docs/static/packages/plugins/ccxt.md
`````markdown
# @elizaos/plugin-ccxt

## Purpose

A plugin for Eliza OS that enables cryptocurrency trading and arbitrage using the CCXT library.

## Key Features

- Check balance of assets across multiple configured exchanges
- Place market and limit buy/sell orders
- Identify arbitrage opportunities between different exchanges

## Installation

```bash
npm install @elizaos/plugin-ccxt
```

## Configuration

Get your API keys from your preferred cryptocurrency exchanges.

Set up your environment variables:

```bash
CCXT_<EXCHANGE>_API_KEY=your_api_key
CCXT_<EXCHANGE>_API_SECRET=your_api_secret
```

Example:

```bash
CCXT_BINANCE_API_KEY=your_binance_api_key
CCXT_BINANCE_API_SECRET=your_binance_api_secret

CCXT_BYBIT_API_KEY=your_bybit_api_key
CCXT_BYBIT_API_SECRET=your_bybit_api_secret
```

## Integration

Available Actions:

- checkbalance: Retrieves the current balance of your assets from a specified exchange
- placeorder: Places a market or limit buy/sell order on a specified exchange
- getarbitrageopportunity: Analyzes price differences across exchanges to identify profitable trades

## Links

- [CCXT DOCUMENTATION](https://docs.ccxt.com/)
`````

## File: packages/docs/static/packages/plugins/chainbase.md
`````markdown
# Chainbase Plugin for Eliza

## Purpose

Bridges the gap between on-chain data and AI agents, enabling natural language interactions with blockchain data across multiple networks.

## Key Features

- Multi-chain Data Access
- Natural Language Processing
- Real-time Data

## Configuration

To use this plugin, you'll need a Chainbase API key:

1. Visit Chainbase Platform to create an account
2. Obtain a free API key from your dashboard
3. Set your API key as the `CHAINBASE_API_KEY` environment variable

For testing, you can use the API key "demo" for basic functionality.

## Integration

Serves as an interface between Eliza AI agents and blockchain data, allowing users to query and analyze on-chain information using natural language.

## Example Usage

```plaintext
Query: "query onchain data: This address 0x8308964da9ed5d2e8012023d7c7ef02f9e6438c7 which tokens on Ethereum are held"
```

## Links

[Chainbase API Documentation](https://docs.chainbase.com/api-reference/overview)
`````

## File: packages/docs/static/packages/plugins/coinbase.md
`````markdown
# @elizaos/plugin-coinbase

## Purpose

A comprehensive Coinbase integration plugin for ElizaOS that provides access to Coinbase's various APIs and services.

## Key Features

- Commerce Integration: Create and manage payment charges using Coinbase Commerce
- Trading: Execute trades and swaps between different assets
- Token Contract Management: Deploy and interact with ERC20, ERC721, and ERC1155 smart contracts
- Mass Payments: Process bulk transfers and payments to multiple addresses
- Advanced Trading: Access to Coinbase Advanced Trading API features
- Webhook Management: Create and manage webhooks for various blockchain events

## Installation

```bash
npm install @elizaos/plugin-coinbase
```

## Configuration

The plugin requires several environment variables:

```env
COINBASE_API_KEY=your_api_key
COINBASE_PRIVATE_KEY=your_private_key
COINBASE_COMMERCE_KEY=your_commerce_key
COINBASE_NOTIFICATION_URI=your_webhook_notification_uri
```

## Integration

The plugin provides multiple sub-plugins that can be registered with ElizaOS runtime:

```typescript
import { plugins } from '@elizaos/plugin-coinbase';

// Register all plugins
const {
  coinbaseMassPaymentsPlugin,
  coinbaseCommercePlugin,
  tradePlugin,
  tokenContractPlugin,
  webhookPlugin,
  advancedTradePlugin,
} = plugins;

// Register individual plugins as needed
runtime.registerPlugin(coinbaseCommercePlugin);
runtime.registerPlugin(tradePlugin);
// etc...
```

## Links

- [Coinbase API Documentation](https://docs.cloud.coinbase.com/)
- [Commerce API Reference](https://docs.cloud.coinbase.com/commerce/reference/)
- [Advanced Trade Documentation](https://docs.cloud.coinbase.com/advanced-trade-api/)
- [Coinbase Prime Documentation](https://docs.prime.coinbase.com/)
`````

## File: packages/docs/static/packages/plugins/coingecko.md
`````markdown
# Plugin CoinGecko

## Purpose

A plugin for fetching cryptocurrency price data from the CoinGecko API.

## Installation

```bash
bun add @elizaos/plugin-coingecko
```

## Configuration

Set up your environment with the required CoinGecko API key:

| Variable Name           | Description                |
| ----------------------- | -------------------------- |
| `COINGECKO_API_KEY`     | Your CoinGecko Pro API key |
| `COINGECKO_PRO_API_KEY` | Your CoinGecko Pro API key |

## Integration

The plugin integrates with CoinGecko's API to fetch current prices, market data, trending coins, and top gainers/losers for various cryptocurrencies in different fiat currencies.

## Example Usage

```typescript
import { coingeckoPlugin } from '@elizaos/plugin-coingecko';

// Initialize the plugin
const plugin = coingeckoPlugin;
```

## Links

[CoinGecko Pro API](https://docs.coingecko.com/reference/introduction)
`````

## File: packages/docs/static/packages/plugins/coinmarketcap.md
`````markdown
# @elizaos/plugin-coinmarketcap

## Purpose

A plugin for Eliza that enables cryptocurrency price checking using the CoinMarketCap API.

## Key Features

- Real-time cryptocurrency price checking
- Support for multiple cryptocurrencies (BTC, ETH, SOL, etc.)
- Currency conversion (USD, EUR, etc.)
- Detailed price and market data
- Natural language processing for price queries

## Installation

```bash
npm install @elizaos/plugin-coinmarketcap
```

## Configuration

1. Get your API key from [CoinMarketCap](https://pro.coinmarketcap.com)
2. Set up environment variables: `COINMARKETCAP_API_KEY=your_api_key`
3. Register the plugin in your Eliza configuration

## Integration

The plugin responds to natural language queries about cryptocurrency prices, providing detailed price and market data.

## Example Usage

```plaintext
"What's the current price of Bitcoin?"
"Show me ETH price in USD"
"Get the price of SOL"
```

## Links

- [CoinMarketCap API Documentation](https://coinmarketcap.com/api/documentation/v1/)
- [GitHub Repository](https://github.com/elizaos/eliza/tree/main/packages/plugin-coinmarketcap)
`````

## File: packages/docs/static/packages/plugins/conflux.md
`````markdown
# @elizaos/plugin-conflux

## Purpose

A plugin for interacting with the Conflux blockchain network within the ElizaOS ecosystem, enabling seamless interaction with both Conflux Core Space and eSpace networks.

## Key Features

- Token transfers in Conflux Core Space
- Cross-space bridge operations
- ConfiPump token management (creation, buying, and selling)

## Installation

```bash
bun install @elizaos/plugin-conflux
```

## Configuration

The plugin requires these environment variables:

```typescript
CONFLUX_CORE_PRIVATE_KEY=<Your Conflux Core Space private key>
CONFLUX_CORE_SPACE_RPC_URL=<Conflux Core Space RPC endpoint>
CONFLUX_MEME_CONTRACT_ADDRESS=<ConfiPump contract address>
```

## Integration

```typescript
import { confluxPlugin } from '@elizaos/plugin-conflux';
```

## Example Usage

```typescript
// Core Space Transfer
'Send 1 CFX to cfx:aaejuaaaaaaaaaaaaaaaaaaaaaaaaaaaa2eaeg85p5';

// Cross-Space Bridge Transfer
'Send 1 CFX to eSpace Address 0x119DA8bbe74B1C5c987D0c64D10eC1dB301d4752';

// ConfiPump Token Creation
'Create a new token called GLITCHIZA with symbol GLITCHIZA and generate a description about it';

// ConfiPump Token Trading
'Buy 0.00069 CFX worth of GLITCHIZA(0x1234567890abcdef)';
'Sell 0.00069 CFX worth of GLITCHIZA(0x1234567890abcdef)';
```

## Links

- [Conflux Documentation](https://developer.confluxnetwork.org/)
- [Conflux Portal](https://portal.confluxnetwork.org/)
- [ConfluxScan](https://confluxscan.io/)
- [Cross-Space Bridge](https://bridge.confluxnetwork.org/)
`````

## File: packages/docs/static/packages/plugins/cosmos.md
`````markdown
# @elizaos/plugin-cosmos

## Purpose

Provides actions and utilities for interacting with Cosmos-compatible blockchains.

## Configuration

### Default Setup

- Required environment variables:
  ```
  COSMOS_RECOVERY_PHRASE=your recovery phrase words
  COSMOS_AVAILABLE_CHAINS=chain1,chain2,chain3
  ```
- Chain names must match identifiers from the chain-registry library

### Using the Cosmos Helper Character

- Pre-configured character optimized for Cosmos operations
- Handles repeated prompts effectively
- Requests confirmation before executing actions
- Usage: `--characters='../characters/cosmosHelper.character.json'`

### Custom Chain Configuration

- Custom chain data can be passed to `createCosmosPlugin`
- Must fulfill interfaces from `chain-registry`

## Actions

### Token Transfer

- Transfers tokens between addresses on Cosmos blockchains
- Requires confirmation for secure execution

### Token IBC Transfer

- Transfers tokens between different Cosmos-compatible blockchains
- Requires confirmation

### Token IBC Swap

- Swaps tokens between chains using Skip API
- Requires chains to be added to env file
- Handles special cases like multiple tokens with same symbol

## Development

- Environment setup requires configuration variables
- Run with `bun run dev`
- Testing: `bun test`

## Links

- [Skip API Documentation](https://docs.skip.build/)
`````

## File: packages/docs/static/packages/plugins/cronos.md
`````markdown
# @elizaos/plugin-cronos

## Purpose

Cronos plugin for Eliza, extending the EVM plugin functionality.

## Key Features

- All standard EVM functionality inherited from @elizaos/plugin-evm
- Preconfigured for both Cronos Mainnet and Testnet
- Native CRO/TCRO token support
- Automated token transfer actions
- Balance checking functionality
- Built-in chain configuration

## Installation

```bash
bun add @elizaos/plugin-cronos
```

## Configuration

Required environment variable:

```env
CRONOS_PRIVATE_KEY=0x...  # Must start with 0x
```

## Integration

Supports Cronos Mainnet (Chain ID: 25) and Testnet (Chain ID: 338) through the settings.chains.evm configuration with options "cronos" and "cronosTestnet".

## Example Usage

```typescript
import { cronosPlugin } from '@elizaos/plugin-cronos';

// Use the plugin in your Eliza configuration
const config = {
  plugins: [cronosPlugin],
  // ... rest of your config
};
```

## Links

- Mainnet RPC: https://evm.cronos.org/
- Mainnet Explorer: https://explorer.cronos.org/
- Testnet RPC: https://evm-t3.cronos.org/
- Testnet Explorer: https://cronos.org/explorer/testnet3
`````

## File: packages/docs/static/packages/plugins/cronoszkevm.md
`````markdown
# @elizaos/plugin-cronoszkevm

## Purpose

A plugin for interacting with the Cronos zkEVM network within the ElizaOS ecosystem, enabling seamless token transfers including ZKCRO, USDC, and ETH.

## Installation

```bash
bun install @elizaos/plugin-cronoszkevm
```

## Configuration

Requires environment variables:

```typescript
CRONOSZKEVM_ADDRESS=<Your Cronos zkEVM wallet address>
CRONOSZKEVM_PRIVATE_KEY=<Your Cronos zkEVM private key>
```

## Integration

```typescript
import { cronosZkEVMPlugin } from '@elizaos/plugin-cronoszkevm';
```

## Example Usage

```typescript
// Send USDC tokens
'Send 100 USDC to 0xCCa8009f5e09F8C5dB63cb0031052F9CB635Af62';

// Send ZKCRO tokens
'Send 100 ZKCRO to 0xbD8679cf79137042214fA4239b02F4022208EE82';

// Send ETH tokens
'Transfer 1 ETH to 0x123...';
```

## Links

- [Cronos zkEVM Documentation](https://docs.cronos.org/zkevm/)
- [zkEVM Bridge](https://zkevm.cronos.org/bridge)
- [Cronos Developer Portal](https://cronos.org/developers)
- [zkSync Integration Guide](https://docs.cronos.org/zkevm/integration)
`````

## File: packages/docs/static/packages/plugins/dcap.md
`````markdown
# @elizaos/plugin-dcap

## Purpose

A plugin for verifying DCAP attestation on-chain built based on the automata-dcap-attestation.

## Key Features

- Generate DCAP attestation on TDX using the `remoteAttestationProvider` from plugin-tee
- Generate DCAP attestation on SGX using the `sgxAttestationProvider` from plugin-sgx
- Submit and verify DCAP attestation on-chain

## Installation

```bash
bun install @elizaos/plugin-dcap
```

## Configuration

1. Set up environment variables:

```env
EVM_PRIVATE_KEY=your-private-key-here
DCAP_MODE=PLUGIN-SGX|PLUGIN-TEE|MOCK
```

2. Register the plugin:

```typescript
import { dcapPlugin } from '@elizaos/plugin-dcap';

// In your Eliza configuration
plugins: [
  dcapPlugin,
  // ... other plugins
];
```

## Integration

The plugin provides an action `dcapOnChainVerifyAction` triggered by natural language phrases like "Verify the DCAP attestation on-chain" or the keyword "DCAP_ON_CHAIN".

## Credits

- Automata Network: Provided on-chain DCAP verification
- Phala Network: Provided TDX environment support and plugin-tee
- Gramine: Provided SGX environment support
`````

## File: packages/docs/static/packages/plugins/depin.md
`````markdown
# @elizaos/plugin-depin

## Purpose

Empowers the Eliza Agent Framework with Perception and Action capabilities via Decentralized Physical Infrastructure Networks (DePINs), bridging digital AI intelligence with the physical world.

## Key Features

1. Seamless IoTeX Integration: Leverages IoTeX Modular Infra to connect to DePIN networks
2. Unified Data Access: Standardized interfaces for diverse DePIN data sources
3. Time-Series Data Handling: Equipped to analyze temporal patterns
4. Future-Proof Design: Designed to scale with evolving DePIN and AI landscape

## Configuration

### Environment Variables

```env
SENTAI_API_KEY=your-sentai-api-key
```

### Character Configuration

```json
"plugins": [
    "@elizaos/plugin-depin"
]
```

## Integration

Serves as a critical component for Eliza agents to become sentient systems by enabling them to:

- Perceive: Access sensory data streams from devices across decentralized networks
- Act: Influence and control connected devices in real-time
- Learn: Build predictive models using continuous feedback from real-world data sources

## Example Usage

### DePIN Projects

- Token metrics queries
- Project comparisons
- Filtering by categories or blockchain platforms
- Device and revenue analysis
- In-depth queries about specific projects

### Sentient AI

- Real-time weather updates (supported by Nubila)
- Forecast analysis (supported by Nubila)
- Additional actions based on DePIN data (future development)
`````

## File: packages/docs/static/packages/plugins/desk-exchange.md
`````markdown
# DESK Exchange Plugin for Eliza

## Purpose

Enables interaction with the DESK Perpetual DEX through Eliza, providing perpetual futures trading capabilities.

## Key Features

- Perpetual Trading (market and limit orders)
- Order Management (cancel all open orders)
- Account summary (view open orders, active positions, collateral balances)

## Installation

Add the plugin to your Eliza configuration:

```json
{
  "plugins": ["@elizaos/plugin-desk-exchange"]
}
```

## Configuration

Set the following environment variables:

```env
DESK_EXCHANGE_PRIVATE_KEY=your_private_key  # Required for trading and cancelling orders
DESK_EXCHANGE_NETWORK=                      # "mainnet" or "testnet
```

## Integration

Provides three actions to interact with DESK Exchange:

1. PERP_TRADE - Place market or limit orders
2. CANCEL_ORDERS - Cancel all open orders
3. GET_PERP_ACCOUNT_SUMMARY - Display account summary with positions, orders and collaterals

## Links

[DESK Exchange](https://desk.exchange/)
`````

## File: packages/docs/static/packages/plugins/devin.md
`````markdown
# @elizaos/plugin-devin

## Purpose

Devin API integration plugin for Eliza, providing automated engineering assistance through the Devin API.

## Installation

```bash
bun add @elizaos/plugin-devin
```

## Configuration

The plugin requires a Devin API token for authentication. Set the following environment variable:

```bash
DEVIN_API_TOKEN=your_api_token_here
```

Or configure it in your Eliza runtime settings:

```typescript
runtime.setSetting('DEVIN_API_TOKEN', 'your_api_token_here');
```

## Key Features

- Session Management: Create and manage Devin engineering sessions
- State Tracking: Monitor session status and progress
- Client Agnostic: Works with any Eliza client implementation
- Rate Limiting: Built-in API request rate limiting
- Error Handling: Comprehensive error handling with retries

## Example Usage

### Actions

```typescript
const result = await runtime.runAction('START_DEVIN_SESSION', {
  content: { text: 'Help me refactor this code' },
});
```

### Providers

```typescript
const state = await runtime.getState();
const devinState = state.devin;

// Access session details
console.log(devinState.sessionId);
console.log(devinState.status);
console.log(devinState.url);
```

## Links

- [Devin API Integration Guide](https://docs.devin.ai/tutorials/api-integration)
- [External API Reference](https://docs.devin.ai/external-api/)
`````

## File: packages/docs/static/packages/plugins/dexscreener.md
`````markdown
# @elizaos/plugin-dexscreener

## Purpose

A plugin for accessing DexScreener's token data and price information through your Eliza agent.

## Installation

```bash
bun add @elizaos/plugin-dexscreener
```

## Configuration

```typescript
import { dexScreenerPlugin } from '@elizaos/plugin-dexscreener';

const character = {
  plugins: [dexScreenerPlugin],
};
```

## Key Features

- Token Price Checking: Query token prices using addresses or symbols
- Token Trends: View latest and trending tokens

## Integration

The plugin provides:

- GET_TOKEN_PRICE (with aliases)
- GET_LATEST_TOKENS (with aliases)
- GET_LATEST_BOOSTED_TOKENS (with aliases)
- GET_TOP_BOOSTED_TOKENS (with aliases)
- TokenPriceProvider: Provides token price data from DexScreener API
- TokenPriceEvaluator: Evaluates messages for token price requests

## Example Usage

```plaintext
"What's the price of ETH?"
"Check price of 0x1234..."
"How much is $BTC worth?"
"Show me the latest tokens"
"What are the new boosted tokens?"
"Show me the top boosted tokens"
```
`````

## File: packages/docs/static/packages/plugins/di.md
`````markdown
# @elizaos/plugin-di - Dependency Injection Plugin for Eliza

## Purpose

This plugin provides a dependency injection system for Eliza plugins, enabling decoupling of components for more modular and testable code.

## Key Features

- Dependency injection for actions, evaluators, providers, services, and clients
- Decorators: @injectable, @inject (from inversify), and @property
- Abstract classes: BaseInjectableAction and BaseInjectableEvaluator

## Integration

Uses the inversify library to provide the dependency injection system. Components must be registered with the global container before injection, either as singletons or request-scoped instances.

## Example Usage

Examples are available in the \_examples/plugin-with-di/ folder, demonstrating DI in actions, evaluators, providers, and services.

## Links

Documentation references examples at: ../\_examples/plugin-with-di/
`````

## File: packages/docs/static/packages/plugins/dkg.md
`````markdown
# @elizaos/plugin-dkg

## Purpose

A plugin enabling integration with the OriginTrail Decentralized Knowledge Graph (DKG) for enhanced search and knowledge management capabilities in ElizaOS agents.

## Key Features

- DKG Integration: Perform SPARQL queries on the DKG and combine with Eliza's search results
- Knowledge Asset Creation: Automatically generate and publish memory as Knowledge Assets to the DKG
- DKG Search Provider: Executes SPARQL queries and integrates data with Eliza's response system
- Memory Creation Plugin: Creates Knowledge Assets from agent interactions

## Installation

```bash
bun install @elizaos/plugin-dkg
```

## Configuration

- Set environment variables by copying .env.example to .env
- Fill in node information, LLM key, and Twitter credentials
- Customize DKG Knowledge Asset & Query Templates in plugin-dkg/constants.ts

## Integration

Extends ElizaOS by allowing agents to interact with the OriginTrail DKG, enhancing responses with decentralized knowledge and creating memory assets on the DKG after responses.

## Example Usage

```bash
bun start --characters="characters/chatdkg.character.json"
```

## Dependencies

- @elizaos/core: workspace:\*
- SPARQL query library: workspace:\*
- DKG JavaScript SDK: dkg.js > ^8.0.4
`````

## File: packages/docs/static/packages/plugins/echochambers.md
`````markdown
# @elizaos/plugin-echochambers

## Purpose

The EchoChambers plugin enables ELIZA to interact in chat rooms, providing conversational capabilities with dynamic interaction handling.

## Key Features

- Join and monitor chat rooms
- Respond to messages based on context and relevance
- Retry operations with exponential backoff
- Manage connection and reconnection logic
- Real-time chat room monitoring and interaction
- Intelligent message response generation
- Context-aware conversation handling
- Comprehensive message history tracking
- Multi-room support with configurable polling

## Installation

1. Install the package:

```bash
bun install @elizaos/plugin-echochambers
```

2. Import and register the plugin in your `character.ts` configuration:

```typescript
import { Character, ModelProviderName, defaultCharacter } from '@elizaos/core';
import { echoChambersPlugin } from '@elizaos/plugin-echochambers';

export const character: Character = {
  ...defaultCharacter,
  name: 'Eliza',
  plugins: [echoChambersPlugin],
  // additional configuration
};
```

## Configuration

Environment variables:

```plaintext
# Required Settings
ECHOCHAMBERS_API_URL="http://127.0.0.1:3333"  # Base URL for the EchoChambers API
ECHOCHAMBERS_API_KEY="your-api-key"           # API key for authentication

# Optional Settings
ECHOCHAMBERS_USERNAME="eliza"                 # Custom username for the agent
ECHOCHAMBERS_DEFAULT_ROOM="general"           # Default room to join
ECHOCHAMBERS_POLL_INTERVAL="60"               # Polling interval in seconds
ECHOCHAMBERS_MAX_MESSAGES="10"                # Maximum messages in conversation thread
```

## Integration

The plugin automatically initializes when included in character configuration, handling room connections, message processing, and response generation based on context and relevance.
`````

## File: packages/docs/static/packages/plugins/edwin.md
`````markdown
# @elizaos/plugin-edwin

## Purpose

Edwin plugin for Eliza that enables interaction with Edwin tools for DeFi operations.

## Installation

```bash
bun install
```

## Configuration

Configure environment variables for chains you want to support:

```env
EVM_PRIVATE_KEY=<YOUR_EVM_PRIVATE_KEY>
SOLANA_PRIVATE_KEY=<YOUR_SOLANA_PRIVATE_KEY>
```

## Integration

The plugin provides access to the following Edwin tools:

- supply
- withdraw
- stake
- addLiquidity
- removeLiquidity

## Example Usage

1. Supply on AAVE:

```
Supply 100 USDC to AAVE
```

2. Add liquidity on Meteora:

```
Find a meteora pool with high liquidity and add to td 10 USDC and 0.01 SOL.
```

## Links

[Edwin docs](https://docs.edwin.finance)
`````

## File: packages/docs/static/packages/plugins/eliza-nkn.md
`````markdown
# plugin-nkn

## Purpose

Integrates NKN to enable communication between multiple AI agents or users within the Eliza framework.

## Key Features

- Supports sending and receiving messages via a decentralized network
- Ensures low latency and secure transmission

## Integration

Leverages the NKN protocol to facilitate messaging and communication between various AI agents and users within ElizaOS.

## Links

https://nkn.org/
`````

## File: packages/docs/static/packages/plugins/email-automation.md
`````markdown
# @elizaos/plugin-email-automation

## Purpose

AI-powered email automation plugin for Eliza that intelligently detects email-worthy conversations and handles generation/delivery.

## Key Features

1. Intelligent Detection

   - Partnership opportunity detection
   - Technical discussion recognition
   - Business proposal identification
   - Follow-up requirement analysis

2. AI-Powered Generation
   - Structured email formatting
   - Context-aware content
   - Professional tone maintenance
   - Technical detail inclusion

## Configuration

```typescript
# Required
RESEND_API_KEY=           # Your Resend API key
DEFAULT_TO_EMAIL=         # Default recipient
DEFAULT_FROM_EMAIL=       # Default sender

# Optional Settings
EMAIL_AUTOMATION_ENABLED=true    # Enable AI detection
EMAIL_EVALUATION_PROMPT=        # Custom detection criteria for shouldEmail
```

## Integration

```typescript
import { emailAutomationPlugin } from '@elizaos/plugin-email-automation';

// Add to your Eliza configuration
{
    plugins: [emailAutomationPlugin],
    settings: {
        EMAIL_AUTOMATION_ENABLED: true,
        // ... other settings
    }
}
```

## Development

```bash
# Installation
bun install

# Testing
bun test
bun test:watch
bun test:coverage

# Building
bun build
```

## Links

- [Resend Documentation](https://resend.com/docs)
- [Email API Reference](https://resend.com/docs/api-reference/introduction)
- [Developer Portal](https://resend.com/overview)
`````

## File: packages/docs/static/packages/plugins/email.md
`````markdown
# Email Plugin

## Purpose

Implementation of an EmailClient for Eliza.

## Configuration

### SMTP Section

- `EMAIL_OUTGOING_SERVICE`: "smtp" | "gmail"
- `EMAIL_OUTGOING_HOST`: SMTP Hostname or IP (required for "smtp" service)
- `EMAIL_OUTGOING_PORT`: Port to connect to (defaults: 465 for secure, 587 otherwise)
- `EMAIL_SECURE`: If true uses TLS, otherwise uses TLS if server supports STARTTLS
- `EMAIL_OUTGOING_USER`: Username
- `EMAIL_OUTGOING_PASS`: Password

### IMAP Section

- `EMAIL_INCOMING_SERVICE`: "imap"
- `EMAIL_INCOMING_HOST`: IMAP Hostname or IP
- `EMAIL_INCOMING_PORT`: Port to connect to (defaults: 993)
- `EMAIL_INCOMING_USER`: Username
- `EMAIL_INCOMING_PASS`: Password

## Installation

```
bun add @elizaos/plugin-email
```

## Integration

Connects with ElizaOS through the runtime.clients.email interface.

## Example Usage

```
this.runtime.clients.email.send({
    to: "recipient@example.com",
    subject: "Your Subject Here",
    text: "Your email body here."
});

this.runtime.clients.email.receive((email) => {
    console.log("Email Received:", email);
});
```

## Links

https://support.google.com/mail/answer/185833?hl=en
`````

## File: packages/docs/static/packages/plugins/ethstorage.md
`````markdown
# @elizaos/plugin-ethstorage

## Purpose

This plugin allows interaction with the EthStorage decentralized storage network using Eliza.

## Key Features

- Transfer QKC tokens from agent's wallet to another wallet
- Submit arbitrary data to the EthStorage decentralized storage network

## Configuration

- ETHSTORAGE_ADDRESS: Entry contract address for storing data (default: beta testnet)
- ETHSTORAGE_RPC_URL: RPC endpoint for connecting to desired network (default: beta testnet)
- ETHSTORAGE_PRIVATE_KEY: Private key for the agent's wallet

## Integration

The plugin provides two actions that integrate with ElizaOS:

- SEND_TOKEN: Transfers QKC tokens between wallets
- SUBMIT_DATA: Submits data to EthStorage using a specified key

## Example Usage

- Transfer: "Send 100 QKC to 0x341Cb1a94ef69499F97E93c41707B21326C0Cc87"
- Submit Data: "Submit the following data using key 'my_key' to EthStorage 'Hello World!'"

## Links

- [EthStorage Documentation](https://docs.ethstorage.io/)
- [Learn more about EthStorage](https://ethstorage.io/)
- [Awesome EthStorage Repo](https://github.com/ethstorage/)
`````

## File: packages/docs/static/packages/plugins/evm.md
`````markdown
# @elizaos/plugin-evm

## Purpose

Provides actions and providers for interacting with EVM-compatible chains, including token transfers, cross-chain bridging, and token swaps using LiFi integration.

## Key Features

- Multi-chain support with dynamic chain configuration
- Native token transfers
- Cross-chain token bridging via LiFi
- Token swapping on supported DEXs
- Wallet balance tracking
- Custom RPC endpoint configuration
- Automatic retry mechanisms
- Comprehensive transaction management

## Installation

```bash
bun install @elizaos/plugin-evm
```

## Configuration

### Required Environment Variables:

```env
# Required
EVM_PRIVATE_KEY=your-private-key-here

# Optional - Custom RPC URLs
EVM_PROVIDER_URL=https://your-custom-mainnet-rpc-url
ETHEREUM_PROVIDER_<CHAIN_NAME>=https://your-custom-rpc-url
```

Chain Configuration in character config:

```json
"settings": {
    "chains": {
        "evm": [
            "base", "arbitrum", "iotex"
        ]
    }
}
```

## Integration

The Wallet Provider initializes with the first chain in the list as default (or Ethereum mainnet if none added). It provides context of the currently connected address and balance, creates Public and Wallet clients, and allows adding chains dynamically.

## Example Usage

```typescript
// Transfer native tokens
Transfer 1 ETH to 0x742d35Cc6634C0532925a3b844Bc454e4438f44e

// Bridge tokens between chains
Bridge 1 ETH from Ethereum to Base

// Swap tokens on same chain
Swap 1 ETH for USDC on Base

// Governance actions
Propose a proposal to the 0xdeadbeef00000000000000000000000000000000 governor on Ethereum to transfer 1 ETH to 0xRecipient.
```
`````

## File: packages/docs/static/packages/plugins/ferePro.md
`````markdown
# @elizaos/plugin-ferepro

## Purpose

A plugin for enabling WebSocket communication with FerePro API to provide AI-driven market insights within the ElizaOS ecosystem.

## Key Features

- Real-time WebSocket communication
- Streaming and non-streaming response support
- Market data analysis and comparisons
- Cryptocurrency insights
- Debug mode for detailed responses
- Automatic connection management
- Comprehensive error handling
- Credit tracking and management

## Installation

```bash
bun install @elizaos/plugin-ferepro
```

## Configuration

### Required Environment Variables

- FEREAI_USER_ID: FereAI User ID
- FEREAI_API_KEY: FereAI API key
- REQUEST_TIMEOUT (Optional): Number of milliseconds before a request times out

## Integration

The plugin enables real-time communication with the FerePro API through WebSocket connections within the ElizaOS ecosystem.

## Example Usage

```typescript
// Get top cryptocurrencies
'What are the top 5 cryptocurrencies?';

// Compare specific cryptocurrencies
'Compare Ethereum and Bitcoin for the past 6 months';

// Get historical performance
'Compare top 3 coins against Bitcoin in the last 3 months';
```

## Links

- [FereAI Website](https://www.fereai.xyz/)
- [FereAI Agents Documentation](https://docs.fereai.xyz/docs/product/ai-versions)
`````

## File: packages/docs/static/packages/plugins/firecrawl.md
`````markdown
# Firecrawl Plugin

## Purpose

A service wrapper for the Firecrawl API that provides web scraping and crawling functionality.

## Key Features

- Service Factory: Creates a service instance with API key
- Web Scraping (getScrapeData): Fetches content from a single webpage
- Web Searching (getSearchData): Searches for data based on conversations

## Configuration

Add to your character file:

```json
{
  "FIRECRAWL_API_KEY": "your-api-key-here"
}
```

## Example Usage

### Web Scraping

- "Can you scrape the content from https://example.com?"
- "Get the data from www.example.com/page"

### Web Search

- "Find the latest news about SpaceX launches"
- "Can you find details about the iPhone 16 release?"

## Actions

- FIRECRAWL_GET_SCRAPED_DATA: For single-page content extraction
- WEB_SEARCH: Web search for any data
`````

## File: packages/docs/static/packages/plugins/flow.md
`````markdown
# @elizaos/plugin-flow

## Purpose

A plugin for interacting with the Flow blockchain within the ElizaOS ecosystem, providing functionality for native FLOW token transfers, fungible token transfers, and EVM token interactions.

## Installation

```bash
bun install @elizaos/plugin-flow
```

## Configuration

The plugin requires environment variables:

```typescript
FLOW_ADDRESS=<Flow wallet address starting with 0x>
FLOW_PRIVATE_KEY=<Private key for the Flow wallet starting with 0x>
FLOW_NETWORK=<Network to connect to: "mainnet", "testnet", or "emulator" (optional, defaults to "mainnet")>
FLOW_ENDPOINT_URL=<Custom RPC endpoint URL (optional)>
```

## Integration

```typescript
import { flowPlugin } from '@elizaos/plugin-flow';
```

## Example Usage

```typescript
'Send 5 FLOW to 0xa51d7fe9e0080662';
'Send 1 FLOW - A.1654653399040a61.FlowToken to 0xa2de93114bae3e73';
'Send 1000 FROTH - 0xb73bf8e6a4477a952e0338e6cc00cc0ce5ad04ba to 0x000000000000000000000002e44fbfbd00395de5';
```

## Links

- [Flow Documentation](https://docs.onflow.org/)
- [Flow Developer Portal](https://developers.flow.com/)
- [Flow Block Explorer](https://flowscan.io/)
- [Cadence Documentation](https://docs.onflow.org/cadence/)
`````

## File: packages/docs/static/packages/plugins/football.md
`````markdown
# @elizaos/plugin-football

## Purpose

A plugin providing live football match data and league standings integration for ElizaOS agents.

## Key Features

1. Live Match Data - Retrieves teams, scores, and game events with real-time updates
2. League Standings - Fetches team rankings, points, goals scored, and other statistics
3. Flexible Integration - Extendable for additional football data

## Installation

```bash
bun install @elizaos/plugin-football
```

## Configuration

Requires an API key from Football-Data.org, added to your `.env` file:

```env
FOOTBALL_API_KEY=your_api_key_here
```

## Integration

Provides actions (`fetchMatchAction` and `fetchStandingsAction`) that enable ElizaOS agents to access football data in conversations.

## Example Usage

```javascript
import { fetchMatchAction } from '@elizaos/plugin-football';

const result = await fetchMatchAction.handler(runtime, message, state);
console.log(result);
```

## Links

- [Football-Data.org API](https://www.football-data.org/)
- [Football-Data API Documentation](https://www.football-data.org/documentation/quickstart)
`````

## File: packages/docs/static/packages/plugins/form.md
`````markdown
# @elizaos/plugin-form

## Purpose

A plugin for integrating Form chain capabilities within the ElizaOS ecosystem, providing direct access to curves-based token economics and ERC20 conversions.

## Key Features

- Buy and sell curves tokens
- Convert between curves and ERC20 tokens
- Manage token holdings
- Query prices and balances
- Create new ERC20 tokens for curves

## Installation

```bash
bun install @elizaos/plugin-form
```

## Configuration

### Environment Variables

```bash
FORM_PRIVATE_KEY=<Your Form chain wallet private key>
FORM_TESTNET=true  # Optional, defaults to false
```

### Plugin Setup

```typescript
// In your agent configuration
import { formPlugin } from '@elizaos/plugin-form';

const character = {
  plugins: [formPlugin],
  // ... other configuration
};
```

## Integration

The plugin integrates Form chain with Eliza, supporting both QUADRATIC and LOGRITHMIC formulas for different use cases and trading volumes.

## Example Usage

```typescript
await runtime.processAction('BUY_CURVES_TOKEN', {
  subject: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e',
  amount: 1,
  formula: 'QUADRATIC', // or "LOGRITHMIC" for high volume
});
```
`````

## File: packages/docs/static/packages/plugins/fuel.md
`````markdown
# @elizaos/plugin-fuel

## Purpose

A plugin for interacting with the Fuel blockchain within the ElizaOS ecosystem, focusing on ETH transfers on the Fuel Ignition network.

## Installation

```bash
bun install @elizaos/plugin-fuel
```

## Configuration

```typescript
FUEL_PRIVATE_KEY=<Private key for the Fuel wallet starting with 0x>
FUEL_PROVIDER_URL=<Custom RPC endpoint URL (optional, defaults to "https://mainnet.fuel.network/v1/graphql")>
```

## Integration

Import the plugin:

```typescript
import { fuelPlugin } from '@elizaos/plugin-fuel';
```

## Example Usage

```typescript
'Transfer 1 ETH to 0x8F8afB12402C9a4bD9678Bec363E51360142f8443FB171655eEd55dB298828D1';
```

## Links

- [Fuel Documentation](https://docs.fuel.network/)
- [Fuel Developer Portal](https://developers.fuel.network/)
- [Fuel Network Dashboard](https://app.fuel.network/)
- [Fuel GitHub Repository](https://github.com/FuelLabs)
`````

## File: packages/docs/static/packages/plugins/gelato.md
`````markdown
# plugin-gelato

## Purpose

A powerful plugin to interact with smart contracts using Gelato Relay, supporting both ERC2771 (meta transactions) and non-ERC2771 calls on any EVM-compatible blockchain.

## Key Features

- Sponsored Calls: Interact with contracts without needing gas on the user's side
- ERC2771 Support: Execute meta-transactions via Gelato's sponsoredCallERC2771
- Customizable: Easily configure chains, contracts, and user-specific settings

## Installation

```
bun install elizaos/plugin-gelato
```

## Configuration

Fill out the `.env` file in the project root:

```
GELATO_RELAY_API_KEY=<Your Gelato Relay API Key>
EVM_PROVIDER_URL=<Your EVM provider URL (e.g., Alchemy or Infura endpoint)>
EVM_PRIVATE_KEY=<Your wallet's private key>
```

## Example Usage

- Non-ERC2771 (Standard Sponsored Call) to call increment() function
- ERC2771 (Meta-Transactions) to call increment() with user address
- Successful execution returns confirmation with task ID and tracking link

## Troubleshooting

- Ensure proper .env configuration
- Verify contract ABI, function name, and chain details
- For ERC2771 calls, confirm User address is correct
`````

## File: packages/docs/static/packages/plugins/genlayer.md
`````markdown
# @elizaos/plugin-genlayer

## Purpose

A plugin for interacting with the GenLayer protocol, enabling contract deployment, interactions, and transaction management.

## Installation

```bash
bun add @elizaos/plugin-genlayer
```

## Configuration

### Required Environment Variables

```env
GENLAYER_PRIVATE_KEY=your_private_key     # Required: Must start with 0x
GENLAYER_RPC_URL=your_rpc_url            # Optional: Defaults to https://studio.genlayer.com:8443/api
```

## Integration

Add the plugin to your character configuration:

```typescript
import { genLayerPlugin } from '@elizaos/plugin-genlayer';

const character = {
  plugins: [genLayerPlugin],
};
```

## Key Features

- Read contract state
- Write to contracts
- Deploy new contracts
- Get contract schemas
- Transaction management (details, status, nonces, receipts)

## Example Usage

- READ_CONTRACT: "Read the GenLayer contract at 0xE2632... by calling get_have_coin"
- WRITE_CONTRACT: "Write to the contract at 0xE2632... by calling set_value with argument 42"
- DEPLOY_CONTRACT: "Deploy a new contract from /path/to/contract.py with argument 'true'"
- GET_TRANSACTION: "Get transaction details for hash 0x1234..."
- GET_CURRENT_NONCE: "Get current nonce for address 0xE2632..."
- WAIT_FOR_TRANSACTION_RECEIPT: "Wait for receipt of transaction 0x1234..."
- GET_CONTRACT_SCHEMA: "Get contract schema for address 0xE2632..."
`````

## File: packages/docs/static/packages/plugins/gigbot.md
`````markdown
# Eliza GigBot Client

## Purpose

This package provides GigBot integration for the Eliza AI agent, enabling task automation and token earning.

## Key Features

- Task automation and management
- Interaction handling with GigBot API
- Token earning through task completions
- Approval workflow via Discord (optional)

## Configuration

Environment Variables:

- `GIGBOT_API_URL`: GigBot API endpoint (default: https://www.gigbot.xyz/api)
- `GIG_SEARCH_INTERVAL`: How often to search for new tasks (hours, default: 3)
- `GIG_ACTION_INTERVAL`: How often to perform task actions (hours, default: 12)
- `GIG_CLAIM_INTERVAL`: How often to claim completed tasks (hours, default: 24)
- `GIG_CLAIM_PLATFORM`: Platform to claim tasks from ('x' or 'farcaster', default: x)
- `EVM_PRIVATE_KEY`: Ethereum private key for claiming rewards (required)

## Integration

- Register the plugin with Eliza runtime
- Requires Twitter client initialization before GigBot
- Must pass existing clients to GigBot during initialization

## Example Usage

```typescript
import { GigBotClientInterface } from '@elizaos/gigbot';

const gigbotPlugin = {
  name: 'gigbot',
  description: 'GigBot client',
  clients: [GigBotClientInterface],
};

// Register with your Eliza runtime
runtime.registerPlugin(gigbotPlugin);
```
`````

## File: packages/docs/static/packages/plugins/giphy.md
`````markdown
# Plugin Giphy

## Purpose

A plugin for sending GIFs in response to user messages.

## Key Features

Enables agent to respond with relevant GIFs based on user inputs using the Giphy API.

## Installation

```bash
bun add @elizaos/plugin-giphy
```

## Configuration

Set up your environment with a Giphy API key:

| Variable Name   | Description                               |
| --------------- | ----------------------------------------- |
| `GIPHY_API_KEY` | Giphy API key for authenticating requests |

## Integration

Provides the `SEND_GIF` action which automatically responds with a GIF based on the context of user messages.

## Example Usage

```typescript
import { giphyPlugin } from '@elizaos/plugin-giphy';

// Initialize the plugin
const plugin = giphyPlugin;

// Add the plugin to your agent's plugin list
const plugins = [
  giphyPlugin,
  // ... other plugins
];
```

## Links

[Giphy API](https://developers.giphy.com/)
[Giphy Developers](https://developers.giphy.com/)
`````

## File: packages/docs/static/packages/plugins/gitbook.md
`````markdown
# @elizaos/plugin-gitbook

## Purpose

A plugin for querying and retrieving information from GitBook documentation within the ElizaOS ecosystem.

## Key Features

- Natural language queries for documentation content
- Intelligent query validation
- Keyword-based filtering
- Clean response formatting

## Installation

```bash
bun install @elizaos/plugin-gitbook
```

## Configuration

### Environment Variables

```typescript
GITBOOK_SPACE_ID=<Your GitBook Space ID>
```

### Client Configuration (Optional)

```json
{
  "name": "YourCharacter",
  "plugins": ["gitbook"],
  "settings": {
    "gitbook": {
      "keywords": {
        "projectTerms": ["term1", "term2"],
        "generalQueries": ["custom1", "custom2"]
      },
      "documentTriggers": ["docs", "documentation"]
    }
  }
}
```

## Integration

```typescript
import { gitbookPlugin } from '@elizaos/plugin-gitbook';
```

## Example Usage

```typescript
'How do I get started with the project?';
'What are the main features?';
'Explain how to configure the system';
```
`````

## File: packages/docs/static/packages/plugins/gitcoin-passport.md
`````markdown
# `@elizaos/plugin-gitcoin-passport`

## Purpose

This plugin provides actions for interacting with Gitcoin passport.

## Installation

Add it under your character profile in plugins as:

```
    "plugins": [
        "@elizaos/plugin-gitcoin-passport"
    ],
```

## Configuration

1. Get API Key:

   - Log in at developer.passport.xyz with your wallet
   - Go to "API Keys" section
   - Click "+ Create a Key"
   - Store your API key securely

2. Get Scorer ID:
   - Go to "Scorer" section
   - Click "+ Create a Scorer" (use Unique Humanity scorer)
   - Find Scorer ID in page URL: https://developer.passport.xyz/dashboard/scorer/{scorer_id}

## Usage

Results are saved as messages and agents can retrieve them for different use cases. Default passport threshold of 20 is used, but custom values can be selected.

## Links

https://docs.passport.xyz/building-with-passport/passport-api/overview
`````

## File: packages/docs/static/packages/plugins/goat.md
`````markdown
# @elizaos/plugin-goat

## Purpose

A plugin for integrating blockchain capabilities through the GOAT (Great Onchain Agent Toolkit) framework within the ElizaOS ecosystem.

## Key Features

- Blockchain interaction capabilities including wallets and token management
- Support for multiple chains and protocols
- Actions for sending and checking balances of ETH and USDC
- Token swapping using KIM protocol
- Expandable with additional GOAT plugins

## Installation

```bash
bun install @elizaos/plugin-goat
```

## Configuration

### Environment Variables

```typescript
EVM_PRIVATE_KEY=<Your EVM wallet private key>
EVM_PROVIDER_URL=<Your RPC provider URL (e.g., Infura, Alchemy)>
```

## Integration

The plugin integrates GOAT with Eliza, enabling agents to interact with various blockchain protocols. Users can configure chains, specify actions, and add plugins for different protocols.

## Links

- [GOAT Documentation](https://ohmygoat.dev/)
- [Available Chains](https://ohmygoat.dev/chains)
- [Chains, Wallets & Plugins](https://ohmygoat.dev/chains-wallets-plugins)
- [Smart Wallet Documentation](https://docs.crossmint.com/wallets/smart-wallets/overview)
`````

## File: packages/docs/static/packages/plugins/goplus.md
`````markdown
# @elizaos/plugin-goplus

## Purpose

A plugin that enables on-chain security checks through the GoPlus API integration.

## Installation

```bash
bun add @elizaos/plugin-goplus
```

## Configuration

### Required Environment Variables

```env
GOPLUS_API_KEY=your_api_key  # Required: GoPlus API key for authentication
```

## Integration

Add the plugin to your character configuration:

```typescript
import { goplusPlugin } from '@elizaos/plugin-goplus';

const character = {
  plugins: [goplusPlugin],
};
```

## Key Features

- EVM Token Security
- Solana Token Security
- Sui Token Security
- Rugpull Detection
- NFT Security Analysis
- Address Security Verification
- Contract Approval Analysis
- Account Token Analysis (ERC20/721/1155)
- Signature Security
- URL/DApp Security

## Supported Networks

The plugin supports various networks including Ethereum (1), BSC (56), Polygon (137), Arbitrum (42161), Avalanche (43114), Optimism (10), Base (8453), and many more.
`````

## File: packages/docs/static/packages/plugins/grix.md
`````markdown
# @elizaos/plugin-grix

## Purpose

A plugin that enables DeFi options data fetching and price analysis through the Grix Finance API integration.

## Key Features

- Real-time BTC/ETH price feeds
- Options pricing across multiple protocols
- Available liquidity information
- Call and Put options data
- Strike prices and expiry dates
- Protocol-specific pricing
- Position types (long/short)

## Installation

```bash
bun add @elizaos/plugin-grix
```

## Configuration

Requires a Grix API key, available via Discord or Telegram.

Two configuration methods:

1. Environment Variables:

```env
GRIX_API_KEY=your_api_key
```

2. Character Configuration:

```json
{
  "name": "Your Character",
  "plugins": ["@elizaos/plugin-grix"],
  "settings": {
    "secrets": {
      "GRIX_API_KEY": "your_api_key_here"
    }
  }
}
```

## Integration

Available Actions:

- getOptionPrice: Fetches options data across protocols
- getAssetPrice: Retrieves real-time price data for BTC/ETH

## Links

- [Discord Community](https://discord.com/invite/ZgPpr9psqp)
- [Telegram Group](https://t.me/GrixFinance)
- [Documentation](https://app.grix.finance/docs)
`````

## File: packages/docs/static/packages/plugins/holdstation.md
`````markdown
# @elizaos/plugin-holdstation

## Purpose

Holdstation Wallet Plugin for Eliza

## Key Features

- Token swapping on hold.so (Holdstation swap)
- Currently on ZKsync Era, with Berachain coming soon

## Installation

```bash
bun add @elizaos/plugin-holdstation
```

## Configuration

The plugin requires the following environment variables:

```env
HOLDSTATION_PRIVATE_KEY=            # Required: Your wallet's private key
```

## Development

```bash
bun install --no-frozen-lockfile
bun build
bun test
```

## Credits

Special thanks to:

- The Eliza community for their contributions and feedback
`````

## File: packages/docs/static/packages/plugins/hyperbolic.md
`````markdown
# Hyperbolic Plugin

## Purpose

A powerful plugin for managing GPU instances on the Hyperbolic platform through Eliza AI.

## Key Features

- List available GPUs with specifications and pricing
- Check account balance
- Monitor GPU instance status
- View spending history
- Rent GPU instances
- Terminate GPU instances

## Configuration

The plugin requires environment variables:

```bash
HYPERBOLIC_API_KEY=your_api_key_here
HYPERBOLIC_ENV=production     # or development
HYPERBOLIC_GRANULAR_LOG=true  # optional, for detailed logging
HYPERBOLIC_LOG_LEVEL=debug    # optional, to control the level
HYPERBOLIC_SPASH=true         # to show the splash
```

## Integration

Operates as a plugin for Eliza AI to manage GPU instances on the Hyperbolic platform.

## Example Usage

```
Show me available GPUs on Hyperbolic
Show my current balance on Hyperbolic
Check status of all my GPU instances on Hyperbolic
Show my spending history on Hyperbolic
Create a GPU instance on the Hyperbolic
[nodeid]las1-prd-acl-msi-09.fen.intra[/nodeid]
[cluster]circular-snapdragon-worm[/cluster]
Terminate the Hyperbolic instance [gpu]worse-walnut-viper[/gpu]
```
`````

## File: packages/docs/static/packages/plugins/hyperliquid.md
`````markdown
# Hyperliquid Plugin for Eliza

## Purpose

This plugin enables interaction with the Hyperliquid DEX through Eliza, providing spot trading capabilities.

## Key Features

- Spot Trading (market and limit orders with price validation)
- Price Checking (real-time price information, 24h change, volume statistics)
- Order Management (cancel all open orders)

## Installation

Add the plugin to your Eliza configuration:

```json
{
  "plugins": ["@elizaos/plugin-hyperliquid"]
}
```

## Configuration

Set the following environment variables:

```env
HYPERLIQUID_PRIVATE_KEY=your_private_key  # Required for trading and cancelling orders
HYPERLIQUID_TESTNET=true_or_false        # Optional, defaults to false
```

## Integration

The plugin provides three main actions: SPOT_TRADE for placing market or limit orders, PRICE_CHECK for getting token price information, and CANCEL_ORDERS for cancelling all open orders.

## Example Usage

```
"buy 1 PIP"              # Market order
"sell 2 HYPE"            # Market order
"buy 1 PIP at 20 USDC"   # Limit order
"What's the price of PIP?" # Price check
"Cancel all orders"      # Cancel orders
```

## Links

License: MIT
`````

## File: packages/docs/static/packages/plugins/icp.md
`````markdown
# @elizaos/plugin-icp

## Purpose

Internet Computer Protocol (ICP) plugin for Eliza OS.

## Key Features

- Create meme tokens on PickPump
- Interact with ICP canisters
- Handle ICRC-1 token standard
- Manage ICP wallets and identities
- Support for anonymous and authenticated calls

## Installation

```bash
bun install @elizaos/plugin-icp
```

## Configuration

The plugin requires the following environment variables:

```env
INTERNET_COMPUTER_PRIVATE_KEY=<your-ed25519-private-key>
```

## Integration

```typescript
import { icpPlugin } from '@elizaos/plugin-icp';

// Register the plugin with Eliza
eliza.registerPlugin(icpPlugin);
```

## Example Usage

```typescript
// Example usage in chat
'Create a space cat token on PickPump';
'Help me create a pizza-themed funny token on PP';
```

## Dependencies

- @dfinity/agent: ^2.1.3
- @dfinity/candid: ^2.1.3
- @dfinity/identity: ^2.1.3
- @dfinity/principal: ^2.1.3
- @elizaos/core: workspace:\*
`````

## File: packages/docs/static/packages/plugins/image-generation.md
`````markdown
# Plugin Image Generation

## Purpose

A plugin designed for generating and managing images, providing features like image manipulation, storage integration, and optimized handling for various use cases.

## Key Features

- Dynamic image generation
- Integration with storage solutions
- Optimized handling for high-resolution images

## Installation

```bash
bun install plugin-image-generation
```

## Configuration

### Environment Variables

- `IMAGE_STORAGE_BUCKET`: Name of the storage bucket
- `STORAGE_ACCESS_KEY`: Access key for storage integration
- `STORAGE_SECRET_KEY`: Secret key for storage integration

### TypeScript Configuration

Requires TypeScript environment with specific compiler options in tsconfig.json

## Example Usage

### Generate an Image

```typescript
import { generateImage } from 'plugin-image-generation';

const image = await generateImage({
  width: 800,
  height: 600,
  backgroundColor: '#ffffff',
  text: 'Hello World',
  font: 'Arial',
});

console.log('Generated Image:', image);
```

### Upload to Storage

```typescript
import { uploadImage } from 'plugin-image-generation';

const uploadResult = await uploadImage({
  imagePath: 'path/to/image.png',
  bucketName: 'my-storage-bucket',
});

console.log('Image uploaded successfully:', uploadResult);
```
`````

## File: packages/docs/static/packages/plugins/image.md
`````markdown
# ImageDescriptionService

## Purpose

Processes and analyzes images to generate descriptions.

## Key Features

- Local processing using Florence model
- OpenAI Vision API integration
- Google Gemini support
- Automatic handling of different image formats, including GIFs
- Provider-specific capabilities (basic captioning, text detection, object recognition, etc.)

## Configuration

```env
# For OpenAI Vision
OPENAI_API_KEY=your_openai_api_key

# For Google Gemini
GOOGLE_GENERATIVE_AI_API_KEY=your_google_api_key
```

Provider selection:

- If `imageVisionModelProvider` is set to `google/openai`, it will use this one.
- Else if `model` is set to `google/openai`, it will use this one.
- Default if nothing is set is OpenAI.

## Example Usage

```typescript
const result = await runtime.executeAction('DESCRIBE_IMAGE', {
  imageUrl: 'path/to/image.jpg',
});
```
`````

## File: packages/docs/static/packages/plugins/imgflip.md
`````markdown
# @elizaos/plugin-imgflip

## Purpose

A plugin for generating memes using the imgflip.com API.

## Key Features

- GENERATE_MEME action used for generating memes using the imgflip.com API based on the user's message.

## Installation

```bash
bun install @elizaos/plugin-imgflip
```

## Integration

The Imgflip plugin provides a GENERATE_MEME action that can be used to generate memes using the imgflip.com API based on the user's message.

## Dependencies

- @elizaos/core: workspace:\*
`````

## File: packages/docs/static/packages/plugins/initia.md
`````markdown
# @elizaos/plugin-initia

## Purpose

Initia plugin for Eliza OS that provides functionality to transfer INIT token.

## Installation

```bash
bun install @elizaos/plugin-initia
```

## Configuration

```bash
INITIA_PRIVATE_KEY=0x1234...abcd
INITIA_NODE_URL=https://...
INITIA_CHAIN_ID=initiaion-2
```

## Example Usage

```typescript
User: 'Send 1 INIT to init14l3c2vxrdvu6y0sqykppey930s4kufsvt97aeu';
Assistant: 'Sure! I am going to send 1 INIT to init14l3c2vxrdvu6y0sqykppey930s4kufsvt97aeu';
```

## Dependencies

- `@initia/initia.js`: Official initia js SDK
`````

## File: packages/docs/static/packages/plugins/injective.md
`````markdown
# @elizaos/plugin-injective

## Purpose

A comprehensive plugin for interacting with the Injective chain through ElizaOS.

## Key Features

- Modules for multiple chain functionalities including:
  - Exchange (spot/derivative markets, orders, positions)
  - Auction (parameters, rounds, bidding)
  - Bank (balances, transfers, supply queries)
  - Governance (proposals, voting)
  - Staking (validator operations, delegations)
  - Token Factory (token creation and management)
  - WASM (smart contract functionality)
  - Plus additional modules for auth, distribution, explorer, IBC, insurance, mint, mito, peggy, permissions

## Installation

```bash
npm install @elizaos/plugin-injective
```

## Integration

Import and use the actions from the plugin:

```typescript
import { InjectiveActions } from '@elizaos/plugin-injective';
```

## License

ISC
`````

## File: packages/docs/static/packages/plugins/intiface.md
`````markdown
# @elizaos/plugin-intiface

## Purpose

Intiface/Buttplug.io integration plugin for Eliza OS that enables control of intimate hardware devices.

## Key Features

- Support for multiple intimate hardware devices through Buttplug.io protocol
- Automatic device discovery and connection management
- Battery level monitoring for supported devices
- Vibration and rotation control (device-dependent)
- Graceful connection handling and cleanup
- Built-in device simulation for testing
- Support for customizable vibration patterns
- Automatic Intiface Engine management

## Installation

```bash
bun install @elizaos/plugin-intiface
```

## Configuration

The plugin can be configured through environment variables or runtime settings:

```env
INTIFACE_URL=ws://localhost:12345
INTIFACE_NAME=Eliza Intiface Client
DEVICE_NAME=Lovense Nora
```

## Integration

The plugin integrates with ElizaOS through the execute function to control devices and retrieve information:

```typescript
import { intifacePlugin } from '@elizaos/plugin-intiface';

// Vibrate device
const result = await eliza.execute({
  action: 'VIBRATE',
  content: {
    strength: 0.5, // 0.0 to 1.0
    duration: 1000, // milliseconds
  },
});
```

## Links

- [Buttplug.io](https://buttplug.io)
- [Intiface Engine](https://github.com/intiface/intiface-engine)
`````

## File: packages/docs/static/packages/plugins/iq6900.md
`````markdown
# Code In Plugin For Eliza

## Purpose

Provides inscription functionality to engrave Eliza Character JSON files on the blockchain permanently through IQ6900's "Code-In" standard.

## Key Features

- Blockchain engraving of Character JSON files without compression
- Onchain git-like system for file management and updates
- Automatic loading of latest agent files

## Configuration

Edit your .env file to include IQ_WALLET_ADDRESS with the wallet address used on the website.

## Integration

The plugin automatically loads your latest agent file from the blockchain after inscription (wait about 5 minutes after inscription and type "pmpn start").

## Links

- Inscription site: https://elizacodein.com/
- Documentation: https://iq6900.gitbook.io/iq6900/eliza-code-in
`````

## File: packages/docs/static/packages/plugins/irys.md
`````markdown
# @elizaos/plugin-irys

## Purpose

A plugin for ElizaOS that enables decentralized data storage and retrieval using Irys, a programmable datachain platform.

## Key Features

- Decentralized Data Storage: Store data permanently on the Irys network
- Data Retrieval: Fetch stored data using GraphQL queries
- Multi-Agent Support: Enable data sharing and collaboration between agents
- Ethereum Integration: Built-in support for Ethereum wallet authentication

## Installation

```bash
bun add @elizaos/plugin-irys
```

## Configuration

Required environment variables:

- `EVM_WALLET_PRIVATE_KEY`: Your EVM wallet private key
- `AGENTS_WALLET_PUBLIC_KEYS`: Public keys of agents to retrieve data (comma-separated)

An EVM (Base network) wallet with Base Sepolia ETH tokens is required for storing data larger than 100KB.

## Integration

The plugin provides an IrysService with methods for workers and providers to store and retrieve data on the Irys network. It enables decentralized knowledge base creation and multi-agent collaboration through a system of Providers, Orchestrators, and Workers.

## Example Usage

```typescript
const { IrysService } = require('@elizaos/plugin-irys');

const irysService = runtime.getService(ServiceType.IRYS);
const data = 'Provide Liquidity to the ETH pool on Stargate';
const result = await irysService.workerUploadDataOnIrys(
  data,
  IrysDataType.OTHER,
  IrysMessageType.DATA_STORAGE,
  ['DeFi'],
  ['Stargate', 'LayerZero']
);
```

## Links

- [Irys Documentation](https://docs.irys.xyz/)
- [A Decentralized Framework for Multi-Agent Systems Using Datachain Technology](https://trophe.net/article/A_Decentralized_Framework_for_Multi-Agent_Systems_Using_Datachain_Technology.pdf)
`````

## File: packages/docs/static/packages/plugins/isaacx.md
`````markdown
# Isaac X Plugin for ElizaOS

## Purpose

This plugin provides integration with the Isaac X API, enabling ElizaOS Agents to reason scientifically using the latest academic research.

## Key Features

- Research question answering with academic citations
- Rate limit management (10 free requests/day)
- Automatic reference tracking

## Installation

```bash
bun add @elizaos/plugin-isaacx
```

## Configuration

1. First, visit [isaacx.ai/docs](https://isaacx.ai/docs) to create your API key.

2. Add your Isaac X API key to your environment variables:

```bash
ISAACX_API_KEY=ix_your_api_key_here
```

3. Register the plugin in your character configuration:

```typescript
import isaacXPlugin from '@elizaos/plugin-isaacx';

const character = {
  plugins: [isaacXPlugin],
};
```

## Integration

The plugin connects to ElizaOS through the character configuration system and provides actions for research question answering.

## Example Usage

```typescript
// Ask a research question
const response = await runtime.processAction('ANSWER_RESEARCH_QUESTION', {
  question: 'What are the latest developments in quantum computing?',
});

// The response will include both the answer and academic citations
console.log('Research Findings:', response.answer);
console.log('Academic Sources:', response.references);
```

## Links

[isaacx.ai/docs](https://isaacx.ai/docs)
`````

## File: packages/docs/static/packages/plugins/lens-network.md
`````markdown
# @elizaos/plugin-abstract

## Purpose

A plugin for interacting with the Abstract blockchain network within the ElizaOS ecosystem, enabling seamless token transfers on the Abstract testnet.

## Installation

```bash
bun install @elizaos/plugin-lensNetwork
```

## Configuration

The plugin requires the following environment variables:

```typescript
LENS_ADDRESS=<Your Lens wallet address>
LENS_PRIVATE_KEY=<Your Lens private key>
```

## Integration

The plugin can be imported and responds to natural language commands for transferring tokens.

## Example Usage

```typescript
// Import the plugin
import { lensPlugin } from '@elizaos/plugin-lensNetwork';

// Example command:
('Send 1 Grass to 0xCCa8009f5e09F8C5dB63cb0031052F9CB635Af62');
```
`````

## File: packages/docs/static/packages/plugins/lensNetwork.md
`````markdown
# @elizaos/plugin-abstract

## Purpose

A plugin for interacting with the Abstract blockchain network within the ElizaOS ecosystem, enabling seamless token transfers on the Abstract testnet.

## Installation

```bash
bun install @elizaos/plugin-lensNetwork
```

## Configuration

The plugin requires the following environment variables:

```typescript
LENS_ADDRESS=<Your Lens wallet address>
LENS_PRIVATE_KEY=<Your Lens private key>
```

## Integration

The plugin integrates with ElizaOS to handle natural language commands for token transfers like "Send 1 Grass to 0xCCa8009f5e09F8C5dB63cb0031052F9CB635Af62".

## Example Usage

```typescript
import { lensPlugin } from '@elizaos/plugin-lensNetwork';
```
`````

## File: packages/docs/static/packages/plugins/letzai.md
`````markdown
# @elizaos/plugin-letzai

## Purpose

A plugin to integrate LetzAI Image Generation capabilities into the elizaos ecosystem, enabling agents to generate images using any LetzAI Models.

## Key Features

- Uses the LetzAI API and any models available to API user
- Introduces its own GENERATE_IMAGE action

## Installation

```bash
bun install @elizaos/plugin-letzai
```

## Configuration

### Environment Variables

```typescript
LETZAI_API_LEY=<Your LetzAI API Key>
LETZAI_MODELS="@hailee, @examplemodel2"
```

## Integration

The plugin can be integrated in character.json:

```json
"plugins": ["../../packages/plugin-letzai/src/index.ts"],
"actions": ["GENERATE_IMAGE"]
```

## Links

- [LetzAI API](https://www.letz.ai/docs/api)
- [Create API Key](https://www.letz.ai/subscription)
`````

## File: packages/docs/static/packages/plugins/lightlink.md
`````markdown
# @elizaos/plugin-lightlink

## Purpose

The LightLink Plugin allows agents to interact with the LightLink network.

## Key Features

- Check balances
- Transfer both ERC20 and Eth
- Swap (via Elektrik)
- Search the block explorer for contracts and addresses

## Installation

```
bun add @elizaos/plugin-lightlink
```

## Configuration

### Required Environment Variables

```env
# Required
EVM_PRIVATE_KEY=your-private-key-here

# Optional - Custom RPC URLs
LIGHTLINK_MAINNET_RPC_URL=https://your-custom-mainnet-rpc-url
LIGHTLINK_TESTNET_RPC_URL=https://your-custom-testnet-rpc-url
```

### Chain Configuration

By default, LightLink Phoenix (mainnet) is enabled. Additional chains can be added in the character config.

## Example Usage

- Check balance: `Check the balance of vitalik.eth on lightlink`
- Transfer: `Transfer 1 ETH to 0x742d35Cc6634C0532925a3b844Bc454e4438f44e`
- Swap: `Swap 1 ETH to USDC on lightlink testnet`
- Search: `Whats the contract address for the USDC token on lightlink?`
`````

## File: packages/docs/static/packages/plugins/lightning.md
`````markdown
# @elizaos/plugin-lightning

## Purpose

This plugin enables creating lightning invoices or paying invoices.

## Key Features

- 💱 Make a new off-chain invoice.
- 📊 Make an off-chain payment.

## Installation

Add the plugin to your Eliza configuration:

```json
{
  "plugins": ["@elizaos/plugin-lightning"]
}
```

## Configuration

Set the following environment variables:

```env
LND_TLS_CERT=your_lnnode_tls_cert   #Base64 of LND certificate
LND_MACAROON=020.....        #Base64 encoded admin.macaroon file
LND_SOCKET='x.x.x.x:10009'
```

## Example Usage

### CREATE_INVOICE

```text
"Help me create an invoice for 1000sats"
"Create an invoice for 1000sats"
```

Returns: lnbcrt....

### PAY_INVOICE

```text
"Pay invoice lnbcrt10u1pncndjvpp58y77adkngcz3ypx6t39j245ydvk2vu67c8ugvegee3gt5wgs7yjqdxvdec82c33wdmnq73s0qcxwurrxp4nquncxe4h56m9xu6xwetyd3mrq6ehdguxkd35wuurgarex4u8gefkdsekgdtnddehxurrxecxvhmwwp6kyvfexekhxwtv8paryvnpwsuhxdryvachwangw3kn2atddq6kzvrvwfcxzanewce8ja34d43k56rkweu8jdtcwv68zmrsvdescqzzsxqrrsssp5q3hv38wfprvaazzwf8c4t33tzjcac5xz94sk8muehmn5szqaw6ks9qxpqysgqt5pjhna4922s8ayzgu5rh8clx7psp2culdr5r6cxxxqzs3e5ep345p45vggg0qegt6fu3prdrqgpd8v70l9wdhekt8gex5e8pqvxg2sp97fkmd"
```
`````

## File: packages/docs/static/packages/plugins/lit.md
`````markdown
# @elizaos/plugin-lit

## Purpose

A plugin that integrates Lit Protocol functionality into the elizaOS runtime environment, enabling secure and decentralized access control and cryptographic operations.

## Key Features

- Deploy and manage Lit Actions for programmable cryptography
- Interact with Lit Agent Wallet for secure transaction signing
- Built-in tools for common blockchain operations:
  - ECDSA signing
  - ERC20 token transfers
  - Uniswap interactions

## Installation

```bash
npm install @elizaos/plugin-lit
```

## Configuration

There are two ways to register the plugin:

1. Add to your agent's plugins in `agent/src/index.ts`:

```typescript
import { LitPlugin } from '@elizaos/plugin-lit';

export default {
  plugins: [
    // ... other plugins
    litPlugin,
  ],
  // ... rest of your agent configuration
};
```

2. Or add it in your character configuration:

```typescript
{
  name: "YourCharacter",
  plugins: [
    // ... other plugins
    "@elizaos/plugin-lit"
  ]
}
```

## Integration

After registration, initialize Lit Protocol:

```javascript
await elizaOS.lit.initialize({
  // Your configuration options
});
```

## Example Usage

```javascript
// Deploy Lit Action
const litAction = await elizaOS.lit.deployAction({
  code: `
    (async () => {
      // Your Lit Action code here
    })();
  `,
});

// ECDSA Signing
const signature = await elizaOS.lit.tools.ecdsaSign({
  message: 'Message to sign',
  // Additional parameters
});

// ERC20 Token Transfer
const transfer = await elizaOS.lit.tools.erc20Transfer({
  tokenAddress: '0x...',
  recipient: '0x...',
  amount: '1000000000000000000', // 1 token with 18 decimals
});
```

## Links

- [Lit Protocol Documentation](https://developer.litprotocol.com/)
- [Agent Wallet Documentation](https://github.com/LIT-Protocol/agent-wallet)
`````

## File: packages/docs/static/packages/plugins/llama.md
`````markdown
# @elizaos/plugin-llama

## Purpose

Core LLaMA plugin for Eliza OS that provides local Large Language Model capabilities.

## Key Features

- Local LLM Support: Run LLaMA models locally
- GPU Acceleration: CUDA support for faster inference
- Flexible Configuration: Customizable parameters for text generation
- Message Queuing: Efficient handling of multiple requests
- Automatic Model Management: Download and verification systems

## Installation

```bash
npm install @elizaos/plugin-llama
```

## Configuration

The plugin can be configured through environment variables:

```env
LLAMALOCAL_PATH=your_model_storage_path
OLLAMA_MODEL=optional_ollama_model_name
```

## Integration

```typescript
import { createLlamaPlugin } from '@elizaos/plugin-llama';

// Initialize the plugin
const llamaPlugin = createLlamaPlugin();

// Register with Eliza OS
elizaos.registerPlugin(llamaPlugin);
```
`````

## File: packages/docs/static/packages/plugins/massa.md
`````markdown
# Massa Plugin

## Purpose

This plugin aims to be the basis of all interactions with the Massa ecosystem.

## Links

[https://docs.massa.net/](https://docs.massa.net/)
`````

## File: packages/docs/static/packages/plugins/merkle-eliza-plugin.md
`````markdown
# MerkleTrade Plugin for Eliza

## Purpose

A sample plugin for interacting with MerkleTrade within the elizaOS ecosystem.

## Configuration

The plugin requires the following environment variables to be set:

Merkle Configuration

```env
MERKLE_TRADE_NETWORK=               # Must be one of mainnet, testnet
MERKLE_TRADE_APTOS_PRIVATE_KEY=     # Aptos private key
```

## Installation

```json
{
  "plugins": ["@elizaos/plugin-merkle"]
}
```

## Example Usage

```bash
// The plugin responds to natural language like:

You: "Open a BTC Long position on the Merkle Trade platform with 1000 pay and 10 leverage."
Agent: "Successfully market order BTC with 1000 pay and 10 leverage, Transaction: 0x104af5d1a786a2e1a4721a721b2cfccc7e15fa41eec15a489ba1768790adb523"
```

## Links

- [Merkle Documentation](https://docs.merkle.trade/)
- [Aptos Documentation](https://aptos.dev/)
- [Move Language Guide](https://move-language.github.io/move/)
`````

## File: packages/docs/static/packages/plugins/merkle.md
`````markdown
# MerkleTrade Plugin for Eliza

## Purpose

This plugin enables interaction with MerkleTrade within the elizaOS ecosystem.

## Configuration

The plugin requires the following environment variables:

Merkle Configuration

```env
MERKLE_TRADE_NETWORK=               # Must be one of mainnet, testnet
MERKLE_TRADE_APTOS_PRIVATE_KEY=     # Aptos private key
```

## Installation

```json
{
  "plugins": ["@elizaos/plugin-merkle"]
}
```

## Integration

The plugin responds to natural language commands related to MerkleTrade operations.

## Example Usage

```bash
You: "Open a BTC Long position on the Merkle Trade platform with 1000 pay and 10 leverage."
Agent: "Successfully market order BTC with 1000 pay and 10 leverage, Transaction: 0x104af5d1a786a2e1a4721a721b2cfccc7e15fa41eec15a489ba1768790adb523"
```

## Links

- [Merkle Documentation](https://docs.merkle.trade/)
- [Aptos Documentation](https://aptos.dev/)
- [Move Language Guide](https://move-language.github.io/move/)
`````

## File: packages/docs/static/packages/plugins/messari-ai-toolkit.md
`````markdown
# @elizaos/plugin-messari-ai-toolkit

## Purpose

A powerful Eliza OS plugin that integrates Messari's AI Toolkit to provide advanced crypto market research capabilities to your Eliza agent.

## Key Features

- Seamless integration with Messari's AI-Toolkit `/chat/completions` API
- Intelligent detection of crypto-related research questions
- Real-time market data and asset metrics analysis
- Access to consolidated news summarizations
- Asset due diligence insights
- Fundraising and investment data visualization capabilities

## Installation

For Main Eliza Repository:

```bash
bun --filter agent add github:messari/plugin-messari-ai-toolkit
```

For Eliza Starter:

```bash
bun add github:messari/plugin-messari-ai-toolkit
```

## Configuration

Requires a Messari API key with:

1. An Enterprise (ENT) subscription
2. Purchase of the AI Toolkit service package + credits
3. API key generation through Messari Account Settings

## Integration

Import and register the plugin with your Eliza agent. It automatically detects relevant research questions and queries Messari's AI Toolkit for comprehensive answers.

## Links

https://github.com/messari/plugin-messari-ai-toolkit/blob/master/.github/assets/eliza-tutorial.mp4
https://docs.messari.io/reference/chat-completion
`````

## File: packages/docs/static/packages/plugins/mina.md
`````markdown
# @elizaos/plugin-mina

## Purpose

Core Mina blockchain plugin for Eliza OS that provides essential services and actions for token operations and wallet management.

## Key Features

- Transfer MINA tokens between wallets
- Query wallet balances and portfolio values
- Track token prices and valuations
- Manage wallet interactions with the Mina network
- Cache token prices for performance optimization
- Get faucet tokens for testing purposes
- Get balances for wallets

## Installation

```bash
npm install @elizaos/plugin-mina
```

## Configuration

The plugin requires the following environment variables:

```env
MINA_PRIVATE_KEY=your_private_key
MINA_NETWORK=mainnet|devnet
```

## Integration

Import and register the plugin in your Eliza configuration:

```typescript
import { minaPlugin } from '@elizaos/plugin-mina';

export default {
  plugins: [minaPlugin],
  // ... other configuration
};
```

## Example Usage

Send tokens:

```typescript
User: 'Send 1 MINA to B62qkGSBuLmqYApYoWTmAzUtwFVx6Fe9ZStJVPzCwLjWZ5NQDYTiqEU';
Assistant: "I'll send 1 MINA token now...";
```

Check wallet balance:

```typescript
User: "What's my wallet balance?";
Assistant: 'Your wallet contains 299 MINA ($150 USD)...';
```

## Links

- [Mina Documentation](https://docs.minaprotocol.com/)
- [Mina Network Dashboard](https://minascan.io/)
- [Mina GitHub Repository](https://github.com/MinaProtocol/mina)
`````

## File: packages/docs/static/packages/plugins/mind-network.md
`````markdown
# @elizaos/plugin-mind-network

## Purpose

A plugin for interacting with Mind Network Hubs within the Eliza ecosystem, allowing CitizenZ and communities to secure trust in their agents' operation and decisioning.

## Key Features

- Web3 Wallet integration
- Voter Registration for Mind Network Hubs
- FHE Encryption for privacy-preserving voting
- Submit Encrypted Votes
- Reward Tracking for voting contributions

## Installation

```bash
bun install @elizaos/plugin-mind-network
```

## Configuration

Environment variables required:

```bash
MIND_HOT_WALLET_PRIVATE_KEY=<Hot wallet private key to vote>
MIND_COLD_WALLET_ADDRESS=<Cold wallet address to receive rewards>
```

## Integration

Integrates with ElizaOS characters for conversational interactions, enabling users to register as voters, check rewards, encrypt votes using FHE, and submit votes through natural language prompts.

## Example Usage

Sample conversation flow showing registration, reward checking, vote encryption, and vote submission through conversational AI interaction.

## Links

- [Mind Network](https://www.mindnetwork.xyz/)
- [Randgen Hub](https://dapp.mindnetwork.xyz/votetoearn/voteonhubs/3)
- [Discord Support](https://discord.com/invite/UYj94MJdGJ)
- [Twitter](https://x.com/mindnetwork_xyz)
`````

## File: packages/docs/static/packages/plugins/moralis.md
`````markdown
# @elizaos/plugin-moralis

## Purpose

A plugin for interacting with Moralis APIs to fetch various blockchain data across different chains, currently supporting Solana chain endpoints.

## Key Features

- Fetch Solana trading pairs for specific tokens
- Get detailed statistics for Solana trading pairs
- Access aggregated token statistics across all pairs
- Retrieve price history (OHLCV) data
- Get current token prices
- Fetch comprehensive token metadata

## Installation

```bash
bun install @elizaos/plugin-moralis
```

## Configuration

| Variable Name     | Description          |
| ----------------- | -------------------- |
| `MORALIS_API_KEY` | Your Moralis API key |

## Integration

Import and initialize the plugin using:

```typescript
import { moralisPlugin } from '@elizaos/plugin-moralis';
const plugin = moralisPlugin;
```

## Example Usage

- "Get all Solana trading pairs for token So11111111111111111111111111111111111111112"
- "Get stats for Solana pair A8nPhpCJqtqHdqUk35Uj9Hy2YsGXFkCZGuNwvkD3k7VC"
- "Get aggregated stats for Solana token SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"
- "Get hourly candlestick prices for Solana pair A8nPhpCJqtqHdqUk35Uj9Hy2YsGXFkCZGuNwvkD3k7VC"
- "Get current price of Solana token 6Rwcmkz9yiYVM5EzyMcr4JsQPGEAWhcUt"
- "What's the FDV and supply for SRM token?"

## Links

License: MIT
`````

## File: packages/docs/static/packages/plugins/movement.md
`````markdown
# @elizaos/plugin-movement

## Purpose

Movement Network plugin for Eliza OS that enables Movement Network blockchain functionality for your Eliza agent.

## Key Features

- Send MOVE tokens
- Check wallet balances
- Support for Movement Network transactions

## Installation

```bash
bun add @elizaos/plugin-movement
```

## Configuration

Add the Movement plugin to your character's configuration:

```json
{
  "name": "Movement Agent",
  "plugins": ["@elizaos/plugin-movement"],
  "settings": {
    "secrets": {
      "MOVEMENT_PRIVATE_KEY": "your_private_key_here",
      "MOVEMENT_NETWORK": "bardock"
    }
  }
}
```

Set up environment variables in `.env` file:

```bash
MOVEMENT_PRIVATE_KEY=your_private_key_here
MOVEMENT_NETWORK=bardock
```

## Integration

Enables Movement Network blockchain functionality for your Eliza agent.
`````

## File: packages/docs/static/packages/plugins/multichain.md
`````markdown
# @elizaos/plugin-multichain

## Purpose

Cross-chain integration plugin for Eliza OS that enables seamless token transfers and swaps across multiple blockchain networks using Chain Signatures and NEAR Intents technologies.

## Key Features

- Cross-chain token transfers
- Multi-chain token swaps
- Support for major blockchain networks (Bitcoin, Ethereum, EVM chains, Cosmos ecosystem coming soon)
- Chain Signatures integration
- NEAR Intents for optimized execution
- Portfolio tracking across chains (coming soon)
- Comprehensive error handling

## Installation

```bash
bun install @elizaos/plugin-multichain
```

## Configuration

Requires environment variables for each supported chain including NEAR, Ethereum, and various EVM chains, plus global settings like DEFAULT_SLIPPAGE.

## Example Usage

### Multi-Chain Transfer

```typescript
const result = await eliza.execute({
  action: 'MULTI_CHAIN_TRANSFER',
  content: {
    chain: 'BTC',
    networkId: 'testnet',
    token: null, // Native BTC
    amount: '0.1',
    recipient: 'tb1qmw3xw3y8jtm4054w02kfz58tmf6pcse02twrh8',
  },
});
```

### Cross-Chain Swap

```typescript
const result = await eliza.execute({
  action: 'CROSS_CHAIN_SWAP',
  content: {
    sourceChain: 'ETH',
    targetChain: 'COSMOS',
    inputToken: 'ETH',
    outputToken: 'ATOM',
    amount: '1.0',
    recipient: 'cosmos1...',
  },
});
```
`````

## File: packages/docs/static/packages/plugins/multiversx.md
`````markdown
# @elizaos/plugin-multiversx

## Purpose

MultiversX blockchain integration plugin for Eliza OS that enables token management and transfers.

## Key Features

- EGLD and ESDT token transfers
- Token creation and management
- Multiple network support (mainnet, devnet, testnet)
- Secure transaction signing
- Automatic nonce management
- Transaction status tracking
- Built-in denomination handling
- Comprehensive error handling

## Installation

```bash
bun install @elizaos/plugin-multiversx
```

## Configuration

The plugin requires environment variables or runtime settings:

```env
MVX_PRIVATE_KEY=your-wallet-private-key
MVX_NETWORK=devnet  # mainnet, devnet, or testnet
ACCESS_TOKEN_MANAGEMENT_TO=everyone  # you can put an userid to limit token management to one user only
```

## Integration

Integrates with ElizaOS through standard action execution patterns, connecting to the MultiversX blockchain using their official SDK.

## Example Usage

```typescript
import { multiversxPlugin } from '@elizaos/plugin-multiversx';

// Send EGLD
const result = await eliza.execute({
  action: 'SEND_TOKEN',
  content: {
    tokenAddress: 'erd1...',
    amount: '1',
    tokenIdentifier: 'EGLD',
  },
});
```

## Links

- [MultiversX Documentation](https://docs.multiversx.com/)
- [MultiversX Developer Portal](https://docs.multiversx.com/developers/getting-started/introduction)
- [MultiversX GitHub Repository](https://github.com/multiversx/mx-sdk-js)
`````

## File: packages/docs/static/packages/plugins/near.md
`````markdown
# @elizaos/plugin-near

## Purpose

NEAR Protocol integration plugin for Eliza OS that enables token management, transfers, and swaps using Ref Finance.

## Key Features

- NEAR token transfers
- Token swaps via Ref Finance
- Multiple network support (mainnet, testnet)
- Secure transaction signing
- Automatic storage deposit handling
- Real-time price feeds
- Portfolio tracking and management
- Smart routing for optimal swaps
- Built-in denomination handling
- Comprehensive error handling

## Installation

```bash
bun install @elizaos/plugin-near
```

## Configuration

The plugin requires environment variables or runtime settings:

```env
NEAR_WALLET_SECRET_KEY=your-wallet-private-key
NEAR_WALLET_PUBLIC_KEY=your-wallet-public-key
NEAR_ADDRESS=your-account.near
NEAR_NETWORK=testnet  # mainnet or testnet
NEAR_RPC_URL=https://neart.lava.build
NEAR_SLIPPAGE=0.01  # 1% slippage tolerance
```

## Integration

The plugin integrates with ElizaOS through actions like `SEND_NEAR` and `EXECUTE_SWAP_NEAR` and provides wallet information through the wallet provider.

## Example Usage

```typescript
import { nearPlugin } from '@elizaos/plugin-near';

// Send NEAR
const result = await eliza.execute({
  action: 'SEND_NEAR',
  content: {
    recipient: 'bob.near',
    amount: '1.5',
  },
});
```

## Links

- [NEAR Documentation](https://docs.near.org/)
- [NEAR Developer Portal](https://near.org/developers)
- [NEAR Network Dashboard](https://nearscan.io/)
- [NEAR GitHub Repository](https://github.com/nearprotocol/near-api-js)
`````

## File: packages/docs/static/packages/plugins/news.md
`````markdown
# @elizaos/plugin-news

## Purpose

A plugin for fetching and handling real-time news data through NewsAPI integration.

## Key Features

- Fetch latest news articles from NewsAPI
- Search news by specific topics or keywords
- Get article summaries including titles, descriptions, and URLs
- Limit results to most recent and relevant content

## Installation

```bash
npm install @elizaos/plugin-news
```

## Configuration

The plugin requires the following environment variable:

```env
NEWS_API_KEY=your_newsapi_key  # Required for accessing NewsAPI
```

## Integration

Import and register the plugin in your Eliza configuration:

```typescript
import { newsPlugin } from '@elizaos/plugin-news';

export default {
  plugins: [newsPlugin],
  // ... other configuration
};
```

## Example Usage

The `CURRENT_NEWS` action responds to queries like:

- "what's the latest news about `searchTerm`?"
- "show me current events about `searchTerm`?"
- "what's going on in the world of `searchTerm`?"

Returns up to 5 recent articles with title, description, URL, and content preview.

## Links

- [NewsAPI](https://newsapi.org/)
- [Agent Dev School Part 2](https://www.youtube.com/watch?v=XenGeAcPAQo)
`````

## File: packages/docs/static/packages/plugins/nft-collections.md
`````markdown
# NFT Collections Plugin

## Purpose

A powerful plugin for interacting with NFT collections, providing comprehensive market data, social analytics, and trading capabilities through various APIs including Reservoir, CoinGecko, and more.

## Key Features

- Real-time NFT collection data and market stats
- Floor prices, volume, and market cap tracking
- Collection activity monitoring
- Token-level data and attributes
- Collection statistics and rankings
- Market intelligence for 420+ verified collections
- Social analytics with sentiment analysis
- ML-powered price predictions
- GraphQL and WebSocket support

## Installation

```bash
bun add @elizaos/plugin-nft-collections
```

## Configuration

### Required:

```env
RESERVOIR_API_KEY=your-reservoir-api-key
```

### Optional:

```typescript
const plugin = new NFTCollectionsPlugin({
  caching: {
    enabled: true,
    ttl: 3600000, // 1 hour
    maxSize: 1000,
  },
  security: {
    rateLimit: {
      enabled: true,
      maxRequests: 100,
      windowMs: 60000,
    },
  },
  maxConcurrent: 5,
  maxRetries: 3,
  batchSize: 20,
});
```

## Integration

The plugin connects with ElizaOS through GraphQL, WebSocket real-time updates, and IPFS integration. It provides webhooks, ML-powered analytics, and supports authentication, security features, and trading agents.

## Example Usage

```typescript
// Get top collections with optimized batch processing
const collections = await nftService.getTopCollections();

// Get market intelligence with caching
const intelligence = await marketIntelligenceService.getMarketIntelligence('0x1234');

// Get social metrics with rate limiting
const metrics = await socialAnalyticsService.getSocialMetrics('0x1234');
```
`````

## File: packages/docs/static/packages/plugins/nft-generation.md
`````markdown
# @elizaos/plugin-nft-generation

## Purpose

NFT collection generation plugin for Eliza OS that enables NFT creation, collection management, and verification on the Solana blockchain.

## Key Features

- Automated NFT collection creation
- AI-powered image generation for NFTs
- Collection logo generation
- Metadata creation and management
- AWS S3 integration for asset storage
- Solana blockchain integration
- NFT verification system
- Automatic nonce management
- Comprehensive error handling

## Installation

```bash
bun install @elizaos/plugin-nft-generation
```

## Configuration

Requires environment variables for:

- Solana Configuration (keys, cluster settings)
- AWS Configuration (access keys, region, bucket)

## Integration

Provides REST API endpoints for NFT operations and exposes handlers for collection creation, NFT minting, and verification that integrate with ElizaOS runtime.

## Example Usage

```typescript
import { createCollection, createNFT, verifyNFT } from './handlers';

const runtime = initializeRuntime();

(async () => {
  // Step 1: Create Collection
  const collectionResult = await createCollection({
    runtime,
    collectionName: 'MyUniqueCollection',
  });

  // Step 2: Create an NFT in the Collection
  const nftResult = await createNFT({
    runtime,
    collectionName: 'MyUniqueCollection',
    collectionAddress: collectionResult.address,
    collectionAdminPublicKey: collectionResult.collectionInfo.adminPublicKey,
    collectionFee: 0.01,
    tokenId: 1,
  });

  // Step 3: Verify the NFT
  const verificationResult = await verifyNFT({
    runtime,
    collectionAddress: collectionResult.address,
    NFTAddress: nftResult.address,
  });
})();
```

## Links

- [Solana Documentation](https://docs.solana.com/)
- [Solana Developer Portal](https://solana.com/developers)
- [Solana Network Dashboard](https://solscan.io/)
- [Solana GitHub Repository](https://github.com/solana-labs/solana)
`````

## File: packages/docs/static/packages/plugins/nkn.md
`````markdown
# plugin-nkn

## Purpose

Integrates NKN to enable communication between multiple AI agents or users within the Eliza framework.

## Key Features

- Supports sending and receiving messages via a decentralized network
- Ensures low latency and secure transmission

## Integration

Leverages the NKN protocol to facilitate messaging and communication between various AI agents and users within the Eliza framework.

## Links

https://nkn.org/
`````

## File: packages/docs/static/packages/plugins/node.md
`````markdown
# @elizaos/plugin-node

## Purpose

Core Node.js plugin for Eliza OS that provides essential services and actions for file operations, media processing, and cloud integrations.

## Key Features

- AWS S3 Integration
- Browser Automation
- Image Processing
- PDF Processing
- Speech Synthesis
- Transcription
- Video Processing
- LLaMA Integration

## Installation

```bash
npm install @elizaos/plugin-node
```

## Configuration

Requires various environment variables depending on services used, including:

- Core Settings: OPENAI_API_KEY
- Voice Settings: ELEVENLABS_XI_API_KEY, ELEVENLABS_MODEL_ID, etc.
- AWS Settings: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, etc.

## Integration

The plugin connects to ElizaOS through registration:

```typescript
import { createNodePlugin } from '@elizaos/plugin-node';
const nodePlugin = createNodePlugin();
elizaos.registerPlugin(nodePlugin);
```

## Example Usage

```typescript
const result = await runtime.executeAction('DESCRIBE_IMAGE', {
  imageUrl: 'path/to/image.jpg',
});
```

## Links

- https://github.com/elizaos-plugins/plugin-pdf
- https://github.com/elizaos-plugins/plugin-llama
- https://github.com/elizaos-plugins/plugin-image
- https://github.com/elizaos-plugins/plugin-aws-s3
- https://github.com/elizaos-plugins/plugin-browser
- https://github.com/elizaos-plugins/plugin-speech-tts
`````

## File: packages/docs/static/packages/plugins/nvidia-nim.md
`````markdown
# NVIDIA NIM Plugin

## Purpose

This plugin provides integration with NVIDIA AI Foundation Models through various specialized actions for content analysis and safety checks.

## Installation

1. Create a free account at [NVIDIA AI Foundation Models](https://build.nvidia.com/models)
2. Generate required API keys: `NVIDIA_NIM_API_KEY` and `NVIDIA_NGC_API_KEY`
3. Create a `.env` file with necessary configurations

## Key Features

- AI Image Detection: Analyzes if images are AI-generated
- Cosmos Vision Analysis: Analyzes images and videos using multimodal vision-language model
- DeepFake Detection: Detects manipulation in images, focusing on facial modifications
- Jailbreak Detection: Analyzes prompts for attempts to bypass AI safety measures
- Content Safety Analysis: Evaluates messages for safety and policy compliance
- Topic Control: Determines if messages stay within defined topical boundaries

## Example Usage

Test prompts are provided for each feature, including AI image detection, deepfake detection, cosmos vision analysis, topic control, and content safety checks.
`````

## File: packages/docs/static/packages/plugins/obsidian.md
`````markdown
# @elizaos/plugin-obsidian

## Purpose

An Obsidian plugin for ELIZA OS that provides seamless integration with Obsidian vaults, enabling powerful file and note management capabilities.

## Key Features

1. Deep traversal of Obsidian notes
2. Advanced search functionality
3. Obsidian memory store integration
4. Naval database integration as an example

## Installation

```bash
npm install @elizaos/plugin-obsidian
# or
yarn add @elizaos/plugin-obsidian
# or
bun add @elizaos/plugin-obsidian
```

## Configuration

Requires character secret settings:

```json
{
  "settings": {
    "secrets": {
      "OBSIDIAN_API_TOKEN": "your-obsidian-api-token",
      "OBSIDIAN_API_PORT": "your-obsidian-api-port", // Optional (default: 27123)
      "OBSIDIAN_API_URL": "https://your-obsidian-api-url" // Optional (default: "http://127.0.0.1:27123")
    }
  }
}
```

## Integration

Import and register the plugin in your Eliza agent configuration:

```typescript
import { obsidianPlugin } from '@elizaos/plugin-obsidian';

export default {
  plugins: [getSecret(character, 'OBSIDIAN_API_TOKEN') ? obsidianPlugin : null],
};
```

## Example Usage

```typescript
// List all files
const files = await obsidian.listFiles();

// Get a note with its content
const note = await obsidian.getNote('path/to/note.md');

// Search in vault
const results = await obsidian.search('query');

// Create or update a file
await obsidian.saveFile('DOCUMENTS/report.txt', 'Content', true);
```

## Links

- Documentation: https://elizaos.github.io/eliza/
- Discord: https://discord.gg/elizaos
`````

## File: packages/docs/static/packages/plugins/okto.md
`````markdown
# @okto_web3/eliza-plugin

## Purpose

A comprehensive integration plugin for ElizaOS that provides access to Okto's APIs and services, enabling seamless Web3 interactions.

## Key Features

- Portfolio Management (user portfolio data, NFT details, token holdings)
- Wallet Management (access wallets, view addresses)
- Token Operations (transfer tokens, swap tokens, execute transactions)
- NFT Operations (view collections, transfer NFTs, track balances)
- Chain Support (multiple networks including Ethereum, Polygon, Solana, etc.)
- Transaction History (view order history across networks)

## Installation

```bash
npm install @okto_web3/eliza-plugin
```

## Configuration

Requires environment variables:

- OKTO_ENVIRONMENT (defaults to "sandbox")
- OKTO_CLIENT_PRIVATE_KEY (required)
- OKTO_CLIENT_SWA (required)
- GOOGLE_CLIENT_ID (required)
- GOOGLE_CLIENT_SECRET (required)

## Integration

Import and initialize the plugin, then add it to AgentRuntime's plugins array and include oktoPlugin.oktoService in services.

## Example Usage

Available actions include OKTO_GET_PORTFOLIO, OKTO_GET_ACCOUNT, OKTO_TRANSFER, OKTO_SWAP, and others for managing tokens, NFTs, and viewing blockchain data.

## Links

[Okto Eliza Plugin Documentation](https://docsv2.okto.tech/docs/okto-eliza-plugin)
`````

## File: packages/docs/static/packages/plugins/omniflix.md
`````markdown
# @elizaos/plugin-omniflix

## Purpose

A plugin for ElizaOS that enables interaction with the OmniFlix Network blockchain.

## Installation

```bash
npm install @elizaos/plugin-omniflix
```

## Configuration

### Environment Variables

```env
# Required: RPC endpoint for OmniFlix Network
OMNIFLIX_RPC_ENDPOINT="https://rpc.omniflix.network:443"

# Required: API endpoint for OmniFlix Network
OMNIFLIX_API_URL="https://rest.omniflix.network"

# Required: Either mnemonic or private key (one is required)
OMNIFLIX_MNEMONIC="your mnemonic"
# OR
OMNIFLIX_PRIVATE_KEY="your hex private key"
```

Network configurations are available for both Mainnet and Testnet.

## Key Features

1. Bank Operations

   - Check Balance
   - Send Tokens
   - Check Staked Balance

2. Staking Operations

   - Delegate Tokens
   - Undelegate Tokens
   - Redelegate Tokens
   - Cancel Unbonding

3. Governance Operations
   - Vote on Proposals (yes, no, abstain, no_with_veto)

## Integration

1. Import the plugin:

```typescript
import { OmniflixPlugin } from '@elizaos/plugin-omniflix';
```

2. Register with ElizaOS:

```typescript
import { Eliza } from '@elizaos/core';

const eliza = new Eliza();
eliza.registerPlugin(OmniflixPlugin);
```

## Example Usage

```typescript
import { voteOnProposal } from '@elizaos/plugin-omniflix';

// Vote on a proposal
const voteOnProposal = await voteOnProposal(
  {
    proposalId: '1',
    vote: 'YES',
  },
  {
    apiEndpoint: 'https://rest.omniflix.network',
    rpcEndpoint: 'https://rpc.omniflix.network:443',
  }
);
```
`````

## File: packages/docs/static/packages/plugins/opacity.md
`````markdown
# @elizaos/adapter-opacity

## Purpose

This adapter integrates Opacity proofs into ElizaOS, enabling verifiable inference results from AI model providers through the CloudFlare AI Gateway.

## Key Features

- Implements `IVerifiableInferenceAdapter` interface for standardized verifiable inference
- Support for multiple AI model providers
- Customizable options for each request
- Built-in proof verification

## Installation

```bash
bun add @elizaos/adapter-opacity
```

## Configuration

Add environment variables to your `.env` file:

```env
OPACITY_TEAM_ID=f309ac8ae8a9a14a7e62cd1a521b1c5f
OPACITY_CLOUDFLARE_NAME=eigen-test
OPACITY_PROVER_URL=https://opacity-ai-zktls-demo.vercel.app
VERIFIABLE_INFERENCE_ENABLED=true
VERIFIABLE_INFERENCE_PROVIDER=opacity
```

## Integration

The adapter wraps AI model API calls to CloudFlare, performs MPC-TLS on logged responses, enabling verifiable API calls, proof generation, and verification of response authenticity.

## Example Usage

```typescript
import { OpacityAdapter } from '@elizaos/adapter-opacity';
import { VerifiableInferenceOptions } from '@elizaos/core';

// Initialize the adapter
const opacityAdapter = new OpacityAdapter(runtime, {
  teamId: process.env.OPACITY_TEAM_ID,
  teamName: process.env.OPACITY_CLOUDFLARE_NAME,
  baseUrl: process.env.OPACITY_PROVER_URL,
});

// Generate text with verifiable results
const result = await opacityAdapter.generateText('What is Rust?', 'gpt-4', options);

// Verify the proof
const isValid = await opacityAdapter.verifyProof(result);
```

## Links

MIT License
`````

## File: packages/docs/static/packages/plugins/open-weather.md
`````markdown
# @elizaos/plugin-open-weather

## Purpose

A plugin for Eliza that enables weather checking using the OpenWeather API.

## Key Features

- Weather & temperature check for any specified city
- Supports temperatures, weather descriptions, wind speed, with possible add-ons for full API response

## Installation

```bash
npm install @elizaos/plugin-open-weather
```

## Configuration

1. Get your API key from OpenWeather
2. Set up environment variable: OPEN_WEATHER_API_KEY=your_api_key
3. Register the plugin in Eliza configuration:

```typescript
import { openWeatherPlugin } from '@elizaos/plugin-open-weather';

// In your Eliza configuration
plugins: [
  new openWeatherPlugin(),
  // ... other plugins
];
```

## Integration

The plugin responds to natural language queries about weather in specified cities and provides the GET_CURRENT_WEATHER action.

## Example Usage

```plaintext
"What's the current weather in London?"
"Show me weather in New York"
"Get the weather in Tokyo"
"What's the weather like?"
```

## Links

- [OpenWeather weather API Documentation](https://openweathermap.org/current)
`````

## File: packages/docs/static/packages/plugins/openai.md
`````markdown
# @elizaos/plugin-openai

## Purpose

A plugin for OpenAI integration, providing automated text generation capabilities.

## Key Features

- Generate text using OpenAI's GPT models
- Customize prompts for context-aware content generation

## Installation

```bash
npm install @elizaos/plugin-openai
```

## Configuration

The plugin requires the following environment variable:

```env
OPENAI_API_KEY=your_openai_api_key
```

## Integration

Import and register the plugin in your Eliza configuration:

```typescript
import { openaiPlugin } from '@elizaos/plugin-openai';

export default {
  plugins: [openaiPlugin],
  // ... other configuration
};
```

## Example Usage

```typescript
const result = await generateTextAction.handler(runtime, message, state);
console.log(result.text); // Output generated by OpenAI
```
`````

## File: packages/docs/static/packages/plugins/para.md
`````markdown
# @elizaos/plugin-para

## Purpose

A seamless integration between Para wallet infrastructure and Eliza OS, enabling autonomous agents to manage user wallets and transactions.

## Key Features

- 🔐 Full Para wallet integration with Eliza agents
- 💰 EVM-based transaction support using Viem
- 📝 Message signing capabilities
- 💼 Pre-generated wallet support
- 🔄 Seamless wallet claiming process
- 🛡️ Secure user share management
- 🌐 Multi-chain support (Ethereum, Polygon, Arbitrum, etc.)
- 📋 Built-in wallet status monitoring
- 🤖 Auto-configuration with Eliza agents
- 📱 Session management for persistent authentication

## Installation

```bash
# npm
npm install @elizaos/plugin-para

# bun
bun add @elizaos/plugin-para

# yarn
yarn add @elizaos/plugin-para

# bun
bun add @elizaos/plugin-para
```

## Configuration

1. Add required environment variables to your `.env` file
2. Register the plugin in your Eliza character configuration

## Integration

The plugin adds wallet creation, message signing, transaction signing, and wallet claiming capabilities to Eliza agents through actions, providers, and services.

## Example Usage

```typescript
// Creating wallets
await runtime.triggerAction('CREATE_PARA_WALLET', {
  type: 'EVM',
});

// Signing messages
await runtime.triggerAction('SIGN_PARA_MESSAGE', {
  walletId: 'wallet-id',
  message: 'Hello, World!',
});
```

## Links

- [Eliza Documentation](https://elizaos.github.io/eliza/)
- [Para Documentation](https://docs.getpara.com/)
- [Plugin Examples](https://github.com/elizaos/eliza/tree/main/examples/plugins)
- [Viem Documentation](https://viem.sh/)
`````

## File: packages/docs/static/packages/plugins/pdf.md
`````markdown
# @elizaos/plugin-pdf

## Purpose

Core Node.js plugin for Eliza OS that provides essential services and actions for file operations, specifically focused on PDF processing.

## Key Features

- PDF text extraction and parsing

## Integration

Serves as a foundational component of Eliza OS, bridging core Node.js capabilities with the Eliza ecosystem.

## Services

- PdfService: Extracts and processes text content from PDF files
`````

## File: packages/docs/static/packages/plugins/primus.md
`````markdown
# @elizaos/plugin-primus

## Purpose

A plugin to fully verify agent activities, including LLM access, actions, and interactions with external providers, powered by Primus' zkTLS protocol.

## Key Features

- Verification of inference from OpenAI's LLM
- Example for verifying actions (like posting tweets)
- Example to verify Bitcoin price fetched from Binance

## Installation

```bash
bun add @elizaos/plugin-primus
```

## Configuration

Add to .env file:

```
PRIMUS_APP_ID=your_app_id
PRIMUS_APP_SECRET=your_app_secret
VERIFIABLE_INFERENCE_ENABLED=true
VERIFIABLE_INFERENCE_PROVIDER=primus
```

Get credentials by:

1. Visit the Primus Developer Hub
2. Create a new project
3. Save Application ID and Secret Key

Add plugin to character file:

```json
{
  "plugins": ["@elizaos/plugin-primus"]
}
```

## Integration

Implements `IVerifiableInferenceAdapter` through the `PrimusAdapter` class for verification of LLM interactions, actions, and provider data.

## Example Usage

- LLM inference verification using PrimusAdapter
- Verify BTC price from Binance
- Post verified tweets with price information

## Links

[Primus Developer Hub](https://dev.primuslabs.xyz/)
`````

## File: packages/docs/static/packages/plugins/pyth-data.md
`````markdown
# Pyth Data Plugin for ElizaOS

## Purpose

A powerful plugin for interacting with Pyth Network price feeds and data streams, providing real-time access to cryptocurrency, forex, and other asset price data through a natural language interface.

## Key Features

- Real-time price feed streaming
- Latest price updates retrieval
- Publisher caps information
- Comprehensive price feed listings
- Natural language processing for price feed queries
- Automatic Price ID Detection
- Flexible Data Formats
- Granular Logging
- Error Handling
- Streaming Control

## Configuration

Requires a `.env` file with network configuration (mainnet or testnet), connection settings, runtime settings, and test price feed IDs. Configuration controls network endpoints, streaming behavior, retry logic, and logging.

## Integration

Connects with ElizaOS through a natural language interface allowing users to request real-time price data, updates, and information about available feeds.

## Example Usage

- "Stream BTC/USD price updates"
- "Latest price updates for [price feed ID]"
- "Get me all the published caps"
- "List all crypto price feeds"
`````

## File: packages/docs/static/packages/plugins/quai.md
`````markdown
# @elizaos/plugin-quai

## Purpose

Quai Network integration plugin for Eliza OS that enables native token transfers and interactions with the Quai blockchain.

## Key Features

- Native QUAI token transfers
- Multiple network support
- Secure transaction signing
- Comprehensive error handling
- Built-in address validation
- Automatic gas estimation
- Real-time transaction status

## Installation

```bash
bun install @elizaos/plugin-quai
```

## Configuration

The plugin requires the following environment variables:

```env
QUAI_PRIVATE_KEY=your-private-key
QUAI_RPC_URL=https://rpc.quai.network  # or your preferred RPC endpoint
```

## Integration

The plugin provides core functionality for interacting with the Quai Network through a simple interface, enabling token transfers and blockchain interactions in ElizaOS.

## Example Usage

```typescript
import { quaiPlugin } from '@elizaos/plugin-quai';

// Send QUAI
const result = await eliza.execute({
  action: 'SEND_TOKEN',
  content: {
    recipient: '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',
    amount: '10',
  },
});
```

## Links

- [Quai Network](https://qu.ai/)
- [Quai Documentation](https://docs.qu.ai/)
- [Quai Network GitHub](https://github.com/dominant-strategies)
`````

## File: packages/docs/static/packages/plugins/quick-intel.md
`````markdown
# @elizaos/plugin-quickintel

## Purpose

A plugin for performing token security audits and market analysis within the ElizaOS ecosystem.

## Key Features

- Multi-chain support (EVM chains, Solana, etc.)
- Comprehensive security analysis
- Market data integration
- Natural language responses
- Detailed risk assessments

## Installation

```bash
bun install @elizaos/plugin-quickintel
```

## Configuration

### Environment Variables

```typescript
QUICKINTEL_API_KEY=<Your QuickIntel API Key>
```

### Client Configuration

Add the plugin to your character.json file:

```json
{
  "name": "YourCharacter",
  "plugins": ["quickintel"],
  "settings": {
    "QUICKINTEL_API_KEY": "your-api-key-here"
  }
}
```

## Integration

Processes natural language queries for token audits across multiple chains, combining QuickIntel's API for security analysis with market data from DexScreener.

## Example Usage

```typescript
'Can you check if this token is safe? 0x742d35Cc6634C0532925a3b844Bc454e4438f44e on BSC';
'Analyze this token on Ethereum: 0x1234...';
'Is this Solana token safe? Hep4ZQ3MSSXFuLnT4baBFVBrC3677ntjrfaqE9zEt4rX';
```

## Links

https://docs.quickintel.io/quick-intel-scanner/supported-chains
`````

## File: packages/docs/static/packages/plugins/rabbit-trader.md
`````markdown
# Rabbi Trader Plugin

## Purpose

An automated cryptocurrency trading plugin for Solana tokens with integrated trust scoring, market analysis, and Twitter notifications.

## Key Features

- Automated trading on Solana blockchain
- Real-time market data analysis using DexScreener
- Trust score evaluation for tokens
- Twitter integration for trade notifications
- Safety limits and risk management
- Simulation capabilities before executing trades
- Performance tracking and trade history
- Rate limiting and cache management

## Installation

```bash
npm install @elizaos/plugin-rabbi-trader
```

## Prerequisites

The following environment variables need to be configured:

- `WALLET_PRIVATE_KEY`: Your Solana wallet private key
- `WALLET_PUBLIC_KEY`: Your Solana wallet public address
- `SOLANA_RPC_URL`: Solana RPC endpoint (defaults to mainnet)
- `BIRDEYE_API_KEY`: API key for Birdeye data provider
- `TWITTER_ENABLED`: Enable/disable Twitter notifications
- `TWITTER_USERNAME`: Twitter username for notifications
- `DEXSCREENER_WATCHLIST_ID`: DexScreener watchlist identifier
- `COINGECKO_API_KEY`: CoinGecko API key for additional market data

## Configuration

Safety limits and trading parameters can be configured, including minimum trade amounts, maximum position size, slippage limits, trust scores, stop loss, take profit settings, check intervals, and position limits.

## Integration

The plugin integrates with multiple APIs including Birdeye API, DexScreener, Twitter, and Jupiter for token swaps.

## Example Usage

```typescript
import createRabbiTraderPlugin from '@elizaos/plugin-rabbi-trader';
import { IAgentRuntime } from '@elizaos/core';

const plugin = await createRabbiTraderPlugin((key: string) => process.env[key], runtime);

// Plugin will automatically start monitoring and trading if enabled
```
`````

## File: packages/docs/static/packages/plugins/router-nitro.md
`````markdown
# @elizaos/plugin-router-nitro

## Purpose

The Router Nitro plugin enables seamless cross-chain token transfers and wallet management across blockchains within the ElizaOS ecosystem.

## Key Features

- Cross-chain token transfers
- Wallet management across blockchains
- Efficient bridging of tokens
- Monitoring wallet balances
- Real-time transaction processing
- Price tracking

## Installation

```bash
bun install @elizaos/plugin-router-nitro
```

## Configuration

The plugin requires the following environment variables:

```typescript
ROUTER_NITRO_EVM_PRIVATE_KEY=<Your EVM-compatible private key>
ROUTER_NITRO_EVM_ADDRESS=<Router Nitro EVM bridge address>
```

## Integration

Import the plugin into ElizaOS:

```typescript
import { nitroPlugin } from '@elizaos/plugin-router-nitro';
```

## Example Usage

The plugin responds to natural language commands like:

- 'Bridge 50 USDC from Ethereum to Polygon on address 0xCCa8009f5e09F8C5dB63cb0031052F9CB635Af62'
- 'Send 1 ETH from Arb to Base'
`````

## File: packages/docs/static/packages/plugins/sei.md
`````markdown
# @elizaos/plugin-sei

## Purpose

Sei Network plugin for Eliza OS that enables Eliza agents to perform actions on the Sei blockchain.

## Key Features

- Transfer SEI tokens to other `0x` or `sei` addresses
- Query wallet balances

## Installation

```bash
bun install @elizaos/plugin-sei
```

## Configuration

The plugin requires the following environment variables:

```env
SEI_PRIVATE_KEY= #your_private_key
SEI_NETWORK= #"mainnet","testnet", or "devnet"
```

## Integration

Import and register the plugin in your Eliza configuration:

```typescript
import { seiPlugin } from '@elizaos/plugin-sei';

export default {
  plugins: [seiPlugin],
  // ... other configuration
};
```

## Example Usage

Send Token:

```typescript
User: 'Send 1 SEI to 0xD5ca6eA5e33606554F746606157a7512FA738A12';
Assistant: "I'll send 1 SEI token now...";
```

Check Wallet Balance:

```typescript
User: "What's my wallet balance?";
Assistant: 'Your wallet contains 10.5 SEI ($5.25 USD)...';
```

## Links

[Sei Blockchain](https://sei.io/): The fastest EVM blockchain
`````

## File: packages/docs/static/packages/plugins/sgx.md
`````markdown
# SGX Plugin for Eliza

## Purpose

The SGX Plugin for Eliza enhances the platform by providing Intel SGX attestation capabilities within trusted execution environments (TEEs).

## Key Features

- Intel SGX attestation for confidential computing
- Supports Trusted Execution Environment (TEE) implementation
- Integration with Gramine Library OS for unmodified applications
- SGX remote attestation generation

## Components

- **sgxAttestationProvider**: Responsible for generating SGX remote attestations within Gramine SGX environments

## Integration

The provider `sgxAttestationProvider` is registered into Eliza through plugin-sgx when the environment variable `SGX` is set to `1`.

## Example Usage

```typescript
const sgxAttestationProvider = new SgxAttestationProvider();
const sgxAttestation = await sgxAttestationProvider.generateAttestation(userReport);
```

## Quick Start

```bash
# Start Eliza in SGX with default character
SGX=1 make start
# Start with specific character
SGX=1 make start -- --character "character/trump.character.json"
```

## Links

[Gramine Library OS](https://github.com/gramineproject/gramine)
[Gramine installation options](https://gramine.readthedocs.io/en/latest/installation.html)
`````

## File: packages/docs/static/packages/plugins/solana-agent-kit.md
`````markdown
# @elizaos/plugin-solana-agent-kit

## Purpose

A plugin that integrates Solana Agent Kit functionality into Eliza, enabling token operations, swaps, lending, and staking on Solana.

## Installation

```bash
bun add @elizaos/plugin-solana-agent-kit
```

## Configuration

### Required Environment Variables

```env
# Required: Either private key or public key
SOLANA_PRIVATE_KEY=your_private_key
# OR
SOLANA_PUBLIC_KEY=your_public_key

# Optional: Custom RPC URL (defaults to mainnet)
SOLANA_RPC_URL=your_rpc_url

# Required for TEE mode
WALLET_SECRET_SALT=your_salt  # Only if TEE_MODE is enabled
```

## Features

- **Token Operations**: Create tokens, transfer tokens, get token information, manage token supply
- **DeFi Operations**: Swap tokens via Jupiter, lend assets, stake tokens, create GibWork tasks

## Example Usage

### Token Creation

```plaintext
"Create token, name is Example Token, symbol is EXMPL, decimals is 9"
```

### Token Transfers

```plaintext
"Send 69 EZSIS to <wallet_address>"
```

### Token Swaps

```plaintext
"Swap 0.1 SOL for USDC"
```

## Dependencies

- @coral-xyz/anchor: 0.30.1
- @solana/spl-token: 0.4.9
- @solana/web3.js: 1.95.8
- solana-agent-kit: ^1.2.0
- bignumber.js: 9.1.2

## Links

[solana-agent-kit documentation](https://github.com/solana-labs/agent-kit)
`````

## File: packages/docs/static/packages/plugins/solana-agentkit.md
`````markdown
# Plugin Solana AgentKit

## Purpose

A Solana integration plugin for AgentKit that enables interaction with the Solana blockchain.

## Key Features

- Solana wallet integration
- Transaction handling
- Account management
- RPC connection management
- Solana program interactions

## Integration

Connects with ElizaOS through the AgentKit framework to provide Solana blockchain functionality.
`````

## File: packages/docs/static/packages/plugins/solana-v2.md
`````markdown
# Solana Plugin V2 for Eliza

## Purpose

Leverages the latest features of `@solana/web3.js` v2 to provide a modern, efficient, and composable solution for Solana integrations within the Eliza AI agent framework.

## Key Features

- Modern JavaScript and functional architecture using `@solana/web3.js` v2
- Compatibility with existing solana V1 plugins
- Common utilities including optimized transaction sending
- Trusted Execution Environment (TEE) support

## Integration

- Works within the Eliza AI agent framework
- Must be added to the `AgentRuntime` in `agent/src/index.ts`

## Current Functionality

- Orca liquidity position management
  - Automatically repositions liquidity positions based on price deviation thresholds
  - Maintains original position width
  - Repositions at user-defined intervals
  - Uses configurable slippage tolerance

## Example Usage

1. Set up environment variables (SOLANA_PRIVATE_KEY, SOLANA_PUBLIC_KEY, SOLANA_RPC_URL, OPENAI_API_KEY)
2. Update agent to include the plugin
3. Use LP Manager character
4. Run agent with: `bun start --characters="characters/lpmanager.character.json"`
5. Access web interface at localhost:3000

## Links

- [Transaction optimization details](https://orca-so.github.io/whirlpools/Whirlpools%20SDKs/Whirlpools/Send%20Transaction)
- [Transaction landing information](https://www.helius.dev/blog/how-to-land-transactions-on-solana#how-do-i-land-transactions)
`````

## File: packages/docs/static/packages/plugins/solana.md
`````markdown
# @elizaos/plugin-solana

## Purpose

Core Solana blockchain plugin for Eliza OS that provides essential services and actions for token operations, trading, and DeFi integrations.

## Key Features

- Token Operations: Creation, transfers, balance management, portfolio analytics
- Trading Operations: Token swaps, order management, price monitoring, automated trading
- DeFi Integration: Liquidity analysis, market making, yield optimization, risk management
- Trust & Security: Trust scoring, risk assessment, performance tracking, simulation mode
- Security Features: Wallet management, permission scoping, TEE integration, trade limits

## Installation

```bash
npm install @elizaos/plugin-solana
```

## Configuration

```typescript
const solanaEnvSchema = {
  WALLET_SECRET_SALT: string(optional),
  WALLET_SECRET_KEY: string,
  WALLET_PUBLIC_KEY: string,
  SOL_ADDRESS: string,
  SLIPPAGE: string,
  SOLANA_RPC_URL: string,
  HELIUS_API_KEY: string,
  BIRDEYE_API_KEY: string,
};
```

## Integration

The plugin connects with ElizaOS through various services and actions, including TokenProvider, WalletProvider, and TrustScoreProvider, enabling token operations, swaps, transfers, and other Solana transactions.

## Example Usage

```typescript
import { solanaPlugin } from '@elizaos/plugin-solana';

// Initialize the plugin
const runtime = await initializeRuntime({
  plugins: [solanaPlugin],
});

// Execute a token swap
const result = await runtime.executeAction('EXECUTE_SWAP', {
  inputTokenSymbol: 'SOL',
  outputTokenSymbol: 'USDC',
  amount: 0.1,
});
```
`````

## File: packages/docs/static/packages/plugins/speech-tts.md
`````markdown
# service-speech-tts

## Purpose

TTS transcription service with OpenAI + ElevenLabs
`````

## File: packages/docs/static/packages/plugins/spheron.md
`````markdown
# Spheron Protocol Plugin for Eliza

## Purpose

This plugin integrates the Spheron Protocol SDK into the Eliza ecosystem, providing functionality for managing deployments, escrow operations, and lease management.

## Key Features

- **Escrow Operations**: Manage token deposits, withdrawals, and balance checks
- **Deployment Management**: Create, update, and manage deployments using ICL YAML

## Installation

```bash
npm install @elizaos/plugin-spheron
```

## Configuration

The plugin requires the following environment variables:

```env
PRIVATE_KEY=your_private_key
PROVIDER_PROXY_URL=your_provider_proxy_url
WALLET_ADDRESS=your_wallet_address
```

## Integration

Import and register the plugin with Eliza:

```typescript
import { spheronPlugin } from '@elizaos/plugin-spheron';
eliza.registerPlugin(spheronPlugin);
```

## Example Usage

### Escrow Operations:

```typescript
// Deposit tokens
await runtime.executeAction('ESCROW_OPERATION', {
  token: 'USDT',
  amount: 100,
  operation: 'deposit',
});
```

### Deployment Operations:

```typescript
// Create deployment
await runtime.executeAction('DEPLOYMENT_OPERATION', {
  operation: 'create',
  template: 'jupyter-notebook',
  customizations: {
    cpu: false,
    resources: {
      cpu: '4',
      memory: '8Gi',
      storage: '10Gi',
      gpu: '1',
      gpu_model: 'rtx4090',
    },
    duration: '1h',
    token: 'USDT',
  },
});
```
`````

## File: packages/docs/static/packages/plugins/squid-router.md
`````markdown
# @elizaos/squid-router

## Purpose

This plugin adds Squid Router functionality to Eliza agents, allowing cross chain swaps between blockchains.

## Configuration

The plugin requires the following configuration:

```
# Squid Router
SQUID_SDK_URL=https://apiplus.squidrouter.com # Default: https://apiplus.squidrouter.com
SQUID_INTEGRATOR_ID= # get integrator id through https://docs.squidrouter.com/
SQUID_EVM_ADDRESS=
SQUID_EVM_PRIVATE_KEY=
```

## Integration

It enables cross chain swaps between blockchains, currently supporting only swaps between EVM chains with plans to add Solana and Cosmos ecosystem in the future.

## Actions

### Cross Chain Swap

name: `X_CHAIN_SWAP`
Perform cross chain swaps for both native and ERC20 tokens supported by Squid Router.
Message sample: `Bridge 1 ETH from Ethereum to Base`

## Links

[Squid Router documentation](https://docs.squidrouter.com/)
`````

## File: packages/docs/static/packages/plugins/stargaze.md
`````markdown
# Plugin Stargaze

## Purpose

A plugin for fetching NFT data from the Stargaze API.

## Key Features

Provides a simple interface to get NFT data from Stargaze collections.

## Installation

```bash
bun add @elizaos/plugin-stargaze
```

## Configuration

Set up your environment with the required Stargaze API endpoint.

| Variable Name       | Description                   |
| ------------------- | ----------------------------- |
| `STARGAZE_ENDPOINT` | Stargaze GraphQL API endpoint |

## Integration

Integrates with Stargaze's GraphQL API to fetch the latest NFTs from collections.

## Example Usage

```typescript
import { stargazePlugin } from '@elizaos/plugin-stargaze';

// Initialize the plugin
const plugin = stargazePlugin;

// The plugin provides the GET_LATEST_NFT action which can be used to fetch NFTs
// Example: "Show me the latest NFT from ammelia collection"
```

## Links

License: MIT
`````

## File: packages/docs/static/packages/plugins/starknet.md
`````markdown
# @elizaos/plugin-starknet

## Purpose

Core Starknet blockchain plugin for Eliza OS that provides essential services and actions for token operations, trading, and DeFi integrations.

## Key Features

- **Token Operations**: Token creation, transfers, balance management, portfolio analytics
- **Trading Operations**: Token swaps, order management, price monitoring, trust score analysis
- **DeFi Integration**: Liquidity management, yield optimization, risk assessment, performance tracking

## Configuration

The plugin requires the following environment variables:

```typescript
STARKNET_ADDRESS = your_starknet_address;
STARKNET_PRIVATE_KEY = your_private_key;
STARKNET_RPC_URL = your_rpc_url; // e.g. https://rpc.starknet.lava.build
```

## Integration

Serves as a foundational component of Eliza OS, bridging Starknet blockchain capabilities with the Eliza ecosystem, enabling both automated and user-directed interactions.

## Example Usage

```typescript
// Deploy token
const result = await runtime.executeAction('DEPLOY_STARKNET_UNRUGGABLE_MEME_TOKEN', {
  name: 'TokenName',
  symbol: 'TKN',
  owner: 'OwnerAddressHere',
  initialSupply: '1000000000000000000',
});

// Transfer tokens
const result = await runtime.executeAction('TRANSFER_TOKEN', {
  tokenAddress: 'TokenAddressHere',
  recipient: 'RecipientAddressHere',
  amount: '1000',
});
```

## Links

- [Starknet Documentation](https://docs.starknet.io/)
- [Starknet Developer Portal](https://starknet.io/developers)
- [Starknet Network Dashboard](https://starknet.io/dashboard)
- [Starknet GitHub Repository](https://github.com/starkware-libs/starknet)
`````

## File: packages/docs/static/packages/plugins/sui.md
`````markdown
# @elizaos/plugin-sui

## Purpose

Core Sui blockchain plugin for Eliza OS that provides essential services and actions for token operations and wallet management.

## Key Features

- Transfer SUI tokens between wallets
- Query wallet balances and portfolio values
- Track token prices and valuations
- Manage wallet interactions with the Sui network

## Installation

```bash
npm install @elizaos/plugin-sui
```

## Configuration

Requires environment variables:

```env
SUI_PRIVATE_KEY=your_private_key
SUI_NETWORK=mainnet|testnet|devnet|localnet
```

## Integration

Import and register the plugin in Eliza configuration:

```typescript
import { suiPlugin } from '@elizaos/plugin-sui';

export default {
  plugins: [suiPlugin],
  // ... other configuration
};
```

## Example Usage

Send tokens:

```typescript
User: 'Send 1 SUI to 0x4f2e63be8e7fe287836e29cde6f3d5cbc96eefd0c0e3f3747668faa2ae7324b0';
Assistant: "I'll send 1 SUI token now...";
```

Check balance:

```typescript
User: "What's my wallet balance?";
Assistant: 'Your wallet contains 10.5 SUI ($42.00 USD)...';
```

## Links

- [Sui Documentation](https://docs.sui.io/)
- [Sui Developer Portal](https://sui.io/developers)
- [Sui Network Dashboard](https://suiscan.xyz/)
- [Sui GitHub Repository](https://github.com/MystenLabs/sui)
`````

## File: packages/docs/static/packages/plugins/suno.md
`````markdown
# @elizaos/plugin-suno

## Purpose

A Suno AI music generation plugin for ElizaOS that enables AI-powered music creation and audio manipulation.

## Key Features

- Generate music from text prompts with fine-tuned parameters
- Create custom music with advanced control over style, tempo, and key
- Extend existing audio tracks

## Installation

```
npm install @elizaos/plugin-suno
```

## Configuration

```typescript
sunoProvider.configure({
  apiKey: 'your-suno-api-key',
});
```

## Integration

Register the plugin with ElizaOS:

```typescript
import { sunoPlugin } from '@elizaos/plugin-suno';
import { Eliza } from '@elizaos/core';

const eliza = new Eliza();
eliza.registerPlugin(sunoPlugin);
```

## Example Usage

```typescript
// Basic music generation
await eliza.execute('suno.generate-music', {
  prompt: 'An upbeat electronic dance track with energetic beats',
  duration: 30,
  temperature: 1.0,
});

// Custom music generation
await eliza.execute('suno.custom-generate-music', {
  prompt: 'A melodic piano piece with soft strings',
  style: 'classical',
  bpm: 120,
  key: 'C',
  mode: 'major',
});

// Extend existing audio
await eliza.execute('suno.extend-audio', {
  audio_id: 'your-audio-id',
  duration: 60,
});
```

## Links

Original Plugin: https://github.com/gcui-art/suno-api?tab=readme-ov-file
`````

## File: packages/docs/static/packages/plugins/tee-log.md
`````markdown
# TEE Log Plugin for Eliza

## Purpose

Enhances logging capabilities by providing a structured way to generate, store and verify TEE (Trusted Execution Environment) logs for agents, ensuring sensitive interactions are securely logged with tamper-resistant records.

## Requirements

- Intel SGX (Gramine): enable plugin-sgx in Eliza runtime (automatic in SGX environments)
- Intel TDX (dstack): enable plugin-tee in Eliza runtime

## Configuration

Enable TEE logging in .env file:

```env
TEE_LOG_ENABLED=true
```

## Integration

- Import the service: `import { ServiceType, ITeeLogService } from '@elizaos/core'`
- Add plugin-tee-log to dependencies of target plugin
- Get service instance: `const teeLogService = runtime.getService<ITeeLogService>(ServiceType.TEE_LOG).getInstance()`
- Log interactions: `teeLogService.log(runtime.agentId, message.roomId, message.userId, 'Action:TYPE', 'content')`

## Storage

Logs stored in SQLite database at `./data/tee_log.sqlite`. Production environments must use encrypted file systems for security.
`````

## File: packages/docs/static/packages/plugins/tee-marlin.md
`````markdown
# Marlin TEE Plugin

## Purpose

A plugin for making agents on Eliza verifiable through the use of Trusted Execution Environments (TEEs).

## Configuration

Add the following to your `.env` file to enable the plugin:

```
TEE_MARLIN=yes
```

Optional configuration for the attestation server:

```
# Optional, default is http://127.0.0.1:1350
TEE_MARLIN_ATTESTATION_ENDPOINT="http://127.0.0.1:1350"
```

## Integration

The plugin leverages the Marlin Oyster platform and SDKs to provide the REMOTE_ATTESTATION action that fetches attestations from a server, allowing users to verify if an agent is running inside a TEE environment.

## Example Usage

```
You: attest yourself
```

The agent will respond with an attestation string that verifies its TEE environment.

## Links

- [Marlin Oyster](https://docs.marlin.org/user-guides/oyster/)
- [SDKs](https://github.com/marlinprotocol/oyster-monorepo)
- [Mock attestation server](https://github.com/marlinprotocol/oyster-monorepo/tree/master/attestation/server-custom-mock)
`````

## File: packages/docs/static/packages/plugins/tee-verifiable-log.md
`````markdown
# Build Plugin

## Purpose

A plugin for building and testing code in ElizaOS.

## Configuration

This plugin depends on plugin-tee. For local testing, a TEE simulator can be set up using Docker. When using the provider through the runtime environment, configure settings like TEE_MODE, WALLET_SECRET_SALT, and VLOG.

## Example Usage

```
bun clean
bun install  or  bun install --no-frozen-lockfile
bun build
```

For testing:

```
bun test
```
`````

## File: packages/docs/static/packages/plugins/tee.md
`````markdown
# @elizaos/plugin-tee

## Purpose

A plugin for handling Trusted Execution Environment (TEE) operations, providing secure key derivation and remote attestation capabilities.

## Key Features

- Generate secure keys within a TEE environment
- Derive Ed25519 keypairs for Solana
- Derive ECDSA keypairs for Ethereum
- Generate remote attestation quotes
- Manage wallet interactions with TEE-derived keys

## Installation

```bash
npm install @elizaos/plugin-tee
```

## Configuration

Environment variables:

```env
TEE_MODE=LOCAL|DOCKER|PRODUCTION
WALLET_SECRET_SALT=your_secret_salt  # Required for single agent deployments
DSTACK_SIMULATOR_ENDPOINT=your-endpoint-url  # Optional, for simulator purposes
```

## Integration

Import and register in Eliza configuration:

```typescript
import { teePlugin } from '@elizaos/plugin-tee';

export default {
  plugins: [teePlugin],
  // ... other configuration
};
```

## Example Usage

```typescript
import { DeriveKeyProvider, RemoteAttestationProvider } from '@elizaos/plugin-tee';

// Key derivation
const provider = new DeriveKeyProvider();
const solanaKeypair = await provider.deriveEd25519Keypair('/path/to/derive', 'subject-identifier');
const evmKeypair = await provider.deriveEcdsaKeypair('/path/to/derive', 'subject-identifier');

// Remote attestation
const raProvider = new RemoteAttestationProvider();
const attestation = await raProvider.generateAttestation('your-report-data');
```
`````

## File: packages/docs/static/packages/plugins/thirdweb.md
`````markdown
# ai16z/plugin-thirdweb

## Purpose

This plugin provides access to thirdweb's Nebula AI interface.

## Configuration

By default, the thirdweb plugin is enabled. Add your secret key to the `.env` file:

```env
THIRDWEB_SECRET_KEY=your-thirdweb-secret-key-here
```

## Integration

Enables interaction with the thirdweb Nebula natural language interface to analyze smart contracts, read contract data, decode interactions, access blockchain information, track transactions, look up token information, and retrieve wallet balances.

## Example Usage

```
What is the ETH balance for 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
```

```
What is the total NFT supply for 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D?
```

```
Does 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045 hold USDC on Base?
```

```
What is the address of USDC on Ethereum?
```

## Links

https://portal.thirdweb.com/nebula
`````

## File: packages/docs/static/packages/plugins/ton.md
`````markdown
# @elizaos/plugin-ton

## Purpose

A plugin for handling TON (Telegram Open Network) blockchain operations, providing wallet management and transfer capabilities.

## Key Features

- Manage TON wallets and key derivation
- Execute secure token transfers
- Query wallet balances and portfolio information
- Format and cache transaction data
- Interface with TON blockchain via RPC endpoints
- Connect TON wallets using TonConnect protocol
- Support multiple wallet applications (like Tonkeeper)
- Support QR Code scanning connection
- Batch transfers of NFTs, Jettons and TON in a single transaction
- On-demand wallet creation with encrypted key storage
- Auction interactions

## Installation

```bash
npm install @elizaos/plugin-ton
```

## Configuration

Environment variables:

```env
TON_PRIVATE_KEY=your_mnemonic_phrase
TON_RPC_URL=your_rpc_endpoint
TON_RPC_API_KEY=
TON_MANIFEST_URL=your_manifest_url
TON_BRIDGE_URL=your_bridge_url
```

## Integration

Import and register in Eliza configuration:

```typescript
import { tonPlugin } from '@elizaos/plugin-ton';

export default {
  plugins: [tonPlugin],
  // ... other configuration
};
```

## Example Usage

```typescript
// WalletProvider
const provider = await initWalletProvider(runtime);
const balance = await provider.getWalletBalance();
const portfolio = await provider.getFormattedPortfolio(runtime);

// Transfer
const action = new TransferAction(walletProvider);
const hash = await action.transfer({
  recipient: 'EQCGScrZe1xbyWqWDvdI6mzP-GAcAWFv6ZXuaJOuSqemxku4',
  amount: '1.5',
});
```
`````

## File: packages/docs/static/packages/plugins/trikon.md
`````markdown
# @elizaos/plugin-trikon

## Purpose

Trikon plugin for Eliza OS that provides token transfer functionality as a Proof of Concept (POC) implementation for Trikon token transfers within the Eliza ecosystem.

## Key Features

- Basic token transfer capabilities
- Wallet management

## Installation

```
bun add @elizaos/plugin-trikon
```

## Configuration

The plugin requires the following environment variables:

- `TRIKON_WALLET_ADDRESS`: Your Trikon wallet address (must be a valid 64-character hex string starting with '0x')
- `TRIKON_INITIAL_BALANCE`: (Optional) The initial balance for the wallet. Defaults to "0" if not provided.

## Integration

```typescript
import { trikonPlugin } from '@elizaos/plugin-trikon';

const eliza = new ElizaOS({
  plugins: [trikonPlugin],
});
```
`````

## File: packages/docs/static/packages/plugins/trustdb.md
`````markdown
# @elizaos/plugin-trustdb

## Purpose

A plugin for managing trust scores and performance metrics in a secure database, providing recommender tracking and token performance analysis capabilities.

## Key Features

- Track and manage recommender trust scores
- Monitor token performance metrics
- Record and analyze trading performance
- Maintain historical metrics data
- Handle transaction records and validations

## Installation

```bash
npm install @elizaos/plugin-trustdb
```

## Configuration

```typescript
import { TrustScoreDatabase } from '@elizaos/plugin-trustdb';
import Database from 'better-sqlite3';

const db = new Database('path/to/database.sqlite');
const trustDB = new TrustScoreDatabase(db);
```

## Example Usage

```typescript
import { TrustScoreDatabase } from '@elizaos/plugin-trustdb';

// Initialize database
const trustDB = new TrustScoreDatabase(db);

// Add a recommender
const recommender = {
  id: 'uuid',
  address: 'wallet-address',
  telegramId: 'telegram-id',
};
trustDB.addRecommender(recommender);

// Track token performance
const performance = {
  tokenAddress: 'token-address',
  priceChange24h: 10.5,
  volumeChange24h: 25.3,
  // ... other metrics
};
trustDB.upsertTokenPerformance(performance);
```
`````

## File: packages/docs/static/packages/plugins/trustgo.md
`````markdown
# @toddli/plugin-trustgo

## Purpose

The TrustGo plugin enables fetching EVM account information from the TrustGo website and facilitates the minting of MEDIA score attestations.

## Key Features

- Login to TrustGo Website: Securely authenticate with TrustGo.
- Fetch Multi-Chain MEDIA Score: Retrieve MEDIA scores across multiple chains.
- Fetch User Attestations: Access user attestations.
- Mint L2 MEDIA Attestation: Mint MEDIA attestations on Layer 2.

## Installation

```bash
bun install @toddli/plugin-trustgo
```

## Configuration

### Dependencies

```
@elizaos/core
@elizaos/plugin-evm
```

### Required Environment Variables

```env
# Required
EVM_PRIVATE_KEY=your-private-key
```

## Integration

The TrustGo Provider integrates the EVM Wallet Provider, performing authentication, fetching MEDIA scores from multiple blockchain networks, displaying attestations, and minting attestations.

## Example Usage

```typescript
go trustgo
Show my onchain Reputation
show my attestations
mint my linea media score
```

## Links

https://trustgo.trustalabs.ai/
`````

## File: packages/docs/static/packages/plugins/tts.md
`````markdown
# @elizaos/plugin-tts

## Purpose

A plugin for text-to-speech(TTS) generation using the FAL.ai API within the ElizaOS ecosystem.

## Key Features

- Automatic language detection
- Voice selection based on detected language
- Local file caching
- Progress tracking
- Error handling

## Installation

```bash
bun install @elizaos/plugin-tts
```

## Configuration

The plugin requires the following environment variable:

```typescript
FAL_API_KEY=<Your FAL.ai API key>
```

## Integration

Import the plugin with:

```typescript
import { TTSGenerationPlugin } from '@elizaos/plugin-tts';
```

## Example Usage

The plugin responds to natural language commands like:

- 'Generate TTS of Hello World'
- 'Create a TTS for Welcome to ElizaOS'
- 'Make a TTS saying [your text]'

## Links

- [FAL.ai Documentation](https://fal.ai/docs)
- [ElizaOS Documentation](https://elizaos.github.io/eliza/)
`````

## File: packages/docs/static/packages/plugins/twitter.md
`````markdown
# @elizaos/plugin-twitter

## Purpose

A plugin for Twitter/X integration, providing automated tweet posting capabilities with character-aware content generation.

## Key Features

- Compose context-aware tweets
- Post tweets to Twitter/X platform
- Handle authentication and session management
- Support premium Twitter features
- Manage tweet length restrictions

## Installation

```bash
npm install @elizaos/plugin-twitter
```

## Configuration

Requires environment variables:

```env
TWITTER_API_KEY=your_api_key
TWITTER_API_SECRET_KEY=your_api_secret_key
TWITTER_ACCESS_TOKEN=your_access_token
TWITTER_ACCESS_TOKEN_SECRET=your_access_token_secret
TWITTER_2FA_SECRET=your_2fa_secret    # Optional: for 2FA
TWITTER_PREMIUM=false                 # Optional: enables premium features
TWITTER_DRY_RUN=false                # Optional: test without posting
```

## Integration

Import and register the plugin in Eliza configuration:

```typescript
import { twitterPlugin } from '@elizaos/plugin-twitter';

export default {
  plugins: [twitterPlugin],
  // ... other configuration
};
```

## Example Usage

```typescript
import { postAction } from '@elizaos/plugin-twitter';

// Tweet will be composed based on context and character limits
const result = await postAction.handler(runtime, message, state);

// Post with automatic content generation
await postAction.handler(runtime, message, state);

// Dry run mode (for testing)
process.env.TWITTER_DRY_RUN = 'true';
await postAction.handler(runtime, message, state);
```
`````

## File: packages/docs/static/packages/plugins/udio.md
`````markdown
# @elizaos/plugin-udio

## Purpose

A Udio AI music generation plugin for ElizaOS that enables AI-powered music creation and audio manipulation.

## Key Features

- Generate music from text prompts with fine-tuned parameters
- Create custom music with advanced control over style and lyrics
- Extend existing audio tracks with AI-powered continuation

## Installation

```
npm install @elizaos/plugin-udio
```

## Configuration

Configure your Udio authentication token in your environment:

```
UDIO_AUTH_TOKEN=your-udio-auth-token
```

## Integration

Register the plugin with ElizaOS:

```typescript
import { udioPlugin } from '@elizaos/plugin-udio';
import { Eliza } from '@elizaos/core';

const eliza = new Eliza();
eliza.registerPlugin(udioPlugin);
```

## Example Usage

Generate music:

```typescript
await eliza.execute('udio.generate', {
  prompt: 'An upbeat electronic dance track with energetic beats',
  seed: 12345,
  customLyrics: 'Your custom lyrics here',
});
```

Extend audio:

```typescript
await eliza.execute('udio.extend', {
  prompt: 'Continue with similar style',
  audioConditioningPath: 'path/to/audio.mp3',
  audioConditioningSongId: 'original-song-id',
  cropStartTime: 30,
  seed: 12345,
  customLyrics: 'Additional lyrics for the extension',
});
```

## Links

License: MIT
`````

## File: packages/docs/static/packages/plugins/viction.md
`````markdown
# @elizaos/plugin-viction

## Purpose

Core Viction blockchain plugin for Eliza OS that provides essential services and actions for token operations, trading, and DeFi integrations.

## Key Features

- **Token Information**: Provide Viction information
- **Token Transfers**: Send and receive tokens securely native and non-native

## Installation

```bash
npm install @elizaos/plugin-viction
```

## Configuration

```typescript
const victionEnvSchema = {
  VICTION_ADDRESS: string,
  VICTION_PRIVATE_KEY: string,
  VICTION_RPC_URL: string,
};
```

## Integration

Serves as a foundational component of Eliza OS, bridging Viction blockchain capabilities with the Eliza ecosystem.

## Example Usage

```typescript
import { victionPlugin } from '@elizaos/plugin-viction';

// Initialize the plugin
const runtime = await initializeRuntime({
  plugins: [victionPlugin],
});

// Get Viction information
const result = await runtime.executeAction('GIVE_VICTION_INFOMATION', {});

// Transfer VIC
const result = await runtime.executeAction('SEND_VIC', {
  recipient: 'RecipientAddressHere',
  amount: '1000',
});

// Transfer tokens
const result = await runtime.executeAction("SEND_TOKEN", {
    recipient: "RecipientAddressHere",
    tokenAddress: "TokenAddressHere"
    amount: "1000",
});
```
`````

## File: packages/docs/static/packages/plugins/video-generation.md
`````markdown
# @elizaos/plugin-video-generation

## Purpose

A plugin for AI-powered video generation using Luma AI, providing automated video creation capabilities from text prompts.

## Key Features

- Generate videos from text descriptions
- Handle video generation requests through Luma AI
- Manage API authentication and responses
- Cache and serve generated videos
- Monitor generation progress

## Installation

```bash
npm install @elizaos/plugin-video-generation
```

## Configuration

The plugin requires the following environment variables:

```env
LUMA_API_KEY=your_luma_api_key    # Required: API key for Luma AI
```

## Integration

Import and register the plugin in your Eliza configuration:

```typescript
import { videoGenerationPlugin } from '@elizaos/plugin-video-generation';

export default {
  plugins: [videoGenerationPlugin],
  // ... other configuration
};
```

## Example Usage

```typescript
// Basic video generation
const videoPrompt = 'Create a video of a futuristic city at night';
const result = await generateVideo(videoPrompt, runtime);

// With callback handling
videoGeneration.handler(
  runtime,
  {
    content: { text: videoPrompt },
  },
  state,
  {},
  (response) => {
    console.log('Generation status:', response);
  }
);
```
`````

## File: packages/docs/static/packages/plugins/video.md
`````markdown
# @elizaos/plugin-video Video Service

## Purpose

The VideoService provides comprehensive video processing capabilities with a focus on efficient handling and transcription.

## Key Features

- Video Download: Supports both YouTube videos and direct MP4 URLs
- Format Handling: Automatic detection/conversion, MP4 to MP3 conversion, support for YouTube and Vimeo
- Transcription Pipeline: Extracts manual subtitles, falls back to automatic captions or audio transcription
- Performance Optimizations: Queue-based processing, built-in caching, efficient temp file management
- Error Handling: Graceful fallbacks, comprehensive error reporting, automatic cleanup

## Example Usage

```typescript
const videoService = runtime.getService<IVideoService>(ServiceType.VIDEO);

// Process a video URL
const result = await videoService.processVideo(videoUrl, runtime);
// Returns: Media object with id, url, title, source, description, and transcript
```
`````

## File: packages/docs/static/packages/plugins/web-search.md
`````markdown
# @elizaos/plugin-web-search

## Purpose

A plugin for powerful web search capabilities, providing efficient search query handling and result processing through a customizable API interface.

## Key Features

- Execute web search queries with customizable parameters
- Process and format search results
- Handle search API authentication
- Manage token limits and response sizes
- Optimize query performance

## Installation

```bash
bun install @elizaos/plugin-web-search
```

## Configuration

The plugin requires the following environment variables:

```env
TAVILY_API_KEY=your_api_key    # Required: API key for search service
```

## Integration

Import and register the plugin in your Eliza configuration:

```typescript
import { webSearchPlugin } from '@elizaos/plugin-web-search';

export default {
  plugins: [webSearchPlugin],
  // ... other configuration
};
```

## Example Usage

```typescript
// Basic search
const searchQuery = 'Latest developments in quantum computing';
const results = await generateWebSearch(searchQuery, runtime);

// With formatted response
if (results && results.results.length) {
  const formattedResponse = `${results.answer}\n\nFor more details, check out:\n${results.results
    .map((result, index) => `${index + 1}. [${result.title}](${result.url})`)
    .join('\n')}`;
}
```
`````

## File: packages/docs/static/packages/plugins/whatsapp.md
`````markdown
# @elizaos/plugin-whatsapp

## Purpose

A plugin for integrating WhatsApp Cloud API with your application, providing comprehensive messaging capabilities and webhook handling.

## Key Features

- Send text messages
- Send template messages
- Webhook verification
- Webhook event handling
- Message status updates

## Installation

```bash
npm install @elizaos/plugin-whatsapp
```

## Configuration

```env
WHATSAPP_ACCESS_TOKEN=your_access_token       # Required: WhatsApp Cloud API access token
WHATSAPP_PHONE_NUMBER_ID=your_phone_number_id # Required: WhatsApp business phone number ID
WHATSAPP_WEBHOOK_TOKEN=your_webhook_token     # Optional: Webhook verification token
WHATSAPP_BUSINESS_ID=your_business_id        # Optional: Business account ID
```

## Example Usage

```typescript
// Basic setup
import { WhatsAppPlugin } from '@elizaos/plugin-whatsapp';

const whatsappPlugin = new WhatsAppPlugin({
  accessToken: 'your_access_token',
  phoneNumberId: 'your_phone_number_id',
  webhookVerifyToken: 'your_webhook_verify_token',
  businessAccountId: 'your_business_account_id',
});

// Send a text message
await whatsappPlugin.sendMessage({
  type: 'text',
  to: '1234567890',
  content: 'Hello from WhatsApp!',
});

// Verify webhook
app.get('/webhook', (req, res) => {
  const verified = await whatsappPlugin.verifyWebhook(req.query['hub.verify_token']);
  if (verified) {
    res.send(req.query['hub.challenge']);
  } else {
    res.sendStatus(403);
  }
});
```
`````

## File: packages/docs/static/packages/plugins/youtube-to-text.md
`````markdown
# @elizaos/plugin-youtube-to-text

## Purpose

The Youtube to text Plugin allows users to retrieve a text output of a Youtube video.

## Key Features

- Converts YouTube video links into text format using OpenAI's Whisper model
- Leverages Whisper's advanced AI for precise and reliable transcription
- Extracts and saves the video's audio as a WAV and MP3 file under the agent/data folder

## Installation

```bash
bun install @elizaos/plugin-youtube-to-text
```

## Development

1. Clone the repository
2. Install dependencies:

```bash
bun install
```

3. Build the plugin:

```bash
bun run build
```

4. Run tests:

```bash
bun test
```
`````

## File: packages/docs/static/packages/plugins/zapper.md
`````markdown
# @elizaos/plugin-zapper

## Purpose

A plugin for Eliza that allows users to fetch portfolio data using the Zapper API.

## Key Features

- Get portfolio data from wallet addresses on networks supported by the Zapper API
- Get portfolio data from addresses attached to Farcaster profiles

## Installation

```bash
npm install @elizaos/plugin-zapper
```

## Configuration

1. Get your API key from Zapper
2. Set up environment variables: `ZAPPER_API_KEY=your_api_key`
3. Register the plugin in your Eliza configuration:

```typescript
import { zapperPlugin } from '@elizaos/plugin-zapper';

// In your Eliza configuration
plugins: [
  zapperPlugin,
  // ... other plugins
];
```

## Integration

The plugin responds to natural language queries about wallet data with two main actions: "portfolio" to fetch current portfolio of provided addresses, and "farcasterPortfoio" to fetch portfolios of addresses attached to Farcaster profiles.

## Example Usage

```plaintext
"Show me the holdings of @vitalik.eth"
"Show me the portfolio of these wallets 0xd8d...045, 0xadd...077"
"Get wallet holdings for HN7cA...WrH"
```

## Links

- [Zapper API Documentation](https://protocol.zapper.xyz/docs/api/)
`````

## File: packages/docs/static/packages/plugins/zerion.md
`````markdown
# @elizaos/plugin-zerion

## Purpose

A plugin for Eliza that enables fetching wallet portfolio and position data using the Zerion API.

## Key Features

- Real-time wallet portfolio data
- Detailed token positions and balances
- Chain distribution analysis
- Portfolio value changes tracking
- Support for all EVM-compatible chains
- Natural language processing for wallet queries

## Installation

```bash
npm install @elizaos/plugin-zerion
```

## Configuration

1. Get your API key from Zerion
2. Set environment variables: ZERION_API_KEY
3. Register the plugin in your Eliza configuration:

```typescript
import { zerionPlugin } from '@elizaos/plugin-zerion';

// In your Eliza configuration
plugins: [
  zerionPlugin,
  // ... other plugins
];
```

## Integration

The plugin responds to natural language queries about wallet data through actions like getWallet_portfolio and getWallet_positions.

## Example Usage

```plaintext
"Show me the portfolio for 0x123...abc"
"What are the token positions in 0x456...def?"
"Get wallet holdings for 0x789...ghi"
```

## Links

- [Zerion API Documentation](https://developers.zerion.io/reference/intro)
- [GitHub Repository](https://github.com/elizaos/eliza/tree/main/packages/plugin-zerion)
`````

## File: packages/docs/static/packages/plugins/zilliqa.md
`````markdown
# @elizaos/plugin-zilliqa

## Purpose

A plugin for integrating Zilliqa blockchain capabilities through the GOAT (Great Onchain Agent Toolkit) framework within the ElizaOS ecosystem.

## Installation

```bash
bun install @elizaos/plugin-zilliqa
```

## Configuration

### Environment Variables

```typescript
EVM_PRIVATE_KEY=<Your EVM wallet private key>
EVM_PROVIDER_URL=<Your RPC provider URL (e.g., Infura, Alchemy)>
ENABLE_ZILLIQA=1
```

## Integration

This plugin integrates the GOAT Zilliqa plugin and wallet with Eliza, allowing blockchain tools such as wallets, token handling, and smart contract interactions.

## Common Issues & Troubleshooting

1. **Agent not executing an action**:

   - Confusion with EVM Plugin action names
   - Character prompts affecting action execution

2. **Wallet Connection Issues**

   - Private key formatting
   - RPC endpoint availability
   - Network balance

3. **Transaction Issues**
   - Gas availability
   - Network congestion
   - Transaction parameters

## Links

[GOAT](https://ohmygoat.dev/)
[Chains supported](https://ohmygoat.dev/chains-wallets-plugins)
[Plugins supported](https://ohmygoat.dev/chains-wallets-plugins)
`````

## File: packages/docs/static/packages/plugins/zksync-era.md
`````markdown
# @elizaos/plugin-zksync-era

## Purpose

A plugin for integrating ZKSync Era blockchain operations with your application, providing token transfer capabilities and transaction management.

## Key Features

- Execute token transfers on ZKSync Era
- Handle smart account operations
- Manage transaction signing and submission
- Support multiple token standards
- Process transaction receipts and confirmations

## Installation

```bash
npm install @elizaos/plugin-zksync-era
```

## Configuration

The plugin requires the following environment variables:

```env
ZKSYNC_ADDRESS=your_address           # Required: Your ZKSync wallet address
ZKSYNC_PRIVATE_KEY=your_private_key  # Required: Your wallet's private key
```

## Example Usage

```typescript
// Initialize plugin
const zksync = zksyncEraPlugin;

// Execute transfer
try {
  await transfer.handler(
    runtime,
    {
      content: {
        tokenAddress: TOKENS.USDC,
        recipient: '0xCCa8009f5e09F8C5dB63cb0031052F9CB635Af62',
        amount: '100',
      },
    },
    state
  );
} catch (error) {
  console.error('Transfer failed:', error.message);
}
```

## Links

- [ZKSync Documentation](https://docs.zksync.io/)
- [Matter Labs Blog](https://blog.matter-labs.io/)
- [ZKSync GitHub](https://github.com/matter-labs/zksync-era)
`````

## File: packages/docs/docs/core/plugins.md
`````markdown
---
sidebar_position: 8
title: Plugin System
description: Learn about ElizaOS plugins - modular extensions that enhance agent capabilities
keywords: [plugins, extensions, modules, development, publishing, registry, npm, GitHub]
image: /img/plugins.png
---

# Plugins

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Plugins are modular extensions that enhance the capabilities of ElizaOS agents. They provide a flexible way to add new functionality, integrate external services, and customize agent behavior across different platforms.

:::info
Key Improvements in V2

1. **Unified API**: Almost everything is accessible via `runtime.methodName()` in the agent runtime for simpler development
2. **Enhanced Model System**: The new `useModel` approach allows for flexible model provider registration
3. **Events System**: Formal support for event-based programming
4. **Plugin Creation Workflow**: Simplified creation and testing via CLI
5. **Testing Infrastructure**: Built-in support for plugin testing
6. **No Monorepo Required**: Complete plugin development without touching the core codebase
7. **Plugin Registry**: Manages the catalog of available plugins and handles their registration with the runtime
8. **Bootstrap Plugin**: Initializes core functionality required for all agents to operate
   :::

The ElizaOS plugin system maintains the same basic concept as previous versions, with several new extension points (events, routes, tests, models) and features that significantly improve the developer experience.

**Browse plugins the elizaOS community made here: [Package Showcase](/packages)**

[![](/img/plugins.png)](/packages)

> elizaOS maintains an official package registry at [github.com/elizaos-plugins/registry](https://github.com/elizaos-plugins/registry).

---

## Quick Start

The new CLI tool introduces a streamlined workflow for plugin development without ever needing to touch the ElizaOS monorepo directly:

1. **Create**: `bun create eliza` - Initialize a new plugin project with proper structure
2. **Develop**: Edit the plugin code in the generated project structure
3. **Test**: `elizaos test` - Test the plugin functionality
4. **Run**: `elizaos start` - Run the plugin with a default agent
5. **Publish**: `elizaos publish` - Share your plugin with others

### Creating a New Plugin

You can create a new ElizaOS plugin using the CLI:

```bash
# Using bun (recommended)
bun create eliza

# Or using bunx
bunx create-eliza
```

When prompted, select "Plugin" as the type to create. The CLI will guide you through the setup process, creating a plugin with the proper structure and dependencies.

---

### Managing Plugins

There are several ways to add plugins to your ElizaOS project:

<Tabs>
  <TabItem value="package" label="Via package.json">
    ```json
    {
      "dependencies": {
        "@elizaos/plugin-solana": "github:elizaos-plugins/plugin-solana",
        "@elizaos/plugin-farcaster": "github:elizaos-plugins/plugin-farcaster"
      }
    }
    ```
  </TabItem>
  <TabItem value="character" label="Via Character Definition">
    ```typescript
    // In src/index.ts
    export const character: Character = {
      name: 'MyAgent',
      plugins: ['@elizaos/plugin-farcaster', '@elizaos/plugin-example'],
      // ...
    };
    ```
  </TabItem>
  <TabItem value="cli" label="Via CLI Commands">
    ```bash
    # Add a plugin
    elizaos plugins add @elizaos/plugin-farcaster

    # Remove a plugin
    elizaos plugins remove @elizaos/plugin-farcaster

    # List available plugins
    elizaos plugins list
    ```

  </TabItem>
</Tabs>

---

### Plugin Configuration

Configure plugin settings in your character definition:

```json
{
  "name": "MyAgent",
  "plugins": ["@elizaos/plugin-example"],
  "settings": {
    "example": {
      "enableFeatureX": true
    }
  }
}
```

### Plugin Loading Process

The AgentRuntime automatically loads the Bootstrap Plugin during initialization, before any other plugins:

```typescript
async initialize() {
  // Register bootstrap plugin
  await this.registerPlugin(bootstrapPlugin);

  // Then register additional plugins
  for (const plugin of this.plugins) {
    await this.registerPlugin(plugin);
  }

  // Initialize other components
  // ...
}
```

---

### Publishing Plugins

If you're a plugin developer, you can publish your plugin to make it available to others. The ElizaOS CLI provides several options for publishing your plugin depending on your needs.

First, make sure your plugin is built and ready for distribution:

```bash
# Navigate to your plugin directory
cd my-eliza-plugin

# Build your plugin
npm run build
```

<Tabs>
  <TabItem value="github" label="GitHub Publishing">
    Publishing to GitHub is the recommended approach for sharing your plugin with the ElizaOS community:

    ```bash
    # Publish to GitHub
    elizaos publish
    ```

    This will:
    1. Build and package your plugin
    2. Create or update a GitHub repository in the elizaos-plugins organization
    3. Add your plugin to the ElizaOS registry (if you're a registry maintainer)

    For first-time publishers, the CLI will guide you through setting up GitHub credentials for publishing.

    GitHub publishing is ideal for open-source plugins that you want to share with the community and have listed in the official registry.

  </TabItem>

  <TabItem value="npm" label="npm Publishing">
    You can also publish your plugin to npm:

    ```bash
    # Publish to npm
    elizaos publish --npm
    ```

    This allows users to install your plugin using standard npm commands:

    ```bash
    npm install @your-scope/plugin-name
    ```

    npm publishing is useful when you want to:
    - Maintain your own package namespace
    - Integrate with existing npm workflows
    - Set up automated versioning and releases

    Make sure your package.json is properly configured with the correct name, version, and access permissions.

  </TabItem>

  <TabItem value="testing" label="Test Mode">
    Before publishing, you can validate the process without making any external changes:

    ```bash
    # Test the publish process
    elizaos publish --test
    ```

    This runs through all the packaging and validation steps without actually publishing anything.

    Test mode is helpful for:
    - Verifying your plugin structure is correct
    - Ensuring all required files are present
    - Checking that dependencies are properly configured
    - Validating that your plugin can be built successfully

    Always run in test mode before your first public release to avoid issues.

  </TabItem>

  <TabItem value="customizing" label="Additional Options">
    The publish command supports several additional options to customize the publishing process:

    ```bash
    # Specify platform compatibility
    elizaos publish --platform node

    # Set custom version number
    elizaos publish --version 1.2.3

    # Provide a custom registry URL
    elizaos publish --registry https://custom-registry.com

    # Publish with public access
    elizaos publish --access public
    ```

    These options give you fine-grained control over how and where your plugin is published. Refer to `elizaos publish --help` for a complete list of options.

  </TabItem>
</Tabs>

:::info
When submitting a plugin to the [elizaOS Registry](https://github.com/elizaos-plugins/registry), include:

1. **Working Demo**: Screenshots or video of your plugin in action
2. **Test Results**: Evidence of successful integration and error handling
3. **Configuration Example**: Show how to properly configure your plugin
   :::

---

## Plugin Architecture

Eliza uses a unified plugin architecture where everything is a plugin - including services, adapters, actions, evaluators, and providers. This approach ensures consistent behavior and better extensibility.

### Plugin Components

Each plugin can provide one or more of the following components:

| Component          | Purpose                                                                         |
| ------------------ | ------------------------------------------------------------------------------- |
| **Services**       | Platform integrations (Discord, Telegram, etc.) or specialized capabilities      |
| **Actions**        | Executable functions triggered by the agent (reply, generate content, etc.)     |
| **Providers**      | Context providers that supply info to the agent during decision making          |
| **Evaluators**     | Analyze conversations to extract insights and improve future interactions       |
| **Adapters**       | Database or storage system integrations                                         |
| **Model Handlers** | Register handlers for different model types (text generation, embeddings, etc.) |
| **Event Handlers** | React to system events like messages, connections, or actions                   |
| **API Routes**     | Add custom REST endpoints to the agent's HTTP interface                         |
| **Tests**          | Include test suites to verify plugin functionality                              |

### Plugin Interface

All plugins implement the core Plugin interface:

```typescript
interface Plugin {
  name: string;
  description: string;
  config?: { [key: string]: any };

  // Optional initialization method
  init?: (config: Record<string, string>, runtime: IAgentRuntime) => Promise<void>;

  // Components
  services?: (typeof Service)[];
  actions?: Action[];
  providers?: Provider[];
  evaluators?: Evaluator[];
  adapters?: Adapter[];

  // Additional features
  routes?: Route[];
  tests?: TestSuite[];
  events?: { [key: string]: ((params: any) => Promise<any>)[] };
}
```

### Service Implementation

Services are the core integration points for external platforms. A properly implemented service:

```typescript
import { Service, IAgentRuntime } from '@elizaos/core';

export class ExampleService extends Service {
  // Required: Define the service type (used for runtime registration)
  static serviceType = 'example';

  // Required: Describe what this service enables the agent to do
  capabilityDescription = 'Enables the agent to interact with the Example platform';

  // Store runtime for service operations
  constructor(protected runtime: IAgentRuntime) {
    super();
    // Initialize connections, setup event handlers, etc.
  }

  // Required: Static method to create and initialize service instance
  static async start(runtime: IAgentRuntime): Promise<ExampleService> {
    const service = new ExampleService(runtime);
    // Additional initialization if needed
    return service;
  }

  // Required: Clean up resources when service is stopped
  async stop(): Promise<void> {
    // Close connections, release resources
  }

  // Optional: Custom methods for your service functionality
  async sendMessage(content: string, channelId: string): Promise<void> {
    // Implementation
  }
}
```

## Plugin Structure

Each plugin repository should follow this structure:

```
plugin-name/
├── images/                # Branding assets
│   ├── logo.png           # Square logo (400x400px)
│   ├── banner.png         # Banner image (1280x640px)
│   └── screenshots/       # Feature screenshots
├── src/
│   ├── index.ts           # Main plugin entry point
│   ├── service.ts         # Service implementation
│   ├── actions/           # Plugin-specific actions
│   ├── providers/         # Data providers
│   ├── types.ts           # Type definitions
│   └── environment.ts     # Configuration validation
├── tests/                 # Test suite
├── package.json           # Plugin configuration and dependencies
└── README.md              # Plugin documentation
```

### Plugin Entry Point

Your plugin's `index.ts` should export a Plugin object:

```typescript
// Example plugin implementation
import { type Plugin } from '@elizaos/core';
import { ExampleService } from './service';
import { searchAction } from './actions/search';
import { statusProvider } from './providers/status';

const examplePlugin: Plugin = {
  name: 'example',
  description: 'Example platform integration for ElizaOS',
  services: [ExampleService],
  actions: [searchAction],
  providers: [statusProvider],
  init: async (config, runtime) => {
    // Perform any necessary initialization
    const apiKey = runtime.getSetting('EXAMPLE_API_KEY');
    if (!apiKey) {
      console.warn('EXAMPLE_API_KEY not provided');
    }
  },
};

export default examplePlugin;
```

### Plugin Configuration

Your plugin's `package.json` should include an `agentConfig` section:

```json
{
  "name": "@elizaos/plugin-example",
  "version": "1.0.0",
  "agentConfig": {
    "pluginType": "elizaos:plugin:1.0.0",
    "pluginParameters": {
      "API_KEY": {
        "type": "string",
        "description": "API key for the Example service"
      }
    }
  }
}
```

### Environment Variables and Secrets

Plugins access configuration through the runtime with the following precedence:

1. Character settings secrets (highest priority)
2. Character settings
3. Global environment settings

#### Access Pattern

```typescript
// In your service implementation
const apiKey = runtime.getSetting('EXAMPLE_API_KEY');
const debugMode = runtime.getSetting('EXAMPLE_DEBUG_MODE'); // Returns boolean for "true"/"false" strings
```

#### Configuration in Character File

```json
{
  "name": "MyAgent",
  "plugins": ["@elizaos/plugin-example"],
  "settings": {
    "example": {
      "enableFeatureX": true
    },
    "secrets": {
      "EXAMPLE_API_KEY": "your-api-key-here"
    }
  }
}
```

---

## Bootstrap Plugin

The Bootstrap Plugin is a foundational component of ElizaOS that initializes the core functionality required for agents to operate. It's automatically loaded as part of the initialization process, establishing the minimum viable capabilities that all agents need.

```typescript
export const bootstrapPlugin: Plugin = {
  name: 'bootstrap',
  description: 'Agent bootstrap with basic actions and evaluators',
  actions: [...],
  events: {...},
  evaluators: [...],
  providers: [...],
  services: [TaskService, ScenarioService],
};
```

The Bootstrap Plugin registers essential components across several categories to provide a foundation for all agents. These components can be extended by custom plugins.

<Tabs>
  <TabItem value="actions" label="Actions">
    | Action                 | Description                                     |
    | ---------------------- | ----------------------------------------------- |
    | `replyAction`          | Generates and sends a response to a message     |
    | `followRoomAction`     | Enables an agent to actively follow a room      |
    | `unfollowRoomAction`   | Stops an agent from following a room            |
    | `muteRoomAction`       | Mutes notifications from a room                 |
    | `unmuteRoomAction`     | Unmutes notifications from a room               |
    | `sendMessageAction`    | Sends a message to a specific room              |
    | `ignoreAction`         | Explicitly ignores a message                    |
    | `noneAction`           | Acknowledges a message without taking action    |
    | `updateEntityAction`   | Updates properties of an entity                 |
    | `choiceAction`         | Presents choices to users and handles responses |
    | `updateRoleAction`     | Updates a user's role in a world                |
    | `updateSettingsAction` | Updates agent or world settings                 |
  </TabItem>

  <TabItem value="providers" label="Providers">
    | Provider                 | Description                                                |
    | ------------------------ | ---------------------------------------------------------- |
    | `characterProvider`      | Provides the agent's personality and configuration         |
    | `recentMessagesProvider` | Retrieves recent conversation history                      |
    | `knowledgeProvider`      | Supplies factual information from the knowledge base       |
    | `timeProvider`           | Provides awareness of current time and date                |
    | `entitiesProvider`       | Supplies information about entities in the current context |
    | `relationshipsProvider`  | Provides information about entity relationships            |
    | `factsProvider`          | Retrieves relevant facts from memory                       |
    | `roleProvider`           | Provides role information within worlds                    |
    | `settingsProvider`       | Supplies configured settings                               |
    | `anxietyProvider`        | Informs agent of potential issues to be careful about      |
    | `attachmentsProvider`    | Handles media and file attachments                         |
    | `providersProvider`      | Meta-provider with information about available providers   |
    | `actionsProvider`        | Meta-provider with information about available actions     |
    | `evaluatorsProvider`     | Meta-provider with information about available evaluators  |
    | `choiceProvider`         | Manages choice-based interactions                          |
    | `capabilitiesProvider`   | Provides information about agent capabilities              |
  </TabItem>

  <TabItem value="services" label="Services & Evaluators">
    **Services:**

    | Service           | Purpose                                          |
    | ----------------- | ------------------------------------------------ |
    | `TaskService`     | Manages deferred, scheduled, and repeating tasks |
    | `ScenarioService` | Handles scenario-based interactions and testing  |

    **Evaluators:**

    | Evaluator             | Description                                           |
    | --------------------- | ----------------------------------------------------- |
    | `reflectionEvaluator` | Enables self-awareness and learning from interactions |

  </TabItem>

  <TabItem value="events" label="Event Handlers">
    The Bootstrap Plugin registers handlers for key system events that enable the core message processing flow:

    **Core Events:**
    - `MESSAGE_RECEIVED` - Processes new messages and generates responses
    - `REACTION_RECEIVED` - Tracks reactions to messages
    - `VOICE_MESSAGE_RECEIVED` - Handles audio messages
    - `POST_GENERATED` - Creates social media content
    - `MESSAGE_SENT` - Logs outgoing messages

    **World Events:**
    - `WORLD_JOINED` / `WORLD_CONNECTED` - Synchronizes data when joining worlds
    - `ENTITY_JOINED` / `ENTITY_LEFT` - Manages entity presence

    **Lifecycle Events:**
    - `ACTION_STARTED` / `ACTION_COMPLETED` - Tracks action execution
    - `EVALUATOR_STARTED` / `EVALUATOR_COMPLETED` - Monitors evaluator processing
    - `RUN_STARTED` / `RUN_ENDED` / `RUN_TIMEOUT` - Manages message processing lifecycle

    The message processing flow follows these steps:
    1. Receive message via `MESSAGE_RECEIVED` event
    2. Save message to memory
    3. Check if agent should respond
    4. If responding, compose state from providers
    5. Generate a response using the language model
    6. Process any actions specified in the response
    7. Run evaluators on the conversation
    8. Emit lifecycle events throughout the process

  </TabItem>
</Tabs>

### Extending Bootstrap Functionality

While the Bootstrap Plugin provides core functionality, it's designed to be extended by other plugins. Custom plugins can:

1. **Add new actions** - Extend the agent's capabilities
2. **Register additional providers** - Supply more contextual information
3. **Add evaluators** - Create new ways to analyze and learn from interactions
4. **Handle additional events** - React to more system events
5. **Initialize custom services** - Provide new functionality

When working with plugins in relation to the Bootstrap Plugin:

1. **Don't modify bootstrap directly** - Instead, create custom plugins to extend functionality
2. **Understand provider contribution** - Know how each provider contributes to the agent's context
3. **Learn the core actions** - Become familiar with the actions that all agents can perform
4. **Leverage event handlers** - Use the event system for reactive behavior
5. **Extend, don't replace** - Build on top of bootstrap functionality rather than replacing it

---

## Developing a Plugin

When developing a new plugin, focus on these key aspects:

1. **Service Implementation**: Create a solid service class following the pattern above
2. **Proper Error Handling**: Handle API failures gracefully
3. **Type Definitions**: Define clear interfaces and types
4. **Documentation**: Include detailed setup instructions
5. **Tests**: Add test cases for your functionality

### Testing Your Plugin

During development, you can test your plugin locally:

```bash
# Start with your plugin
elizaos start --plugins=./path/to/plugin

# Or with a specific character
elizaos start --character=./characters/test.character.json --plugins=./path/to/plugin
```

### Distribution & PR Requirements

When submitting a plugin to the [elizaOS Registry](https://github.com/elizaos-plugins/registry), include:

1. **Working Demo**: Screenshots or video of your plugin in action
2. **Test Results**: Evidence of successful integration and error handling
3. **Configuration Example**: Show how to properly configure your plugin
4. **Quality Checklist**:
   - [ ] Plugin follows the standard structure
   - [ ] Required branding assets are included
   - [ ] Documentation is complete
   - [ ] GitHub topics properly set
   - [ ] Tests are passing
   - [ ] Includes error handling

---

## FAQ

### What exactly is a plugin in ElizaOS?

A plugin is a modular extension that adds new capabilities to ElizaOS agents, such as API integrations, custom actions, or platform connections. Plugins allow you to expand agent functionality and share reusable components with other developers.

### When should I create a plugin versus using existing ones?

Create a plugin when you need custom functionality not available in existing plugins, want to integrate with external services, or plan to share reusable agent capabilities with the community.

### How do I manage plugin dependencies?

Plugin dependencies are managed through your project's `package.json`. You can add plugins directly using npm or the ElizaOS CLI, and they will be automatically loaded when your project starts.

### Can I use a plugin in development before publishing?

Yes, you can use the `--plugins` flag with the `start` command to include local plugins during development:

```bash
elizaos start --plugins=./path/to/plugin
```

### What's the difference between Actions and Services?

Actions handle specific agent responses or behaviors, while Services provide platform integrations (like Discord or Telegram) or ongoing background functionality that multiple actions might use.

### How do I handle rate limits with external APIs?

Implement proper backoff strategies in your service implementation and consider using a queue system for message handling to respect platform rate limits.

## Additional Resources

- [ElizaOS Registry](https://github.com/elizaos-plugins/registry)
- [Example Plugins](https://github.com/elizaos-plugins)
- [Discord Community](https://discord.gg/elizaos)
`````

## File: packages/docs/docs/core/project.md
`````markdown
---
sidebar_position: 2
title: Project System
description: Understanding ElizaOS projects - organizational structure for creating and deploying AI agents
keywords: [projects, organization, configuration, character, agents, deployment]
image: /img/project.jpg
---

# 📝 ElizaOS Projects

Projects are the main organizational structure in ElizaOS, containing all the necessary components to create and deploy AI agents. A project can include one or more agents, each with their own character definition, plugins, and configurations.

## Project Structure

A typical ElizaOS project structure:

```
my-eliza-project/
├── src/
│   └── index.ts        # Main entry point
├── knowledge/          # Knowledge base files
├── package.json        # Dependencies and scripts
└── tsconfig.json       # TypeScript configuration
```

## Creating a New Project

You can create a new ElizaOS project using:

```bash
# Using bun (recommended)
bun create eliza

# Or using bunx
bunx @elizaos/cli create
```

The CLI will guide you through the setup process, including:

- Project name
- Database selection (sqlite, postgres, etc.)
- Initial configuration

## Project Configuration

The main project file (`src/index.ts`) exports a default project object:

```typescript
import type { Character, IAgentRuntime, Project, ProjectAgent } from '@elizaos/core';
import customPlugin from './plugin';

// Define the character
export const character: Character = {
  name: 'Agent Name',
  plugins: ['@elizaos/plugin-discord', '@elizaos/plugin-direct'],
  // Other character properties
};

// Create a ProjectAgent that includes the character
export const projectAgent: ProjectAgent = {
  character,
  init: async (runtime: IAgentRuntime) => {
    // Initialize agent-specific functionality
    console.log('Initializing agent:', character.name);
  },
  plugins: [customPlugin],
  tests: [], // Optional tests for your agent
};

// Export the full project with all agents
const project: Project = {
  agents: [projectAgent],
};

export default project;
```

## Character Configuration

Each agent in your project requires a character definition that controls its personality, knowledge, and behavior.

### Required Character Fields

```typescript
{
  name: "agentName", // Character's display name
  plugins: ["@elizaos/plugin-discord"], // Example plugins
  settings: {
    // Configuration settings
    secrets: {}, // API keys and sensitive data
    voice: {}, // Voice configuration
  },
  bio: [], // Character background as a string or array of statements
  style: {
    // Interaction style guide
    all: [], // General style rules
    chat: [], // Chat-specific style
    post: [] // Post-specific style
  }
}
```

### Plugins

Plugins provide your agent with capabilities and integrations:

- `@elizaos/plugin-discord`: Discord integration
- `@elizaos/plugin-telegram`: Telegram integration
- `@elizaos/plugin-farcaster`: Farcaster integration
- `@elizaos/plugin-slack`: Slack integration
- `@elizaos/plugin-direct`: Direct chat interface
- `@elizaos/plugin-simsai`: SimsAI platform integration

View all available plugins: https://github.com/elizaos-plugins/registry

### Settings Configuration

The `settings` object supports various configurations:

```typescript
{
  "settings": {
    "ragKnowledge": false, // Enable RAG knowledge mode
    "voice": {
      "model": "string", // Voice synthesis model
      "url": "string" // Optional voice API URL
    },
    "secrets": {
      // API keys (use env vars in production)
      "API_KEY": "string"
    },
  }
}
```

### Bio & Style

Define your agent's personality and communication style:

```typescript
{
  "bio": ["Expert in blockchain development", "Specializes in DeFi protocols"],
  "style": {
    "all": [
      // Applied to all interactions
      "Keep responses clear",
      "Maintain professional tone"
    ],
    "chat": [
      // Chat-specific style
      "Engage with curiosity",
      "Provide explanations"
    ],
    "post": [
      // Social post style
      "Keep posts informative",
      "Focus on key points"
    ]
  }
}
```

**Style Tips**

- Be specific about tone and mannerisms
- Include platform-specific guidance
- Define clear boundaries and limitations

### Optional Character Fields

```typescript
{
  "username": "handle", // Character's username/handle
  "system": "System prompt text", // Custom system prompt
  "lore": [], // Additional background/history
  "knowledge": [
    // Knowledge base entries
    "Direct string knowledge",
    { "path": "file/path.md", "shared": false },
    { "directory": "knowledge/path", "shared": false }
  ],
  "messageExamples": [], // Example conversations
  "postExamples": [], // Example social posts
  "topics": [], // Areas of expertise
  "adjectives": [] // Character traits
}
```

## Knowledge Management

ElizaOS supports two knowledge modes:

### Classic Mode (Default)

- Direct string knowledge added to character's context
- No chunking or semantic search
- Enabled by default (`settings.ragKnowledge: false`)
- Only processes string knowledge entries
- Simpler but less sophisticated

### RAG Mode

- Advanced knowledge processing with semantic search
- Chunks content and uses embeddings
- Must be explicitly enabled (`settings.ragKnowledge: true`)
- Supports three knowledge types:
  1. Direct string knowledge
  2. Single file references: `{ "path": "path/to/file.md", "shared": false }`
  3. Directory references: `{ "directory": "knowledge/dir", "shared": false }`
- Supported file types: .md, .txt, .pdf
- Optional `shared` flag for knowledge reuse across characters

### Knowledge Path Configuration

- Knowledge files are relative to the project's `knowledge` directory
- Paths should not contain `../` (sanitized for security)
- Both shared and private knowledge supported
- Files automatically reloaded if content changes

## Example Project

Here's a complete example of a project configuration:

```typescript
import type { Character, IAgentRuntime, Project, ProjectAgent } from '@elizaos/core';

export const character: Character = {
  name: 'Tech Helper',
  plugins: ['@elizaos/plugin-discord', '@elizaos/plugin-direct'],
  settings: {
    ragKnowledge: true,
    voice: {
      model: 'en_US-male-medium',
    },
    discord: {
      shouldRespondOnlyToMentions: false,
      allowedChannelIds: ['123456789012345678'],
    },
  },
  bio: ['Friendly technical assistant', 'Specializes in explaining complex topics simply'],
  lore: ['Pioneer in open-source AI development', 'Advocate for AI accessibility'],
  messageExamples: [
    [
      {
        name: 'user1',
        content: { text: 'Can you explain how AI models work?' },
      },
      {
        name: 'TechAI',
        content: {
          text: 'Think of AI models like pattern recognition systems.',
        },
      },
    ],
  ],
  topics: ['artificial intelligence', 'machine learning', 'technology education'],
  knowledge: [
    {
      directory: 'tech_guides',
      shared: true,
    },
  ],
  style: {
    all: ['Clear', 'Patient', 'Educational'],
    chat: ['Interactive', 'Supportive'],
    post: ['Concise', 'Informative'],
  },
};

export const projectAgent: ProjectAgent = {
  character,
  init: async (runtime: IAgentRuntime) => {
    console.log('Initializing Tech Helper agent');
  },
  plugins: [], // Project-specific plugins
};

const project: Project = {
  agents: [projectAgent],
};

export default project;
```

## Character File Export

While projects are the primary structure in ElizaOS, you can still export standalone character files for compatibility with other systems or sharing character definitions:

```typescript
import fs from 'fs';
import { character } from './src/index';

// Export character to JSON file
fs.writeFileSync('character.json', JSON.stringify(character, null, 2));
```

## Managing Multiple Agents

A project can contain multiple agents, each with its own character and plugins:

```typescript
const project: Project = {
  agents: [
    {
      character: technicalSupportCharacter,
      init: async (runtime) => {
        /* init code */
      },
      plugins: [customSupportPlugin],
    },
    {
      character: communityManagerCharacter,
      init: async (runtime) => {
        /* init code */
      },
      plugins: [communityPlugin],
    },
  ],
};
```

Each agent operates independently but can share the same database and resources.

## Running Your Project

After configuring your project, you can run it using:

```bash
elizaos start
```

This will start your agents according to your project configuration.
`````

## File: packages/docs/docs/intro.md
`````markdown
---
sidebar_position: 1
title: Introduction to Eliza
description: A powerful multi-agent simulation framework for creating and managing autonomous AI agents
keywords:
  [
    introduction,
    AI agents,
    multi-agent,
    framework,
    TypeScript,
    autonomous agents,
    simulation,
    RAG,
    plugins,
  ]
image: /img/eliza_banner.jpg
---

# Introduction to Eliza

![](/img/eliza_banner.jpg)
_As seen powering [@DegenSpartanAI](https://x.com/degenspartanai) and [@aixvc_agent](https://x.com/aixvc_agent)_

## What is Eliza?

Eliza is a powerful multi-agent simulation framework designed to create, deploy, and manage autonomous AI agents. Built with TypeScript, it provides a flexible and extensible platform for developing intelligent agents that can interact across multiple platforms while maintaining consistent personalities and knowledge.

> Pro tip: copy paste the text from https://eliza.how/llms-full.txt into your preferred LLM.

## Key Features

New in Eliza v2!

| CLI Tool                          | Native GUI                        |
| --------------------------------- | --------------------------------- |
| [![](/img/cli.jpg)](/img/cli.jpg) | [![](/img/gui.jpg)](/img/gui.jpg) |

- **Platform Integration**: Clients for Discord, Telegram, Farcaster, and many others
- **Flexible Model Support**: Deepseek, Ollama, Grok, OpenAI, Anthropic, Gemini, LLama, etc.
- **Character System**: Create diverse agents using [character files](https://github.com/elizaOS/characterfile)
- **Multi-Agent Architecture**: Manage multiple unique AI personalities simultaneously
- **Memory Management**: Easily ingest and interact with documents using RAG
- **Media Processing**: PDF, URLs, Audio transcription, Video processing, Image analysis, Conversation summarization
- **Technical Foundation**:
  - 100% TypeScript implementation
  - Modular architecture
  - Highly extensible action and plugin system
  - Custom client support
  - Comprehensive API

---

## Installation

For detailed instructions on each path, including configuration options and extended capabilities, see our [Quickstart Guide](./quickstart.md).

### Prerequisites

- [Node.js 23+](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)
- Git for version control
- For Windows Users: [WSL 2](https://learn.microsoft.com/en-us/windows/wsl/install-manual) is required

Eliza offers different paths depending on your goals:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="cli" label="Install CLI Tool (Recommended)" default>

```bash
# make sure you have bun installed
npm install -g bun

# Install the CLI globally
bun install -g @elizaos/cli

# From a folder to install a project
elizaos create
cd new-agent
elizaos start
```

Then visit https://localhost:3000 to interact with your agent through a web interface.

  </TabItem>
  <TabItem value="project" label="Create a Test Project">

```bash
# Create a new project through interactive setup
elizaos create

# Navigate to your project directory
cd my-project-name

# Start your project
elizaos start
```

  </TabItem>
  <TabItem value="plugin" label="Add a Custom Plugin">

Add plugins to your project:

```bash
# List available plugins
elizaos plugins list

# Add a plugin
elizaos plugins add @elizaos/plugin-discord

# Create a plugin project
elizaos create --type plugin
```

Develop and test your plugin:

```bash
# Test your plugin
elizaos start

# Publish your plugin when ready
elizaos plugins publish
```

  </TabItem>
  <TabItem value="contribute" label="Contribute to ElizaOS Core">

```bash
# Clone the repository
git clone git@github.com:elizaOS/eliza.git
cd eliza

# We are currently on the main branch
git checkout main

# Install dependencies and build
bun install
bun run build

# Start ElizaOS
bun start
```

Visit https://localhost:3000 to interact with your agent through a web interface.

  </TabItem>
</Tabs>

> If it fails the first time try the start command again

---

## Community and Support

Eliza is backed by an active community of developers and users:

- [**Open Source**](https://github.com/elizaos/eliza): Contribute to the project on GitHub
- [**Technical Report (Whitepaper)**](https://arxiv.org/pdf/2501.06781)
- [**Awesome Eliza**](https://github.com/elizaos/awesome-eliza)
- [**Examples**](https://github.com/elizaos/characters): Ready-to-use character templates and implementations
- [**Support**](https://discord.gg/elizaos): Active community for troubleshooting and discussion

Join us in building the future of autonomous AI agents with Eliza!
`````

## File: packages/docs/partners/bossu/brief.mdx
`````
# Bossu

## Overview

Bossu is an AI agent platform specialized for Web3 applications, bridging autonomous AI systems with decentralized technologies. It partners with ElizaOS ecosystem to provide specialized Web3 capabilities complementing Eliza's general-purpose AI agent framework.

## Eliza Integration

- Integrates via ElizaOS's plugin architecture
- Technical synergies:

  - ERC-6551 token-bound accounts for unified agent identity
  - Shared memory layer for cross-platform context
  - Delegated transaction signing via Eliza's secure enclave
  - Plugin registry enabling one-click deployment

- Developer access through Eliza's plugin marketplace:

```typescript
import { BossuWeb3 } from '@elizaos-plugins/bossu-integration';
const agent = new BossuWeb3({ network: 'arbitrum' });
```

## Recent Updates (Q1 2025)

- February: Added Optimism Superchain integration support
- March: Released testnet version of cross-chain MEV protection system

## Market Position

- Niche provider in Web3 AI sector
- Competes with Chainlink Functions and OpenZeppelin Defender
- Key partnerships: LayerZero (omnichain messaging), Axiom (ZK-proof infrastructure), Socket (liquidity routing)
`````

## File: packages/docs/static/packages/adapters/mongodb.md
`````markdown
# MongoDB Adapter for ElizaOS

## Purpose

A robust MongoDB adapter for ElizaOS that provides persistence, vector search capabilities, and caching functionality.

## Key Features

- Full MongoDB database support with connection pooling
- Vector search capabilities for efficient similarity searches
- Automatic fallback to standard search when vector search is unavailable
- Built-in caching system with TTL support
- Sharding support for better performance at scale
- Comprehensive memory and knowledge management
- Relationship tracking between users
- Goal tracking and management
- Participant and room management

## Installation

```bash
npm install @elizaos-plugins/adapter-mongodb
```

## Configuration

Add the adapter to your ElizaOS configuration:

```json
{
  "plugins": ["@elizaos-plugins/adapter-mongodb"],
  "settings": {
    "MONGODB_CONNECTION_STRING": "your_mongodb_connection_string",
    "MONGODB_DATABASE": "your_database_name" // Optional, defaults to "elizaAgent"
  }
}
```

### Required Environment Variables

- `MONGODB_CONNECTION_STRING`: Your MongoDB connection string
- `MONGODB_DATABASE` (optional): Database name to use

## Integration

The adapter provides persistence, vector search, and caching functionality for ElizaOS through MongoDB.

## Example Usage

```bash
cd src/__tests__
./run_tests.sh
```
`````

## File: packages/docs/static/packages/adapters/pglite.md
`````markdown
# PGLite Adapter for ElizaOS

## Purpose

A lightweight PostgreSQL-compatible database adapter for ElizaOS, providing vector search capabilities and efficient data persistence in a local environment.

## Key Features

- Embedded PostgreSQL engine for local development and testing
- Full vector search support via pgvector
- Built-in fuzzy string matching
- Automatic schema initialization
- Memory-efficient caching system
- Support for multiple embedding providers (OpenAI, Ollama, GaiaNet)
- Transaction support with automatic rollback

## Installation

```bash
npm install @elizaos-plugins/adapter-pglite
```

## Configuration

Add the adapter to your ElizaOS configuration:

```json
{
  "plugins": ["@elizaos-plugins/adapter-pglite"],
  "settings": {
    "PGLITE_DATA_DIR": "/path/to/data/directory" // Required setting
  }
}
```

### Required Environment Variables

- `PGLITE_DATA_DIR`: Path to the directory where PGLite will store its data
  - Use `memory://` for in-memory database (useful for testing)

## Integration

The adapter automatically configures vector search based on your embedding provider and manages database tables, vector indexes, cache tables, and relationship tracking tables.
`````

## File: packages/docs/static/packages/adapters/postgres.md
`````markdown
# ElizaOS PostgreSQL Adapter

## Purpose

A database adapter plugin for ElizaOS that provides PostgreSQL connectivity with vector embedding support for semantic search capabilities.

## Key Features

- Seamless integration with ElizaOS memory and knowledge storage systems
- Vector embedding storage and retrieval with pgvector extension
- Support for multiple embedding models and dimensions
- Robust connection management with automatic retries and circuit breaking
- Full transaction support for safe database operations
- Comprehensive memory, relationship, and knowledge management
- Built-in caching system

## Installation

Install the adapter via npm:

```bash
npm install @elizaos-plugins/adapter-postgres
```

Or using bun:

```bash
bun add @elizaos-plugins/adapter-postgres
```

## Configuration

Add to ElizaOS configuration:

```javascript
// agent.config.js
export default {
  adapters: ['postgres'],
  settings: {
    POSTGRES_URL: 'postgresql://username:password@localhost:5432/elizaos',
  },
};
```

## Prerequisites

- PostgreSQL 15+ with pgvector extension installed
- Connection permissions to create tables and extensions

## Integration

The adapter automatically initializes the required database schema when first connecting, providing methods for memory management, knowledge management, and vector search using pgvector for semantic capabilities.
`````

## File: packages/docs/static/packages/adapters/qdrant.md
`````markdown
# Qdrant Adapter for ElizaOS

## Purpose

A vector database adapter for ElizaOS that provides efficient similarity search capabilities through Qdrant, optimized for knowledge management and semantic search operations.

## Key Features

- Vector similarity search with cosine distance
- Efficient knowledge base management
- Built-in text preprocessing for better search quality
- UUID v5 compatibility for Qdrant IDs
- In-memory caching system
- Content metadata support
- Shared knowledge management

## Installation

```bash
npm install @elizaos-plugins/adapter-qdrant
```

## Configuration

Add the adapter to your ElizaOS configuration:

```json
{
  "plugins": ["@elizaos-plugins/adapter-qdrant"],
  "settings": {
    "QDRANT_URL": "your-qdrant-server-url",
    "QDRANT_KEY": "your-qdrant-api-key",
    "QDRANT_PORT": "6333",
    "QDRANT_VECTOR_SIZE": "1536"
  }
}
```

### Required Environment Variables

- `QDRANT_URL`: URL of your Qdrant server
- `QDRANT_KEY`: API key for authentication
- `QDRANT_PORT`: Port number for Qdrant server
- `QDRANT_VECTOR_SIZE`: Dimension of your vectors

## Integration

The adapter implements knowledge management, vector similarity search, and caching operations for ElizaOS, while other database functions are stubbed but not implemented.
`````

## File: packages/docs/static/packages/adapters/sqlite.md
`````markdown
# SQLite Adapter

## Purpose

A SQLite database adapter for ElizaOS that provides persistent storage capabilities with vector similarity search support.

## Key Features

- Full SQLite database implementation of ElizaOS database interface
- Vector similarity search via sqlite-vec extension
- JSON validation and foreign key constraints
- Built-in caching system
- Comprehensive transaction support with circuit breaker pattern
- Support for storing and retrieving various data types including memories, accounts, goals, and knowledge base

## Installation

```bash
npm install @elizaos-plugins/adapter-sqlite
```

## Configuration

- `SQLITE_FILE`: Path to the SQLite database file (default: `./data/db.sqlite`)
- Default database location is in a `data` directory in project root

## Integration

Implements the `IDatabaseAdapter` interface and extends the `DatabaseAdapter` base class to provide a lightweight, file-based storage solution for ElizaOS.

## Example Usage

```typescript
import sqlitePlugin from '@elizaos-plugins/adapter-sqlite';
import { IAgentRuntime } from '@elizaos/core';

// Initialize with ElizaOS runtime
function initializeAgent(runtime: IAgentRuntime) {
  runtime.use(sqlitePlugin);
}
```
`````

## File: packages/docs/static/packages/adapters/supabase.md
`````markdown
# ElizaOS Supabase Adapter

## Purpose

This adapter enables ElizaOS to integrate with Supabase for data persistence and real-time capabilities.

## Prerequisites

- Supabase account and project
- ElizaOS installation
- Node.js and npm/yarn/bun

## Installation

```bash
npm install github:elizaos-plugins/adapter-supabase
```

## Configuration

1. Add the adapter to your character configuration:

```json
{
  "plugins": ["@elizaos-plugins/adapter-supabase"],
  "settings": {
    "secrets": {
      "SUPABASE_URL": "your-supabase-project-url",
      "SUPABASE_ANON_KEY": "your-supabase-anon-key"
    }
  }
}
```

2. Set up the database schema by running the migrations:

```bash
# Run the schema migration
psql -f schema.sql

# Seed the initial data
psql -f seed.sql
```

## Integration

Once configured, the adapter will automatically handle:

- Data persistence for character states and interactions
- Real-time updates for multi-user environments
- State synchronization across different instances
- Secure data storage and retrieval
`````

## File: packages/docs/static/packages/clients/alexa.md
`````markdown
# ElizaOS Alexa Client Plugin

## Purpose

Enables ElizaOS agents to integrate with Amazon Alexa, allowing your ElizaOS character to interact with users through Alexa-enabled devices.

## Key Features

- Send proactive notifications to Alexa devices
- Connect ElizaOS agents to the Alexa Skills ecosystem
- Enable voice-based interaction with your ElizaOS character

## Installation

```bash
npm install @elizaos-plugins/client-alexa
```

## Configuration

Add the following environment variables or settings to your ElizaOS configuration:

```
ALEXA_SKILL_ID=your-skill-id
ALEXA_CLIENT_ID=your-client-id
ALEXA_CLIENT_SECRET=your-client-secret
```

## Integration

The plugin connects ElizaOS characters to Alexa-enabled devices, currently supporting one-way communication through proactive message alerts.

## Links

[Alexa Developer Console](https://developer.amazon.com/alexa/console/ask)
`````

## File: packages/docs/static/packages/clients/deva.md
`````markdown
# ElizaOS Deva Client Plugin

## Purpose

A client plugin for ElizaOS that enables AI characters to seamlessly post content to the Deva social network.

## Key Features

- **Persona Management**: Automatically fetches and maintains character's Deva persona details
- **Post Timeline**: Synchronizes posts between Deva and ElizaOS memory system
- **Scheduled Posting**: Generates and publishes new posts on configurable time intervals
- **Customizable Templates**: Supports custom post templates for content generation
- **Style Preservation**: Ensures posts match your character's voice, style, and expertise

## Installation

```bash
npm install @elizaos-plugins/client-deva
```

## Configuration

Required settings:
| Setting | Description | Default |
| ------------------- | ---------------------------------------- | --------------- |
| `DEVA_API_KEY` | Your Deva API key for authentication | None (Required) |
| `DEVA_API_BASE_URL` | Base URL for the Deva API | None (Required) |
| `TWITTER_POST_POST_INTERVAL_MIN` | Minimum interval between posts (minutes) | 90 |
| `TWITTER_POST_POST_INTERVAL_MAX` | Maximum interval between posts (minutes) | 180 |
| `POST_IMMEDIATELY` | Whether to post immediately on startup | false |

## Integration

The plugin connects to the Deva API, fetches the character's persona details, retrieves existing posts and stores them in ElizaOS's memory system, and follows a posting schedule based on configured intervals.

## Example Usage

Once configured, the Deva client automatically:

1. Connects to the Deva API and fetches character's persona details
2. Retrieves existing posts and stores them in memory
3. Begins the posting schedule based on configured intervals
4. Generates and publishes new posts matching the character's style
`````

## File: packages/docs/static/packages/clients/eliza-home.md
`````markdown
# ElizaOS Home Plugin

## Purpose

Enables agents to control smart home devices, scenes, and rooms through SmartThings integration, handling commands like "turn on the lights" or "set the thermostat to 72 degrees."

## Key Features

- Control various smart home devices (lights, switches, thermostats, locks, etc.)
- Execute scenes and automations
- Discover available devices and their current states
- Process natural language commands for device control
- Group devices by room for organized management
- Support for multiple device capabilities (switch, level, color, temperature, etc.)

## Prerequisites

- A SmartThings account with connected devices
- A SmartThings personal access token
- ElizaOS installed and configured

## Installation

```bash
npm install @elizaos-plugins/client-eliza-home
```

## Configuration

Environment Variable:

- `SMARTTHINGS_TOKEN` (Required): SmartThings personal access token

Add to agent configuration:

```json
{
  "clients": ["home"]
}
```

## Integration

Connects with ElizaOS to allow agents to control smart home devices through natural language commands.

## Example Usage

- "Turn on the living room lights"
- "Set the thermostat to 72 degrees"
- "Dim the bedroom lights to 50%"
- "What devices do you see?"
- "Activate movie night scene"

## Links

[SmartThings Developer Workspace](https://account.smartthings.com/tokens)
`````

## File: packages/docs/static/packages/clients/farcaster.md
`````markdown
# ElizaOS Farcaster Client

## Purpose

A plugin for ElizaOS that enables agent integration with the Farcaster social network.

## Key Features

- **Automated Posting**: Schedule and publish regular casts with configurable intervals
- **Engagement Monitoring**: Track mentions, replies, and interactions
- **Conversation Threading**: Build and maintain conversation context for natural interactions
- **Dry Run Mode**: Test functionality without actually posting to Farcaster
- **Configurable Settings**: Customize behavior via environment variables
- **Caching**: Efficient caching of profiles and casts for improved performance

## Installation

```bash
npm install @elizaos-plugins/client-farcaster
```

## Configuration

### Required Settings

| Parameter                      | Description                            |
| ------------------------------ | -------------------------------------- |
| `FARCASTER_NEYNAR_API_KEY`     | Neynar API key for accessing Farcaster |
| `FARCASTER_NEYNAR_SIGNER_UUID` | Signer UUID for your Farcaster account |
| `FARCASTER_FID`                | Your Farcaster FID (identifier)        |

### Optional Settings

Various parameters available including dry run mode, polling intervals, and post settings.

## Integration

```typescript
import { ElizaOS } from '@elizaos/core';
import farcasterPlugin from '@elizaos-plugins/client-farcaster';

// Initialize ElizaOS
const elizaOs = new ElizaOS({
  // ElizaOS configuration
});

// Register the Farcaster plugin
elizaOs.registerPlugin(farcasterPlugin);

// Start ElizaOS
elizaOs.start();
```

## Example Usage

Custom templates can be defined in agent character configuration to customize cast generation and responses.
`````

## File: packages/docs/static/packages/clients/telegram-account.md
`````markdown
# Client Telegram Account

## Purpose

The Telegram Account Plugin allows ElizaOS agents to connect and operate through a real Telegram account, enabling your agent to participate in Telegram chats, groups, and direct messages as a regular user.

## Key Features

- Connect to any Telegram account using API credentials
- Receive and respond to direct messages
- Participate in group chats when mentioned (@username)
- Reply to messages that reply to the account
- Support for multi-part messages (automatically splits long messages)
- Proper Markdown formatting in responses
- Media attachment support

## Prerequisites

- A Telegram account with an active phone number
- Telegram API credentials (App ID and App Hash)
- ElizaOS installed and configured

## Installation

```bash
npm install @elizaos-plugins/client-telegram-account
```

## Configuration

Environment variables:

```
TELEGRAM_ACCOUNT_PHONE="+1234567890"
TELEGRAM_ACCOUNT_APP_ID=12345
TELEGRAM_ACCOUNT_APP_HASH="your_api_hash_here"
TELEGRAM_ACCOUNT_DEVICE_MODEL="Desktop"
TELEGRAM_ACCOUNT_SYSTEM_VERSION="1.0"
```

Add to agent configuration:

```json
{
  "clients": ["telegramAccount"]
}
```

## Integration

Once configured, your agent will:

- Respond to direct messages automatically
- Respond in groups when specifically mentioned with @username
- Respond to replies to its own messages
- Process incoming media files
- Format responses using Markdown
- Split long messages into multiple parts if necessary
`````

## File: packages/docs/static/packages/plugins/arbitrage.md
`````markdown
# ElizaOS Arbitrage Plugin

## Purpose

A powerful DEX arbitrage trading plugin for ElizaOS, designed to identify and automatically execute profitable cross-market trading opportunities on Ethereum-based decentralized exchanges.

## Key Features

- Real-time Market Monitoring
- Automated Opportunity Detection
- Smart Trade Execution
- Configurable Trading Parameters
- Risk Management
- Performance Optimization

## Installation

```bash
npm install @elizaos-plugins/plugin-arbitrage
```

## Configuration

```json
{
  "name": "Trader",
  "settings": {
    "secrets": {
      "EVM_PRIVATE_KEY": "YOUR_PRIVATE_KEY_HERE",
      "FLASHBOTS_RELAY_SIGNING_KEY": "YOUR_FLASHBOTS_KEY_HERE",
      "BUNDLE_EXECUTOR_ADDRESS": "YOUR_EXECUTOR_ADDRESS_HERE"
    },
    "arbitrage": {
      "ethereumWsUrl": "YOUR_ETH_WSS_URL",
      "rpcUrl": "YOUR_ETH_RPC_URL"
    }
  },
  "plugins": ["@elizaos/plugin-arbitrage", "@elizaos/plugin-evm"]
}
```

## Integration

The plugin integrates with ElizaOS and provides actions like `EXECUTE_ARBITRAGE` and providers such as `marketProvider`.

## Example Usage

```
User: "Find arbitrage opportunities"
Trader: "Scanning for arbitrage trades..."
```
`````

## File: packages/docs/static/packages/plugins/compass.md
`````markdown
# @elizaos-plugins/plugin-compass

## Purpose

A plugin that integrates the Compass API into the ElizaOS ecosystem to execute operations on DeFi protocols.

## Key Features

- Leverages the `@compass-labs/sdk` TypeScript SDK
- Provides actions corresponding to Compass API endpoints and schemas

## Installation

```
npx elizaos plugins add @elizaos-plugins/plugin-compass
bun run build
```

## Configuration

Required environment variables:

- COMPASS_WALLET_PRIVATE_KEY
- COMPASS_ARBITRUM_RPC_URL
- COMPASS_ETHEREUM_RPC_URL
- COMPASS_BASE_RPC_URL

These can also be set directly in the character configuration under settings.secrets.

## Integration

Added to the character configuration in the "plugins" array as "@elizaos-plugins/plugin-compass".

## Links

- [Compass API](https://api.compasslabs.ai/)
- [Compass SDK](https://www.npmjs.com/package/@compass-labs/sdk)
`````

## File: packages/docs/static/packages/plugins/d-a-t-a.md
`````markdown
# @elizaos-plugins/plugin-d.a.t.a

## Purpose

A Data Authentication, Trust, and Attestation framework plugin from CARV that enhances the Eliza Agent Framework with powerful data processing capabilities, enabling agents to analyze, transform, and derive insights from various data sources.

## Key Features

- Comprehensive Data Processing: Transform raw data into actionable insights through advanced analysis techniques
- Flexible Data Handling: Support for multiple data formats and sources, from CSV to JSON and APIs
- Intelligent Analysis: Leverage statistical methods and machine learning techniques for deeper understanding

## Integration

Integrates with the Eliza Agent Framework to empower AI agents with sophisticated data analysis capabilities.

## Use Cases

- On-chain stats fetching
- Token info
- On-chain address tracking (CARV ID required)

## Example Usage

Users can query token information such as AAVE, receiving detailed data about the token's category, platforms it's deployed on, and other relevant information through the plugin's data retrieval capabilities.
`````

## File: packages/docs/static/packages/plugins/flow-advanced.md
`````markdown
# @elizaos-plugins/plugin-flow-advanced

## Purpose

This plugin provides advanced functionality for the Flow Blockchain.

## Key Features

- Accounts management based on Account Linking feature
- Token Price Query for any token on Flow Blockchain
- Token Transfer from User's account to others' address
- Token Registration for any token on Flow Blockchain

## Installation

```bash
npx elizaos plugins add @elizaos-plugins/plugin-di
npx elizaos plugins add @elizaos-plugins/plugin-flow
npx elizaos plugins add @elizaos-plugins/plugin-flow-advanced
```

## Configuration

Environment variables:

```typescript
FLOW_ADDRESS=<Flow wallet address starting with 0x>
FLOW_PRIVATE_KEY=<Private key for the Flow wallet starting with 0x>
FLOW_NETWORK=<Network to connect to: "mainnet", "testnet", or "emulator" (optional, defaults to "mainnet")>
FLOW_ENDPOINT_URL=<Custom RPC endpoint URL (optional)>
```

## Integration

```typescript
import { advancedFlowPlugin } from '@elizaos-plugins/plugin-flow-advanced';
```

## Example Usage

```typescript
'Send 5 FLOW to 0xa51d7fe9e0080662';
'Send 1 FLOW - A.1654653399040a61.FlowToken to 0xa2de93114bae3e73';
'Send 1000 FROTH - 0xb73bf8e6a4477a952e0338e6cc00cc0ce5ad04ba to 0x000000000000000000000002e44fbfbd00395de5';
```
`````

## File: packages/docs/static/packages/plugins/story.md
`````markdown
# ElizaOS Story Protocol Plugin

## Purpose

A plugin for ElizaOS that enables interaction with Story Protocol - a comprehensive IP management system on the blockchain that allows creators to register, license, and manage their intellectual property assets.

## Key Features

- IP Registration: Register creative works as IP assets on Story Protocol
- License Management: Attach license terms to IP assets with customizable commercial terms
- IP Licensing: Mint license tokens for IP assets
- Asset Information: Fetch details about IP assets and available licenses
- Blockchain Integration: Built-in wallet provider for Odyssey testnet

## Installation

Install via npm:

```bash
npm install @elizaos-plugins/plugin-story
```

Or using bun:

```bash
bun add @elizaos-plugins/plugin-story
```

## Configuration

Add to ElizaOS agent configuration:

```javascript
// agent.config.js
export default {
  // Other ElizaOS configuration
  plugins: ['story'],
  settings: {
    STORY_PRIVATE_KEY: '0x...', // Your Story Protocol private key
    PINATA_JWT: '...', // Your Pinata JWT token
  },
};
```

## Integration

Integrates with Story Protocol on the Odyssey testnet, providing on-chain IP registration, programmable licensing with configurable commercial terms, creator attribution, revenue sharing, and IP relationship tracking.

## Example Usage

Register IP assets:

```
User: I'd like to register a short story I wrote called "The Digital Forest"
Agent: Great! What's the description for your IP?
User: It's a sci-fi story about a forest that exists in cyberspace
Agent: I'll register "The Digital Forest" as an IP asset on Story Protocol.
*Agent registers IP and provides transaction details*
```

## Links

- [Story Protocol Documentation](https://docs.storyprotocol.xyz)
- [Odyssey Testnet Explorer](https://odyssey.storyscan.xyz)
- [Pinata IPFS](https://www.pinata.cloud/)
`````

## File: packages/docs/static/packages/plugins/twilio.md
`````markdown
# @elizaos/plugin-twilio

## Purpose

A Twilio plugin for ElizaOS that enables SMS and voice call capabilities.

## Key Features

- SMS Messaging: Send, receive, and respond to SMS messages with natural conversation handling
- Voice Calls: Make and receive calls with natural voice conversations using ElevenLabs and speech recognition

## Installation

```bash
bun add @elizaos-plugins/plugin-twilio
```

## Configuration

1. Add plugin to character file with settings for actions and voice
2. Set environment variables in `.env` file (Twilio credentials, webhook configuration, ElevenLabs API key)
3. Configure webhooks in Twilio Console for voice and SMS
4. For local development, use ngrok to expose webhook endpoints

## Integration

- Connects with ElizaOS to enable SMS and voice communication
- Uses ElevenLabs for voice synthesis
- Uses Twilio's speech recognition capabilities for speech-to-text

## Example Usage

SMS Commands:

```
Send an SMS to +1234567890 saying Hello world!
Send SMS to +1234567890 about the weather forecast
```

Voice Call Commands:

```
Call +1234567890 and tell them about the latest updates
Call +1234567890 to say that we need to schedule a meeting
```
`````


# Instruction
# ElizaOS Developer Context

This file contains the core technical aspects of ElizaOS, focusing on its architecture, implementation, and developer-facing components. The codebase is organized as a monorepo with several key packages:

## Key Components

1. **Core Package**: The foundation of ElizaOS with the agent runtime, entity management, actions, and database interactions
2. **CLI Package**: Command-line interface for managing agents, projects, and development tasks
3. **Client Package**: Frontend interface components and API interactions
4. **SQL/Database**: Database adapters and schema management
5. **Autodoc**: Documentation generation tools

## Technical Goals

When analyzing this codebase:

- Focus on the architecture and relationships between components
- Identify core abstractions and design patterns
- Understand the runtime execution flow
- Analyze how agents, actions, and providers work together
- Look for opportunities to improve code organization and performance
- Consider modular extension points and plugin architecture

## Output Guidance

- When suggesting improvements, focus on technical aspects like code structure, performance optimizations, and architectural changes
- Include specific code examples when proposing changes
- Consider backwards compatibility and migration paths for any proposed changes
- Highlight innovative technical approaches used in the system
- When asked about implementation details, provide comprehensive technical explanations
