"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[82993],{22450:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>s,default:()=>l,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"technical/architecture/room-world-abstraction","title":"Room/World Abstraction and UUID System","description":"ElizaOS implements a sophisticated abstraction layer that maps platform-specific concepts (Discord servers, Telegram groups, etc.) to universal Room and World concepts, while maintaining agent-specific perspectives through deterministic UUID generation.","source":"@site/docs/technical/architecture/room-world-abstraction.md","sourceDirName":"technical/architecture","slug":"/technical/architecture/room-world-abstraction","permalink":"/docs/technical/architecture/room-world-abstraction","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/technical/architecture/room-world-abstraction.md","tags":[],"version":"current","lastUpdatedBy":"Sayo","lastUpdatedAt":1751802400000,"frontMatter":{}}');var a=t(31085),r=t(71184);const o={},s="Room/World Abstraction and UUID System",d={},c=[{value:"Overview",id:"overview",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Entity Hierarchy",id:"entity-hierarchy",level:3},{value:"Type Definitions",id:"type-definitions",level:3},{value:"UUID System Architecture",id:"uuid-system-architecture",level:2},{value:"Deterministic UUID Generation",id:"deterministic-uuid-generation",level:3},{value:"Agent Perspective System",id:"agent-perspective-system",level:3},{value:"Platform Mapping",id:"platform-mapping",level:2},{value:"Discord Integration",id:"discord-integration",level:3},{value:"Telegram Integration",id:"telegram-integration",level:3},{value:"Environment Context Management",id:"environment-context-management",level:2},{value:"World Creation and Management",id:"world-creation-and-management",level:3},{value:"Room Context Management",id:"room-context-management",level:3},{value:"Component System",id:"component-system",level:2},{value:"Entity Components",id:"entity-components",level:3},{value:"Memory Context Integration",id:"memory-context-integration",level:2},{value:"Context-Aware Memory Storage",id:"context-aware-memory-storage",level:3},{value:"Cross-Platform Entity Resolution",id:"cross-platform-entity-resolution",level:2},{value:"Entity Linking",id:"entity-linking",level:3},{value:"Performance Optimizations",id:"performance-optimizations",level:2},{value:"UUID Caching",id:"uuid-caching",level:3},{value:"Batch Entity Operations",id:"batch-entity-operations",level:3}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"roomworld-abstraction-and-uuid-system",children:"Room/World Abstraction and UUID System"})}),"\n",(0,a.jsx)(e.p,{children:"ElizaOS implements a sophisticated abstraction layer that maps platform-specific concepts (Discord servers, Telegram groups, etc.) to universal Room and World concepts, while maintaining agent-specific perspectives through deterministic UUID generation."}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(e.p,{children:"The Room/World abstraction system provides:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Platform Abstraction"})," - Universal concepts across different platforms"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Agent Perspectives"})," - Each agent has unique UUIDs for the same entities"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Hierarchical Organization"})," - Worlds contain rooms, rooms contain conversations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Isolation Boundaries"})," - Proper data separation between contexts"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(e.h3,{id:"entity-hierarchy",children:"Entity Hierarchy"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Universal entity hierarchy\nWorld (Discord Server, Telegram Group, etc.)\n  \u2514\u2500\u2500 Room (Discord Channel, Telegram Chat, etc.)\n      \u2514\u2500\u2500 Conversation (Message threads)\n          \u2514\u2500\u2500 Message (Individual messages)\n              \u2514\u2500\u2500 Entity (Users, Agents)\n"})}),"\n",(0,a.jsx)(e.h3,{id:"type-definitions",children:"Type Definitions"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// packages/core/src/types/environment.ts\n\ninterface World {\n  id: UUID;\n  name: string;\n  description?: string;\n  metadata: {\n    platform?: string; // 'discord', 'telegram', etc.\n    platformId?: string; // Original platform ID\n    owner?: UUID; // World owner entity\n    permissions?: Permission[];\n    settings?: WorldSettings;\n  };\n  entities: UUID[]; // Entities with access to this world\n  rooms: UUID[]; // Rooms within this world\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ninterface Room {\n  id: UUID;\n  worldId: UUID; // Parent world\n  name: string;\n  description?: string;\n  type: ChannelType; // Channel classification\n  metadata: {\n    platform?: string; // Origin platform\n    platformId?: string; // Original platform room ID\n    permissions?: Permission[];\n    settings?: RoomSettings;\n  };\n  participants: UUID[]; // Active participants\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nenum ChannelType {\n  SELF = 'SELF', // Agent's private channel\n  DM = 'DM', // Direct message\n  GROUP = 'GROUP', // Group chat\n  VOICE_DM = 'VOICE_DM', // Voice direct message\n  VOICE_GROUP = 'VOICE_GROUP', // Voice group chat\n  FEED = 'FEED', // Social media feed\n  THREAD = 'THREAD', // Threaded conversation\n  WORLD = 'WORLD', // World-level channel\n  FORUM = 'FORUM', // Forum-style discussion\n}\n\ninterface Entity {\n  id: UUID;\n  name: string;\n  username?: string;\n  metadata: {\n    platform?: string; // Origin platform\n    platformId?: string; // Original platform user ID\n    avatar?: string;\n    bio?: string;\n    roles?: string[];\n    settings?: EntitySettings;\n  };\n  components: Component[]; // Extensible entity properties\n  createdAt: Date;\n  updatedAt: Date;\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"uuid-system-architecture",children:"UUID System Architecture"}),"\n",(0,a.jsx)(e.h3,{id:"deterministic-uuid-generation",children:"Deterministic UUID Generation"}),"\n",(0,a.jsx)(e.p,{children:"The UUID system ensures each agent has a unique perspective on the same entities:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// packages/core/src/utils.ts\n\nfunction stringToUuid(target: string): UUID {\n  // Generate deterministic UUID from string using SHA1\n  const hash = crypto.createHash('sha1').update(target).digest('hex');\n\n  // Convert to UUID v4 format\n  return [\n    hash.substring(0, 8),\n    hash.substring(8, 12),\n    '4' + hash.substring(13, 16), // Version 4 identifier\n    ((parseInt(hash.substring(16, 17), 16) & 0x3) | 0x8).toString(16) + hash.substring(17, 20),\n    hash.substring(20, 32),\n  ].join('-') as UUID;\n}\n\nfunction createUniqueUuid(runtime: IAgentRuntime, baseUserId: UUID | string): UUID {\n  // Agent-specific UUID swizzling\n  const combinedString = `${baseUserId}:${runtime.agentId}`;\n  return stringToUuid(combinedString);\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"agent-perspective-system",children:"Agent Perspective System"}),"\n",(0,a.jsx)(e.p,{children:"Each agent maintains its own UUID mapping for entities:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// packages/core/src/entities.ts\n\nclass EntityManager {\n  constructor(private runtime: IAgentRuntime) {}\n\n  // Get agent-specific UUID for an entity\n  async getEntityId(platformId: string, platform: string): Promise<UUID> {\n    // Create deterministic UUID based on platform and agent\n    const baseId = `${platform}:${platformId}`;\n    return createUniqueUuid(this.runtime, baseId);\n  }\n\n  // Ensure entity exists with agent-specific perspective\n  async ensureEntityExists(entityData: {\n    platformId: string;\n    platform: string;\n    name: string;\n    username?: string;\n    metadata?: any;\n  }): Promise<Entity> {\n    const entityId = await this.getEntityId(entityData.platformId, entityData.platform);\n\n    // Check if entity already exists\n    const existing = await this.runtime.databaseAdapter.getEntity({ id: entityId });\n    if (existing) {\n      return existing;\n    }\n\n    // Create new entity with agent-specific UUID\n    const entity: Entity = {\n      id: entityId,\n      name: entityData.name,\n      username: entityData.username,\n      metadata: {\n        platform: entityData.platform,\n        platformId: entityData.platformId,\n        ...entityData.metadata,\n      },\n      components: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    await this.runtime.databaseAdapter.createEntity(entity);\n    return entity;\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"platform-mapping",children:"Platform Mapping"}),"\n",(0,a.jsx)(e.h3,{id:"discord-integration",children:"Discord Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// packages/plugin-discord/src/environment.ts\n\nclass DiscordEnvironmentManager {\n  async mapDiscordToWorld(guild: Guild): Promise<World> {\n    const worldId = stringToUuid(`discord:guild:${guild.id}`);\n\n    return {\n      id: worldId,\n      name: guild.name,\n      description: guild.description || undefined,\n      metadata: {\n        platform: 'discord',\n        platformId: guild.id,\n        owner: await this.getGuildOwnerEntityId(guild.ownerId),\n        permissions: await this.mapGuildPermissions(guild),\n        settings: {\n          memberCount: guild.memberCount,\n          features: guild.features,\n          verificationLevel: guild.verificationLevel,\n        },\n      },\n      entities: await this.getGuildMemberEntityIds(guild),\n      rooms: await this.getGuildChannelRoomIds(guild),\n      createdAt: guild.createdAt,\n      updatedAt: new Date(),\n    };\n  }\n\n  async mapDiscordToRoom(channel: GuildChannel | DMChannel, worldId?: UUID): Promise<Room> {\n    const roomId = stringToUuid(`discord:channel:${channel.id}`);\n\n    return {\n      id: roomId,\n      worldId: worldId || stringToUuid(`discord:guild:${channel.guild?.id || 'dm'}`),\n      name: channel.name || 'Direct Message',\n      description: 'description' in channel ? channel.description : undefined,\n      type: this.mapChannelType(channel),\n      metadata: {\n        platform: 'discord',\n        platformId: channel.id,\n        permissions: await this.mapChannelPermissions(channel),\n        settings: {\n          nsfw: 'nsfw' in channel ? channel.nsfw : false,\n          rateLimitPerUser: 'rateLimitPerUser' in channel ? channel.rateLimitPerUser : 0,\n        },\n      },\n      participants: await this.getChannelParticipantEntityIds(channel),\n      createdAt: channel.createdAt,\n      updatedAt: new Date(),\n    };\n  }\n\n  private mapChannelType(channel: GuildChannel | DMChannel): ChannelType {\n    if (channel.type === ChannelType.DM) return ChannelType.DM;\n    if (channel.type === ChannelType.GROUP_DM) return ChannelType.GROUP;\n    if (channel.type === ChannelType.GUILD_VOICE) return ChannelType.VOICE_GROUP;\n    if (channel.type === ChannelType.GUILD_TEXT) return ChannelType.GROUP;\n    if (channel.type === ChannelType.GUILD_FORUM) return ChannelType.FORUM;\n    return ChannelType.GROUP; // Default fallback\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"telegram-integration",children:"Telegram Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// packages/plugin-telegram/src/environment.ts\n\nclass TelegramEnvironmentManager {\n  async mapTelegramToWorld(chat: Chat): Promise<World> {\n    const worldId = stringToUuid(`telegram:chat:${chat.id}`);\n\n    return {\n      id: worldId,\n      name: chat.title || `Chat ${chat.id}`,\n      description: chat.description,\n      metadata: {\n        platform: 'telegram',\n        platformId: chat.id.toString(),\n        settings: {\n          type: chat.type,\n          memberCount:\n            'all_members_are_administrators' in chat\n              ? chat.all_members_are_administrators\n              : undefined,\n          inviteLink: 'invite_link' in chat ? chat.invite_link : undefined,\n        },\n      },\n      entities: await this.getChatMemberEntityIds(chat),\n      rooms: [worldId], // Telegram chats are typically single-room\n      createdAt: new Date(), // Telegram doesn't provide creation time\n      updatedAt: new Date(),\n    };\n  }\n\n  async mapTelegramToRoom(chat: Chat, worldId?: UUID): Promise<Room> {\n    const roomId = stringToUuid(`telegram:chat:${chat.id}`);\n\n    return {\n      id: roomId,\n      worldId: worldId || roomId, // Self-contained for Telegram\n      name: chat.title || `Chat ${chat.id}`,\n      description: chat.description,\n      type: this.mapChatType(chat),\n      metadata: {\n        platform: 'telegram',\n        platformId: chat.id.toString(),\n        settings: {\n          type: chat.type,\n          username: 'username' in chat ? chat.username : undefined,\n        },\n      },\n      participants: await this.getChatMemberEntityIds(chat),\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n  }\n\n  private mapChatType(chat: Chat): ChannelType {\n    switch (chat.type) {\n      case 'private':\n        return ChannelType.DM;\n      case 'group':\n        return ChannelType.GROUP;\n      case 'supergroup':\n        return ChannelType.GROUP;\n      case 'channel':\n        return ChannelType.FEED;\n      default:\n        return ChannelType.GROUP;\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"environment-context-management",children:"Environment Context Management"}),"\n",(0,a.jsx)(e.h3,{id:"world-creation-and-management",children:"World Creation and Management"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// packages/core/src/environment.ts\n\nclass WorldManager {\n  constructor(private runtime: IAgentRuntime) {}\n\n  async ensureWorldExists(worldData: {\n    platformId: string;\n    platform: string;\n    name: string;\n    description?: string;\n    metadata?: any;\n  }): Promise<World> {\n    const worldId = stringToUuid(`${worldData.platform}:world:${worldData.platformId}`);\n\n    // Check if world already exists\n    const existing = await this.runtime.databaseAdapter.getWorld({ id: worldId });\n    if (existing) {\n      return existing;\n    }\n\n    // Create new world\n    const world: World = {\n      id: worldId,\n      name: worldData.name,\n      description: worldData.description,\n      metadata: {\n        platform: worldData.platform,\n        platformId: worldData.platformId,\n        ...worldData.metadata,\n      },\n      entities: [],\n      rooms: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    await this.runtime.databaseAdapter.createWorld(world);\n    return world;\n  }\n\n  async addEntityToWorld(worldId: UUID, entityId: UUID): Promise<void> {\n    const world = await this.runtime.databaseAdapter.getWorld({ id: worldId });\n    if (world && !world.entities.includes(entityId)) {\n      world.entities.push(entityId);\n      world.updatedAt = new Date();\n      await this.runtime.databaseAdapter.updateWorld(world);\n    }\n  }\n\n  async addRoomToWorld(worldId: UUID, roomId: UUID): Promise<void> {\n    const world = await this.runtime.databaseAdapter.getWorld({ id: worldId });\n    if (world && !world.rooms.includes(roomId)) {\n      world.rooms.push(roomId);\n      world.updatedAt = new Date();\n      await this.runtime.databaseAdapter.updateWorld(world);\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"room-context-management",children:"Room Context Management"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"class RoomManager {\n  constructor(private runtime: IAgentRuntime) {}\n\n  async ensureRoomExists(roomData: {\n    platformId: string;\n    platform: string;\n    worldId: UUID;\n    name: string;\n    type: ChannelType;\n    metadata?: any;\n  }): Promise<Room> {\n    const roomId = stringToUuid(`${roomData.platform}:room:${roomData.platformId}`);\n\n    const existing = await this.runtime.databaseAdapter.getRoom({ id: roomId });\n    if (existing) {\n      return existing;\n    }\n\n    const room: Room = {\n      id: roomId,\n      worldId: roomData.worldId,\n      name: roomData.name,\n      type: roomData.type,\n      metadata: {\n        platform: roomData.platform,\n        platformId: roomData.platformId,\n        ...roomData.metadata,\n      },\n      participants: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    await this.runtime.databaseAdapter.createRoom(room);\n\n    // Add room to world\n    const worldManager = new WorldManager(this.runtime);\n    await worldManager.addRoomToWorld(roomData.worldId, roomId);\n\n    return room;\n  }\n\n  async addParticipantToRoom(roomId: UUID, entityId: UUID): Promise<void> {\n    const room = await this.runtime.databaseAdapter.getRoom({ id: roomId });\n    if (room && !room.participants.includes(entityId)) {\n      room.participants.push(entityId);\n      room.updatedAt = new Date();\n      await this.runtime.databaseAdapter.updateRoom(room);\n    }\n  }\n\n  async removeParticipantFromRoom(roomId: UUID, entityId: UUID): Promise<void> {\n    const room = await this.runtime.databaseAdapter.getRoom({ id: roomId });\n    if (room) {\n      room.participants = room.participants.filter((id) => id !== entityId);\n      room.updatedAt = new Date();\n      await this.runtime.databaseAdapter.updateRoom(room);\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"component-system",children:"Component System"}),"\n",(0,a.jsx)(e.h3,{id:"entity-components",children:"Entity Components"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// packages/core/src/types/component.ts\n\ninterface Component {\n  id: UUID;\n  type: ComponentType;\n  entityId: UUID;\n  data: any;\n  metadata?: {\n    source?: string;\n    platform?: string;\n    updatedAt: Date;\n    [key: string]: any;\n  };\n}\n\nenum ComponentType {\n  PROFILE = 'profile', // User profile data\n  PERMISSIONS = 'permissions', // Access permissions\n  PREFERENCES = 'preferences', // User preferences\n  ACTIVITY = 'activity', // Activity tracking\n  RELATIONSHIPS = 'relationships', // Social connections\n  CUSTOM = 'custom', // Custom component types\n}\n\nclass ComponentManager {\n  constructor(private runtime: IAgentRuntime) {}\n\n  async addComponent(\n    entityId: UUID,\n    component: Omit<Component, 'id' | 'entityId'>\n  ): Promise<Component> {\n    const componentId = stringToUuid(`${entityId}:${component.type}:${Date.now()}`);\n\n    const fullComponent: Component = {\n      id: componentId,\n      entityId,\n      ...component,\n      metadata: {\n        ...component.metadata,\n        updatedAt: new Date(),\n      },\n    };\n\n    await this.runtime.databaseAdapter.createComponent(fullComponent);\n    return fullComponent;\n  }\n\n  async getEntityComponents(entityId: UUID, type?: ComponentType): Promise<Component[]> {\n    return this.runtime.databaseAdapter.getComponents({\n      entityId,\n      type,\n    });\n  }\n\n  async updateComponent(componentId: UUID, data: any): Promise<void> {\n    const component = await this.runtime.databaseAdapter.getComponent({ id: componentId });\n    if (component) {\n      component.data = { ...component.data, ...data };\n      component.metadata = {\n        ...component.metadata,\n        updatedAt: new Date(),\n      };\n      await this.runtime.databaseAdapter.updateComponent(component);\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"memory-context-integration",children:"Memory Context Integration"}),"\n",(0,a.jsx)(e.h3,{id:"context-aware-memory-storage",children:"Context-Aware Memory Storage"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"class ContextualMemoryManager {\n  constructor(private runtime: IAgentRuntime) {}\n\n  async createMemoryWithContext(\n    content: Content,\n    context: {\n      entityId: UUID;\n      worldId?: UUID;\n      roomId?: UUID;\n      type: MemoryType;\n      scope: 'private' | 'room' | 'shared';\n    }\n  ): Promise<Memory> {\n    const memory: Memory = {\n      id: stringToUuid(`${context.entityId}:${Date.now()}`),\n      entityId: context.entityId,\n      worldId: context.worldId,\n      roomId: context.roomId,\n      content,\n      type: context.type,\n      metadata: {\n        scope: context.scope,\n        source: content.source || 'unknown',\n        timestamp: Date.now(),\n      },\n    };\n\n    // Apply agent-specific UUID swizzling for agent's perspective\n    const agentMemory = this.swizzleMemoryForAgent(memory);\n\n    await this.runtime.memory.create(agentMemory);\n    return agentMemory;\n  }\n\n  private swizzleMemoryForAgent(memory: Memory): Memory {\n    // Create agent-specific view of the memory\n    return {\n      ...memory,\n      id: createUniqueUuid(this.runtime, memory.id),\n      entityId: createUniqueUuid(this.runtime, memory.entityId),\n      worldId: memory.worldId ? createUniqueUuid(this.runtime, memory.worldId) : undefined,\n      roomId: memory.roomId ? createUniqueUuid(this.runtime, memory.roomId) : undefined,\n    };\n  }\n\n  async searchMemoriesInContext(\n    query: string,\n    context: {\n      worldId?: UUID;\n      roomId?: UUID;\n      scope?: 'private' | 'room' | 'shared';\n    }\n  ): Promise<Memory[]> {\n    const embedding = await this.runtime.embed(query);\n\n    return this.runtime.memory.searchMemoriesByEmbedding(embedding, {\n      match_threshold: 0.7,\n      count: 10,\n      tableName: 'memories',\n      worldId: context.worldId,\n      roomId: context.roomId,\n    });\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"cross-platform-entity-resolution",children:"Cross-Platform Entity Resolution"}),"\n",(0,a.jsx)(e.h3,{id:"entity-linking",children:"Entity Linking"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"class EntityLinkingManager {\n  constructor(private runtime: IAgentRuntime) {}\n\n  async linkEntitiesAcrossPlatforms(\n    primaryEntityId: UUID,\n    secondaryEntityId: UUID,\n    linkType: 'same_person' | 'alias' | 'bot_account'\n  ): Promise<void> {\n    // Create bidirectional link between entities\n    await this.createEntityLink(primaryEntityId, secondaryEntityId, linkType);\n    await this.createEntityLink(secondaryEntityId, primaryEntityId, linkType);\n  }\n\n  private async createEntityLink(\n    fromEntityId: UUID,\n    toEntityId: UUID,\n    linkType: string\n  ): Promise<void> {\n    const component: Omit<Component, 'id' | 'entityId'> = {\n      type: ComponentType.RELATIONSHIPS,\n      data: {\n        linkedEntity: toEntityId,\n        linkType,\n        strength: 1.0,\n        verified: false,\n      },\n      metadata: {\n        source: 'entity_linking',\n        updatedAt: new Date(),\n      },\n    };\n\n    const componentManager = new ComponentManager(this.runtime);\n    await componentManager.addComponent(fromEntityId, component);\n  }\n\n  async resolveEntityAliases(entityId: UUID): Promise<UUID[]> {\n    const componentManager = new ComponentManager(this.runtime);\n    const relationships = await componentManager.getEntityComponents(\n      entityId,\n      ComponentType.RELATIONSHIPS\n    );\n\n    return relationships\n      .filter((comp) => comp.data.linkType === 'alias' || comp.data.linkType === 'same_person')\n      .map((comp) => comp.data.linkedEntity);\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"performance-optimizations",children:"Performance Optimizations"}),"\n",(0,a.jsx)(e.h3,{id:"uuid-caching",children:"UUID Caching"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"class UUIDCache {\n  private cache = new Map<string, UUID>();\n  private readonly maxSize = 10000;\n\n  getOrCreateUUID(key: string, generator: () => UUID): UUID {\n    if (this.cache.has(key)) {\n      return this.cache.get(key)!;\n    }\n\n    const uuid = generator();\n\n    // Manage cache size\n    if (this.cache.size >= this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n\n    this.cache.set(key, uuid);\n    return uuid;\n  }\n\n  invalidate(key: string): void {\n    this.cache.delete(key);\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"batch-entity-operations",children:"Batch Entity Operations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"class BatchEntityManager {\n  constructor(private runtime: IAgentRuntime) {}\n\n  async createEntitiesBatch(entities: Omit<Entity, 'id'>[]): Promise<Entity[]> {\n    const created: Entity[] = [];\n\n    // Process in batches to avoid overwhelming the database\n    const batchSize = 50;\n    for (let i = 0; i < entities.length; i += batchSize) {\n      const batch = entities.slice(i, i + batchSize);\n      const batchResults = await this.processBatch(batch);\n      created.push(...batchResults);\n    }\n\n    return created;\n  }\n\n  private async processBatch(entities: Omit<Entity, 'id'>[]): Promise<Entity[]> {\n    const promises = entities.map(async (entityData) => {\n      const entityId = stringToUuid(`${entityData.name}:${Date.now()}`);\n      const entity: Entity = {\n        id: entityId,\n        ...entityData,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      await this.runtime.databaseAdapter.createEntity(entity);\n      return entity;\n    });\n\n    return Promise.all(promises);\n  }\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"This Room/World abstraction system provides ElizaOS with platform-agnostic entity management while maintaining proper isolation and agent-specific perspectives through deterministic UUID generation."})]})}function l(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(m,{...n})}):m(n)}},71184:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>s});var i=t(14041);const a={},r=i.createContext(a);function o(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);