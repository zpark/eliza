"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[36298],{64575:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"plugins/service-registration-pattern","title":"Service Registration Pattern","description":"This document describes the complete service registration pattern in Eliza, providing type safety and automatic type inference.","source":"@site/docs/plugins/service-registration-pattern.md","sourceDirName":"plugins","slug":"/plugins/service-registration-pattern","permalink":"/docs/plugins/service-registration-pattern","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/plugins/service-registration-pattern.md","tags":[],"version":"current","lastUpdatedBy":"Shaw","lastUpdatedAt":1747957163000,"frontMatter":{}}');var r=n(31085),s=n(71184);const c={},a="Service Registration Pattern",o={},l=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Creating Services",id:"creating-services",level:2},{value:"Method 1: Using Service Builder",id:"method-1-using-service-builder",level:3},{value:"Method 2: Using defineService Helper",id:"method-2-using-defineservice-helper",level:3},{value:"Method 3: Traditional Class Definition",id:"method-3-traditional-class-definition",level:3},{value:"Extending Service Types",id:"extending-service-types",level:2},{value:"1. Declare Module Augmentation",id:"1-declare-module-augmentation",level:3},{value:"2. Export Service Type Constants",id:"2-export-service-type-constants",level:3},{value:"Using Services",id:"using-services",level:2},{value:"Type-Safe Service Access",id:"type-safe-service-access",level:3},{value:"In Actions and Evaluators",id:"in-actions-and-evaluators",level:3},{value:"Complete Plugin Example",id:"complete-plugin-example",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Runtime Behavior",id:"runtime-behavior",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"service-registration-pattern",children:"Service Registration Pattern"})}),"\n",(0,r.jsx)(i.p,{children:"This document describes the complete service registration pattern in Eliza, providing type safety and automatic type inference."}),"\n",(0,r.jsx)(i.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Service Type Registry"}),": A global registry of service types that can be extended by plugins"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Type-Safe Registration"}),": Services are registered with full type safety"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Automatic Type Inference"}),": The runtime can infer service types from registration"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"creating-services",children:"Creating Services"}),"\n",(0,r.jsx)(i.h3,{id:"method-1-using-service-builder",children:"Method 1: Using Service Builder"}),"\n",(0,r.jsx)(i.p,{children:"The service builder provides a fluent API for creating services:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-typescript",children:"import { createService, ServiceType } from '@elizaos/core';\n\n// Define your service interface\ninterface MyCustomService extends Service {\n  doSomething(): Promise<string>;\n}\n\n// Create the service using the builder\nconst MyServiceClass = createService<MyCustomService>('my_custom_service')\n  .withDescription('My custom service')\n  .withStart(async (runtime) => {\n    const service = new MyServiceImpl(runtime);\n    await service.initialize();\n    return service;\n  })\n  .withStop(async () => {\n    // Cleanup logic\n  })\n  .build();\n\n// Implementation\nclass MyServiceImpl extends Service implements MyCustomService {\n  async doSomething(): Promise<string> {\n    return 'Hello from custom service!';\n  }\n\n  async stop(): Promise<void> {\n    // Cleanup\n  }\n}\n"})}),"\n",(0,r.jsx)(i.h3,{id:"method-2-using-defineservice-helper",children:"Method 2: Using defineService Helper"}),"\n",(0,r.jsxs)(i.p,{children:["For simpler cases, use the ",(0,r.jsx)(i.code,{children:"defineService"})," helper:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-typescript",children:"import { defineService, type ServiceDefinition } from '@elizaos/core';\n\nconst weatherServiceDef: ServiceDefinition<WeatherService> = {\n  serviceType: 'weather',\n  description: 'Provides weather information',\n  start: async (runtime) => {\n    return new WeatherService(runtime);\n  },\n  stop: async () => {\n    console.log('Weather service stopped');\n  },\n};\n\nexport const WeatherServiceClass = defineService(weatherServiceDef);\n"})}),"\n",(0,r.jsx)(i.h3,{id:"method-3-traditional-class-definition",children:"Method 3: Traditional Class Definition"}),"\n",(0,r.jsx)(i.p,{children:"You can still use the traditional approach:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-typescript",children:"export class TraditionalService extends Service {\n  static serviceType = 'traditional' as const;\n  capabilityDescription = 'Traditional service';\n\n  static async start(runtime: IAgentRuntime): Promise<TraditionalService> {\n    return new TraditionalService(runtime);\n  }\n\n  async stop(): Promise<void> {\n    // Cleanup\n  }\n}\n"})}),"\n",(0,r.jsx)(i.h2,{id:"extending-service-types",children:"Extending Service Types"}),"\n",(0,r.jsx)(i.h3,{id:"1-declare-module-augmentation",children:"1. Declare Module Augmentation"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-typescript",children:"// In your plugin's types.ts\ndeclare module '@elizaos/core' {\n  interface ServiceTypeRegistry {\n    WEATHER: 'weather';\n    BLOCKCHAIN: 'blockchain';\n    ANALYTICS: 'analytics';\n  }\n\n  // Optional: Map service types to their classes for better type inference\n  interface ServiceClassMap {\n    weather: typeof WeatherService;\n    blockchain: typeof BlockchainService;\n    analytics: typeof AnalyticsService;\n  }\n}\n"})}),"\n",(0,r.jsx)(i.h3,{id:"2-export-service-type-constants",children:"2. Export Service Type Constants"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-typescript",children:"export const PluginServiceTypes = {\n  WEATHER: 'weather',\n  BLOCKCHAIN: 'blockchain',\n  ANALYTICS: 'analytics',\n} as const satisfies Partial<ServiceTypeRegistry>;\n"})}),"\n",(0,r.jsx)(i.h2,{id:"using-services",children:"Using Services"}),"\n",(0,r.jsx)(i.h3,{id:"type-safe-service-access",children:"Type-Safe Service Access"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-typescript",children:"// Method 1: Generic type parameter\nconst weatherService = runtime.getService<WeatherService>('weather');\n\n// Method 2: Type-safe getter\nconst typedService = runtime.getTypedService<WeatherService>('weather');\n\n// Method 3: Check if service exists\nif (runtime.hasService('weather')) {\n  const service = runtime.getService<WeatherService>('weather');\n  // Use service\n}\n\n// Method 4: Get all registered services\nconst registeredTypes = runtime.getRegisteredServiceTypes();\nconsole.log('Available services:', registeredTypes);\n"})}),"\n",(0,r.jsx)(i.h3,{id:"in-actions-and-evaluators",children:"In Actions and Evaluators"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-typescript",children:"export const getWeatherAction: Action = {\n  name: 'GET_WEATHER',\n  description: 'Get weather information',\n  handler: async (runtime, message, state) => {\n    const weatherService = runtime.getService<WeatherService>('weather');\n\n    if (!weatherService) {\n      throw new Error('Weather service not available');\n    }\n\n    const location = state.values.location || 'New York';\n    const weather = await weatherService.getCurrentWeather(location);\n\n    return {\n      text: `The weather in ${location} is ${weather.condition} with a temperature of ${weather.temperature}\xb0C`,\n    };\n  },\n  validate: async (runtime) => {\n    return runtime.hasService('weather');\n  },\n};\n"})}),"\n",(0,r.jsx)(i.h2,{id:"complete-plugin-example",children:"Complete Plugin Example"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-typescript",children:"// types.ts\nimport { type Service } from '@elizaos/core';\n\ndeclare module '@elizaos/core' {\n  interface ServiceTypeRegistry {\n    NOTIFICATION: 'notification';\n  }\n}\n\nexport const NotificationServiceType = 'notification' as const;\n\nexport interface NotificationService extends Service {\n  sendNotification(title: string, message: string): Promise<void>;\n  getNotificationHistory(): Promise<Notification[]>;\n}\n\n// service.ts\nimport { defineService } from '@elizaos/core';\nimport { NotificationServiceType, type NotificationService } from './types';\n\nclass NotificationServiceImpl extends Service implements NotificationService {\n  private notifications: Notification[] = [];\n\n  async sendNotification(title: string, message: string): Promise<void> {\n    const notification = { title, message, timestamp: Date.now() };\n    this.notifications.push(notification);\n    // Send actual notification\n  }\n\n  async getNotificationHistory(): Promise<Notification[]> {\n    return this.notifications;\n  }\n\n  async stop(): Promise<void> {\n    this.notifications = [];\n  }\n}\n\nexport const NotificationServiceClass = defineService<NotificationService>({\n  serviceType: NotificationServiceType,\n  description: 'Handles system notifications',\n  start: async (runtime) => new NotificationServiceImpl(runtime),\n});\n\n// plugin.ts\nimport { type Plugin } from '@elizaos/core';\nimport { NotificationServiceClass } from './service';\nimport { sendNotificationAction } from './actions';\n\nexport const notificationPlugin: Plugin = {\n  name: 'notification-plugin',\n  description: 'Adds notification capabilities',\n  services: [NotificationServiceClass],\n  actions: [sendNotificationAction],\n};\n"})}),"\n",(0,r.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Always extend the ServiceTypeRegistry"})," for new service types"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Use descriptive service type names"})," (lowercase, underscore-separated)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Export service type constants"})," for use in your plugin"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Document your service interface"})," for other developers"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Validate service availability"})," before using in actions/evaluators"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Handle missing services gracefully"})," with appropriate error messages"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Clean up resources"})," in the ",(0,r.jsx)(i.code,{children:"stop()"})," method"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"runtime-behavior",children:"Runtime Behavior"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Services are initialized during plugin registration"}),"\n",(0,r.jsxs)(i.li,{children:["Services can depend on other services (check availability in ",(0,r.jsx)(i.code,{children:"start()"}),")"]}),"\n",(0,r.jsx)(i.li,{children:"The runtime maintains a single instance of each service type"}),"\n",(0,r.jsx)(i.li,{children:"Services are stopped in reverse registration order during shutdown"}),"\n",(0,r.jsx)(i.li,{children:"Service types are validated at registration time"}),"\n"]})]})}function p(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},71184:(e,i,n)=>{n.d(i,{R:()=>c,x:()=>a});var t=n(14041);const r={},s=t.createContext(r);function c(e){const i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);