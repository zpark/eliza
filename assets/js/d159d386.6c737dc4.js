"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[31841],{71184:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(14041);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},84929:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"api/plugin-interface","title":"Plugin Interface Reference","description":"This document provides the complete Plugin interface definition and all related types as implemented in the ElizaOS codebase.","source":"@site/docs/api/plugin-interface.md","sourceDirName":"api","slug":"/api/plugin-interface","permalink":"/docs/api/plugin-interface","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/api/plugin-interface.md","tags":[],"version":"current","lastUpdatedBy":"SYMBaiEX","lastUpdatedAt":1751607435000,"frontMatter":{}}');var s=t(31085),r=t(71184);const a={},o="Plugin Interface Reference",c={},l=[{value:"Plugin Interface",id:"plugin-interface",level:2},{value:"Route Type",id:"route-type",level:2},{value:"PluginEvents Type",id:"pluginevents-type",level:2},{value:"Service Class",id:"service-class",level:2},{value:"Service Type Registry",id:"service-type-registry",level:2},{value:"TypedService Interface",id:"typedservice-interface",level:2},{value:"Provider Interface",id:"provider-interface",level:2},{value:"ProviderResult Type",id:"providerresult-type",level:2},{value:"Action Interface",id:"action-interface",level:2},{value:"Evaluator Interface",id:"evaluator-interface",level:2},{value:"TestSuite Interface",id:"testsuite-interface",level:2},{value:"TestCase Interface",id:"testcase-interface",level:2},{value:"ProjectAgent Interface",id:"projectagent-interface",level:2},{value:"Project Interface",id:"project-interface",level:2},{value:"Event Types",id:"event-types",level:2},{value:"Event Handler Type",id:"event-handler-type",level:2},{value:"Usage Notes",id:"usage-notes",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"plugin-interface-reference",children:"Plugin Interface Reference"})}),"\n",(0,s.jsx)(n.p,{children:"This document provides the complete Plugin interface definition and all related types as implemented in the ElizaOS codebase."}),"\n",(0,s.jsx)(n.h2,{id:"plugin-interface",children:"Plugin Interface"}),"\n",(0,s.jsxs)(n.p,{children:["The main ",(0,s.jsx)(n.code,{children:"Plugin"})," interface defines the structure for extending agent functionality. All interfaces follow TypeScript best practices for clarity, type safety, and maintainability:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'/**\n * Plugin interface for extending agent functionality\n *\n * @example\n * ```typescript\n * const myPlugin: Plugin = {\n *   name: "example-plugin",\n *   description: "An example plugin for demonstration",\n *   actions: [myAction],\n *   providers: [myProvider],\n *   init: async (config, runtime) => {\n *     // Initialize plugin\n *   }\n * };\n * ```\n */\nexport interface Plugin {\n  /** Unique identifier for the plugin */\n  name: string;\n\n  /** Human-readable description of plugin functionality */\n  description: string;\n\n  /**\n   * Optional initialization function called when plugin is loaded\n   * @param config - Configuration object from environment variables\n   * @param runtime - Agent runtime instance for accessing services\n   */\n  init?: (config: Record<string, string>, runtime: IAgentRuntime) => Promise<void>;\n\n  /** Plugin-specific configuration settings */\n  config?: { [key: string]: any };\n\n  /** Service classes that this plugin provides */\n  services?: (typeof Service)[];\n\n  /**\n   * Entity component type definitions for structured data\n   * Used for defining custom data schemas with optional validation\n   */\n  componentTypes?: {\n    /** Component type name */\n    name: string;\n    /** JSON schema definition for the component */\n    schema: Record<string, unknown>;\n    /** Optional validation function for component data */\n    validator?: (data: any) => boolean;\n  }[];\n\n  /** Actions that the agent can perform */\n  actions?: Action[];\n\n  /** Providers for supplying contextual information */\n  providers?: Provider[];\n\n  /** Evaluators for post-interaction processing */\n  evaluators?: Evaluator[];\n\n  /** Database adapter for custom storage implementations */\n  adapter?: IDatabaseAdapter;\n\n  /**\n   * Model functions for AI/ML capabilities\n   * Maps model names to their implementation functions\n   */\n  models?: {\n    [key: string]: (...args: any[]) => Promise<any>;\n  };\n\n  /** Event handlers for plugin lifecycle events */\n  events?: PluginEvents;\n\n  /** HTTP routes exposed by the plugin */\n  routes?: Route[];\n\n  /** Test suites for plugin functionality */\n  tests?: TestSuite[];\n\n  /** Names of other plugins this plugin depends on */\n  dependencies?: string[];\n\n  /** Plugin dependencies only needed for testing */\n  testDependencies?: string[];\n\n  /** Loading priority (higher numbers load first) */\n  priority?: number;\n\n  /** JSON schema for plugin configuration validation */\n  schema?: any;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"route-type",children:"Route Type"}),"\n",(0,s.jsx)(n.p,{children:"Routes define HTTP endpoints exposed by plugins:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"/**\n * Defines an HTTP route exposed by a plugin\n *\n * @example\n * ```typescript\n * const apiRoute: Route = {\n *   type: 'GET',\n *   path: '/api/status',\n *   public: true,\n *   name: 'Status Check',\n *   handler: async (req, res, runtime) => {\n *     res.json({ status: 'running' });\n *   }\n * };\n * ```\n */\nexport type Route = {\n  /** HTTP method for the route */\n  type: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'STATIC';\n\n  /** URL path for the route (e.g., '/api/data') */\n  path: string;\n\n  /** File path for STATIC routes to serve files */\n  filePath?: string;\n\n  /** Whether the route is publicly accessible without authentication */\n  public?: boolean;\n\n  /** Display name for public routes (shown in UI tabs) */\n  name?: string extends { public: true } ? string : string | undefined;\n\n  /**\n   * Handler function for processing requests\n   * @param req - HTTP request object\n   * @param res - HTTP response object\n   * @param runtime - Agent runtime instance\n   */\n  handler?: (req: any, res: any, runtime: IAgentRuntime) => Promise<void>;\n\n  /** Whether the route expects multipart/form-data for file uploads */\n  isMultipart?: boolean;\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pluginevents-type",children:"PluginEvents Type"}),"\n",(0,s.jsx)(n.p,{children:"Defines event handlers for plugin lifecycle events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"/**\n * Event handlers mapping for plugin lifecycle events\n *\n * @example\n * ```typescript\n * const pluginEvents: PluginEvents = {\n *   MESSAGE_RECEIVED: [handleMessage],\n *   WORLD_JOINED: [handleWorldJoin],\n *   customEvent: [handleCustom]\n * };\n * ```\n */\nexport type PluginEvents = {\n  /** Standard event handlers mapped by event type */\n  [K in keyof EventPayloadMap]?: EventHandler<K>[];\n} & {\n  /** Custom event handlers for plugin-specific events */\n  [key: string]: ((params: any) => Promise<any>)[];\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"service-class",children:"Service Class"}),"\n",(0,s.jsxs)(n.p,{children:["The abstract ",(0,s.jsx)(n.code,{children:"Service"})," class provides the foundation for all plugin services:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"/**\n * Abstract base class for all ElizaOS services\n *\n * Services provide specialized functionality like transcription, video processing,\n * web browsing, and other capabilities that agents can utilize.\n *\n * @example\n * ```typescript\n * class TranscriptionService extends Service {\n *   static serviceType = 'transcription';\n *   capabilityDescription = 'Audio transcription service';\n *\n *   static async start(runtime: IAgentRuntime): Promise<Service> {\n *     return new TranscriptionService(runtime);\n *   }\n *\n *   async stop(): Promise<void> {\n *     // Cleanup logic\n *   }\n * }\n * ```\n */\nexport abstract class Service {\n  /** Runtime instance for accessing agent capabilities */\n  protected runtime!: IAgentRuntime;\n\n  /**\n   * @param runtime - Optional runtime instance, can be set later\n   */\n  constructor(runtime?: IAgentRuntime) {\n    if (runtime) {\n      this.runtime = runtime;\n    }\n  }\n\n  /** Cleanup and stop the service */\n  abstract stop(): Promise<void>;\n\n  /** Unique identifier for this service type */\n  static serviceType: string;\n\n  /** Human-readable description of service capabilities */\n  abstract capabilityDescription: string;\n\n  /** Service-specific configuration metadata */\n  config?: Metadata;\n\n  /**\n   * Start and initialize the service\n   * @param _runtime - Agent runtime instance\n   * @returns Promise resolving to the service instance\n   */\n  static async start(_runtime: IAgentRuntime): Promise<Service> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Stop the service class-wide\n   * @param _runtime - Agent runtime instance\n   * @returns Promise for cleanup completion\n   */\n  static async stop(_runtime: IAgentRuntime): Promise<unknown> {\n    throw new Error('Not implemented');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"service-type-registry",children:"Service Type Registry"}),"\n",(0,s.jsx)(n.p,{children:"The service type registry defines all available service types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export interface ServiceTypeRegistry {\n  TRANSCRIPTION: 'transcription';\n  VIDEO: 'video';\n  BROWSER: 'browser';\n  PDF: 'pdf';\n  REMOTE_FILES: 'aws_s3';\n  WEB_SEARCH: 'web_search';\n  EMAIL: 'email';\n  TEE: 'tee';\n  TASK: 'task';\n  WALLET: 'wallet';\n  LP_POOL: 'lp_pool';\n  TOKEN_DATA: 'token_data';\n  DATABASE_MIGRATION: 'database_migration';\n  PLUGIN_MANAGER: 'PLUGIN_MANAGER';\n  PLUGIN_CONFIGURATION: 'PLUGIN_CONFIGURATION';\n  PLUGIN_USER_INTERACTION: 'PLUGIN_USER_INTERACTION';\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"typedservice-interface",children:"TypedService Interface"}),"\n",(0,s.jsx)(n.p,{children:"Generic service interface with better type checking:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export interface TypedService<ConfigType extends Metadata = Metadata, ResultType = unknown>\n  extends Service {\n  /**\n   * The configuration for this service instance\n   */\n  config?: ConfigType;\n\n  /**\n   * Process an input with this service\n   * @param input The input to process\n   * @returns A promise resolving to the result\n   */\n  process(input: unknown): Promise<ResultType>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"provider-interface",children:"Provider Interface"}),"\n",(0,s.jsx)(n.p,{children:"Providers supply external data and services to the agent:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"/**\n * Provider interface for supplying contextual information to agents\n *\n * Providers act as the agent's \"senses\", gathering dynamic information\n * from external sources to inform decision-making.\n *\n * @example\n * ```typescript\n * const weatherProvider: Provider = {\n *   name: 'weather',\n *   description: 'Current weather information',\n *   get: async (runtime, message, state) => {\n *     const weather = await fetchWeather(state.location);\n *     return {\n *       text: `Current weather: ${weather.description}, ${weather.temperature}\xb0C`,\n *       data: weather\n *     };\n *   }\n * };\n * ```\n */\nexport interface Provider {\n  /** Unique identifier for the provider */\n  name: string;\n\n  /** Human-readable description of what this provider supplies */\n  description?: string;\n\n  /**\n   * Whether the provider generates dynamic content that changes over time\n   * Dynamic providers are called more frequently\n   */\n  dynamic?: boolean;\n\n  /**\n   * Position in the provider execution order\n   * Positive numbers = later in chain, negative = earlier\n   */\n  position?: number;\n\n  /**\n   * Whether the provider is private\n   *\n   * Private providers are not shown in provider lists and must be\n   * explicitly called by name from actions or other providers\n   */\n  private?: boolean;\n\n  /**\n   * Data retrieval function called when agent needs this information\n   * @param runtime - Agent runtime for accessing services and capabilities\n   * @param message - Current message context triggering the provider\n   * @param state - Current conversation state and context\n   * @returns Promise resolving to provider data\n   */\n  get: (runtime: IAgentRuntime, message: Memory, state: State) => Promise<ProviderResult>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"providerresult-type",children:"ProviderResult Type"}),"\n",(0,s.jsx)(n.p,{children:"Result structure returned by providers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export interface ProviderResult {\n  values?: {\n    [key: string]: any;\n  };\n  data?: {\n    [key: string]: any;\n  };\n  text?: string;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"action-interface",children:"Action Interface"}),"\n",(0,s.jsx)(n.p,{children:"Actions define capabilities the agent can perform:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"/**\n * Interface for defining agent actions\n *\n * Actions represent specific capabilities or behaviors that an agent\n * can execute in response to messages or triggers.\n *\n * @example\n * ```typescript\n * const sendMessageAction: Action = {\n *   name: 'SEND_MESSAGE',\n *   description: 'Send a message to a specified recipient',\n *   similes: ['message', 'send', 'communicate'],\n *   examples: [[\n *     { name: 'User', content: { text: 'Send hello to John' } },\n *     { name: 'Assistant', content: { text: 'Message sent to John: Hello!' } }\n *   ]],\n *   validate: async (runtime, message) => {\n *     return message.content.text?.includes('send');\n *   },\n *   handler: async (runtime, message, state) => {\n *     // Implementation\n *   }\n * };\n * ```\n */\nexport interface Action {\n  /** Alternative names or keywords that trigger this action */\n  similes?: string[];\n\n  /** Detailed description of what this action does */\n  description: string;\n\n  /**\n   * Example conversation flows showing how to use this action\n   * Each example is an array of message exchanges\n   */\n  examples?: ActionExample[][];\n\n  /**\n   * Handler function that executes the action\n   * @param runtime - Agent runtime instance\n   * @param message - Triggering message\n   * @param state - Current conversation state\n   * @param options - Additional options\n   * @param callback - Callback for handling responses\n   * @param responses - Previous responses in conversation\n   */\n  handler: Handler;\n\n  /** Unique name identifying this action */\n  name: string;\n\n  /**\n   * Validation function to determine if action should trigger\n   * @param runtime - Agent runtime instance\n   * @param message - Message to validate against\n   * @param state - Current conversation state\n   * @returns Promise resolving to boolean indicating if action applies\n   */\n  validate: Validator;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"evaluator-interface",children:"Evaluator Interface"}),"\n",(0,s.jsx)(n.p,{children:"Evaluators assess agent responses and behavior:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"/**\n * Interface for defining agent evaluators\n *\n * Evaluators run after interactions to assess performance, learn from\n * conversations, and update agent knowledge or behavior patterns.\n *\n * @example\n * ```typescript\n * const sentimentEvaluator: Evaluator = {\n *   name: 'SENTIMENT_ANALYSIS',\n *   description: 'Analyzes conversation sentiment for learning',\n *   alwaysRun: true,\n *   examples: [{\n *     prompt: 'Analyze the emotional tone of this conversation',\n *     messages: [\n *       { name: 'User', content: { text: 'I\\'m really frustrated with this' } },\n *       { name: 'Assistant', content: { text: 'I understand your frustration' } }\n *     ],\n *     outcome: 'Negative sentiment detected, empathetic response given'\n *   }],\n *   validate: async (runtime, message) => true,\n *   handler: async (runtime, message, state) => {\n *     // Sentiment analysis implementation\n *   }\n * };\n * ```\n */\nexport interface Evaluator {\n  /**\n   * Whether this evaluator should run after every interaction\n   * If false, only runs when validate() returns true\n   */\n  alwaysRun?: boolean;\n\n  /** Detailed description of what this evaluator analyzes */\n  description: string;\n\n  /** Alternative names or keywords for this evaluator */\n  similes?: string[];\n\n  /**\n   * Example scenarios showing what this evaluator looks for\n   * Each example includes context, sample messages, and expected outcome\n   */\n  examples: EvaluationExample[];\n\n  /**\n   * Handler function that performs the evaluation\n   * @param runtime - Agent runtime instance\n   * @param message - Message or interaction to evaluate\n   * @param state - Current conversation state\n   * @param options - Additional evaluation options\n   * @param callback - Callback for handling evaluation results\n   * @param responses - Previous responses for context\n   */\n  handler: Handler;\n\n  /** Unique name identifying this evaluator */\n  name: string;\n\n  /**\n   * Validation function to determine if evaluator should run\n   * @param runtime - Agent runtime instance\n   * @param message - Message to validate against\n   * @param state - Current conversation state\n   * @returns Promise resolving to boolean indicating if evaluator applies\n   */\n  validate: Validator;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testsuite-interface",children:"TestSuite Interface"}),"\n",(0,s.jsx)(n.p,{children:"Test suites organize related test cases:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"/**\n * Test suite for organizing related test cases\n *\n * Test suites group related tests together and are used by the ElizaOS\n * test runner to systematically validate plugin functionality.\n *\n * @example\n * ```typescript\n * const pluginTestSuite: TestSuite = {\n *   name: 'Message Processing Tests',\n *   tests: [\n *     {\n *       name: 'should process text messages',\n *       fn: async (runtime) => {\n *         const result = await runtime.processMessage(testMessage);\n *         assert(result.success);\n *       }\n *     },\n *     {\n *       name: 'should handle empty messages',\n *       fn: async (runtime) => {\n *         const result = await runtime.processMessage(emptyMessage);\n *         assert(!result.success);\n *       }\n *     }\n *   ]\n * };\n * ```\n */\nexport interface TestSuite {\n  /** Descriptive name for the test suite (e.g., \"Core Functionality Tests\") */\n  name: string;\n\n  /** Array of test cases that belong to this suite */\n  tests: TestCase[];\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testcase-interface",children:"TestCase Interface"}),"\n",(0,s.jsx)(n.p,{children:"Individual test cases for plugin functionality:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"/**\n * Individual test case for validating specific functionality\n *\n * Test cases contain the actual test logic and assertions. They receive\n * access to the agent runtime to test interactions and behaviors.\n *\n * @example\n * ```typescript\n * const greetingTest: TestCase = {\n *   name: 'should respond to greetings appropriately',\n *   fn: async (runtime) => {\n *     const message = createTestMessage('Hello!');\n *     const response = await runtime.processMessage(message);\n *\n *     assert(response, 'Should generate a response');\n *     assert(response.content.text.includes('hello'), 'Should acknowledge greeting');\n *   }\n * };\n * ```\n */\nexport interface TestCase {\n  /** Descriptive name for the test case (e.g., \"should respond to greetings\") */\n  name: string;\n\n  /**\n   * Test execution function containing the test logic and assertions\n   *\n   * @param runtime - Agent runtime instance providing access to all agent\n   *                  capabilities, services, and test utilities\n   * @returns Promise for async tests, or void for synchronous tests\n   *\n   * The function should use assertions to verify expected behavior and\n   * throw errors when tests fail.\n   */\n  fn: (runtime: IAgentRuntime) => Promise<void> | void;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"projectagent-interface",children:"ProjectAgent Interface"}),"\n",(0,s.jsx)(n.p,{children:"Defines agents within a project:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export interface ProjectAgent {\n  character: Character;\n  init?: (runtime: IAgentRuntime) => Promise<void>;\n  plugins?: Plugin[];\n  tests?: TestSuite | TestSuite[];\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"project-interface",children:"Project Interface"}),"\n",(0,s.jsx)(n.p,{children:"Top-level project structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export interface Project {\n  agents: ProjectAgent[];\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"event-types",children:"Event Types"}),"\n",(0,s.jsx)(n.p,{children:"Standard event types across all platforms:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export enum EventType {\n  // World events\n  WORLD_JOINED = 'WORLD_JOINED',\n  WORLD_CONNECTED = 'WORLD_CONNECTED',\n  WORLD_LEFT = 'WORLD_LEFT',\n\n  // Entity events\n  ENTITY_JOINED = 'ENTITY_JOINED',\n  ENTITY_LEFT = 'ENTITY_LEFT',\n  ENTITY_UPDATED = 'ENTITY_UPDATED',\n\n  // Room events\n  ROOM_JOINED = 'ROOM_JOINED',\n  ROOM_LEFT = 'ROOM_LEFT',\n\n  // Message events\n  MESSAGE_RECEIVED = 'MESSAGE_RECEIVED',\n  MESSAGE_SENT = 'MESSAGE_SENT',\n  MESSAGE_DELETED = 'MESSAGE_DELETED',\n\n  // Channel events\n  CHANNEL_CLEARED = 'CHANNEL_CLEARED',\n\n  // Voice events\n  VOICE_MESSAGE_RECEIVED = 'VOICE_MESSAGE_RECEIVED',\n  VOICE_MESSAGE_SENT = 'VOICE_MESSAGE_SENT',\n\n  // Interaction events\n  REACTION_RECEIVED = 'REACTION_RECEIVED',\n  POST_GENERATED = 'POST_GENERATED',\n  INTERACTION_RECEIVED = 'INTERACTION_RECEIVED',\n\n  // Run events\n  RUN_STARTED = 'RUN_STARTED',\n  RUN_ENDED = 'RUN_ENDED',\n  RUN_TIMEOUT = 'RUN_TIMEOUT',\n\n  // Action events\n  ACTION_STARTED = 'ACTION_STARTED',\n  ACTION_COMPLETED = 'ACTION_COMPLETED',\n\n  // Evaluator events\n  EVALUATOR_STARTED = 'EVALUATOR_STARTED',\n  EVALUATOR_COMPLETED = 'EVALUATOR_COMPLETED',\n\n  // Model events\n  MODEL_USED = 'MODEL_USED',\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"event-handler-type",children:"Event Handler Type"}),"\n",(0,s.jsx)(n.p,{children:"Generic event handler function type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export type EventHandler<T extends keyof EventPayloadMap> = (\n  payload: EventPayloadMap[T]\n) => Promise<void>;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"usage-notes",children:"Usage Notes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Plugin Registration"}),": Plugins are registered with the runtime through the ",(0,s.jsx)(n.code,{children:"plugins"})," array in ",(0,s.jsx)(n.code,{children:"ProjectAgent"})," or directly via the runtime's plugin management system."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Service Integration"}),": Services are registered using the ",(0,s.jsx)(n.code,{children:"ServiceType"})," constants and can be accessed via ",(0,s.jsx)(n.code,{children:"runtime.getService()"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Event Handling"}),": Plugin events are automatically registered when the plugin is loaded and are triggered based on the event type."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Route Exposure"}),": HTTP routes with ",(0,s.jsx)(n.code,{children:"public: true"})," are exposed as HTML tabs in the agent interface."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Testing"}),": Use the ",(0,s.jsx)(n.code,{children:"TestSuite"})," structure to organize plugin tests, which can be run via the ElizaOS test runner."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This interface provides a comprehensive foundation for creating modular, extensible plugins that integrate seamlessly with the ElizaOS agent runtime."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);