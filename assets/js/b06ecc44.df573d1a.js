"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[82e3],{45124:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"technical/integrations/twitter-technical","title":"Twitter Technical Integration Guide","description":"This guide covers the technical implementation details of Twitter integration in ElizaOS, including API implementation, architecture patterns, and advanced development techniques.","source":"@site/docs/technical/integrations/twitter-technical.md","sourceDirName":"technical/integrations","slug":"/technical/integrations/twitter-technical","permalink":"/docs/technical/integrations/twitter-technical","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/technical/integrations/twitter-technical.md","tags":[],"version":"current","lastUpdatedBy":"SYMBaiEX","lastUpdatedAt":1751607435000,"frontMatter":{},"sidebar":"technicalSidebar","previous":{"title":"\ud83d\udcf1 Telegram Technical Integration","permalink":"/docs/technical/integrations/telegram-technical"},"next":{"title":"\u2728 Best Practices","permalink":"/docs/technical/advanced/best-practices"}}');var r=t(31085),a=t(71184);const s={},o="Twitter Technical Integration Guide",c={},l=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Twitter Plugin Architecture",id:"twitter-plugin-architecture",level:3},{value:"Core Components",id:"core-components",level:3},{value:"Twitter Client Implementation",id:"twitter-client-implementation",level:2},{value:"Basic Client Structure",id:"basic-client-structure",level:3},{value:"Authentication Implementation",id:"authentication-implementation",level:3},{value:"Content Generation System",id:"content-generation-system",level:2},{value:"Dynamic Content Pipeline",id:"dynamic-content-pipeline",level:3},{value:"Engagement Management",id:"engagement-management",level:2},{value:"Intelligent Response System",id:"intelligent-response-system",level:3},{value:"Data Models and Storage",id:"data-models-and-storage",level:2},{value:"Twitter Data Models",id:"twitter-data-models",level:3},{value:"Database Schema",id:"database-schema",level:3},{value:"Advanced Features Implementation",id:"advanced-features-implementation",level:2},{value:"Trend Analysis and Topic Detection",id:"trend-analysis-and-topic-detection",level:3},{value:"Sentiment Analysis Integration",id:"sentiment-analysis-integration",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Rate Limiting and Request Management",id:"rate-limiting-and-request-management",level:3},{value:"Caching Strategy",id:"caching-strategy",level:3},{value:"Testing and Quality Assurance",id:"testing-and-quality-assurance",level:2},{value:"Unit Testing Framework",id:"unit-testing-framework",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Deployment and Monitoring",id:"deployment-and-monitoring",level:2},{value:"Production Configuration",id:"production-configuration",level:3},{value:"Monitoring and Alerting",id:"monitoring-and-alerting",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"API Key Management",id:"api-key-management",level:3},{value:"Content Safety",id:"content-safety",level:3},{value:"Troubleshooting and Debugging",id:"troubleshooting-and-debugging",level:2},{value:"Debug Logging",id:"debug-logging",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",mermaid:"mermaid",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"twitter-technical-integration-guide",children:"Twitter Technical Integration Guide"})}),"\n",(0,r.jsx)(n.p,{children:"This guide covers the technical implementation details of Twitter integration in ElizaOS, including API implementation, architecture patterns, and advanced development techniques."}),"\n",(0,r.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,r.jsx)(n.h3,{id:"twitter-plugin-architecture",children:"Twitter Plugin Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The ElizaOS Twitter integration follows a modular plugin architecture:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface TwitterPlugin {\n  name: string;\n  description: string;\n  clients: TwitterClient[];\n  providers: TwitterProvider[];\n  actions: TwitterAction[];\n  evaluators: TwitterEvaluator[];\n  services: TwitterService[];\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[TwitterClient] --\x3e B[TwitterService]\n    B --\x3e C[TwitterAPI]\n    B --\x3e D[ContentGenerator]\n    B --\x3e E[EngagementManager]\n\n    F[TwitterProvider] --\x3e G[TimelineProvider]\n    F --\x3e H[UserProvider]\n    F --\x3e I[TrendProvider]\n\n    J[TwitterAction] --\x3e K[PostAction]\n    J --\x3e L[ReplyAction]\n    J --\x3e M[RetweetAction]\n\n    N[TwitterEvaluator] --\x3e O[EngagementEvaluator]\n    N --\x3e P[SentimentEvaluator]\n    N --\x3e Q[ContentEvaluator]"}),"\n",(0,r.jsx)(n.h2,{id:"twitter-client-implementation",children:"Twitter Client Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"basic-client-structure",children:"Basic Client Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { TwitterApi } from 'twitter-api-v2';\nimport { Client, IAgentRuntime } from '@elizaos/core';\n\nexport class TwitterClient extends Client {\n  private twitter: TwitterApi;\n  private runtime: IAgentRuntime;\n\n  constructor(runtime: IAgentRuntime) {\n    super();\n    this.runtime = runtime;\n    this.initializeTwitterApi();\n  }\n\n  private initializeTwitterApi(): void {\n    this.twitter = new TwitterApi({\n      appKey: process.env.TWITTER_API_KEY!,\n      appSecret: process.env.TWITTER_API_SECRET!,\n      accessToken: process.env.TWITTER_ACCESS_TOKEN!,\n      accessSecret: process.env.TWITTER_ACCESS_TOKEN_SECRET!,\n    });\n  }\n\n  async start(): Promise<void> {\n    console.log('Starting Twitter client...');\n\n    // Start monitoring mentions and DMs\n    await this.startMentionMonitoring();\n    await this.startDirectMessageMonitoring();\n\n    // Start periodic posting if enabled\n    if (this.shouldStartPeriodicPosting()) {\n      await this.startPeriodicPosting();\n    }\n  }\n\n  async stop(): Promise<void> {\n    console.log('Stopping Twitter client...');\n    // Cleanup and stop monitoring\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"authentication-implementation",children:"Authentication Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface TwitterAuthConfig {\n  apiKey: string;\n  apiSecret: string;\n  accessToken: string;\n  accessTokenSecret: string;\n  bearerToken?: string;\n  clientId?: string;\n  clientSecret?: string;\n}\n\nclass TwitterAuth {\n  private config: TwitterAuthConfig;\n\n  constructor(config: TwitterAuthConfig) {\n    this.config = config;\n  }\n\n  // OAuth 1.0a implementation\n  async authenticateOAuth1(): Promise<TwitterApi> {\n    return new TwitterApi({\n      appKey: this.config.apiKey,\n      appSecret: this.config.apiSecret,\n      accessToken: this.config.accessToken,\n      accessSecret: this.config.accessTokenSecret,\n    });\n  }\n\n  // OAuth 2.0 implementation for newer features\n  async authenticateOAuth2(): Promise<TwitterApi> {\n    return new TwitterApi({\n      clientId: this.config.clientId!,\n      clientSecret: this.config.clientSecret!,\n    });\n  }\n\n  // Bearer token for read-only operations\n  async authenticateBearerToken(): Promise<TwitterApi> {\n    return new TwitterApi(this.config.bearerToken!);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"content-generation-system",children:"Content Generation System"}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-content-pipeline",children:"Dynamic Content Pipeline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface ContentGenerationContext {\n  character: Character;\n  recentTweets: Tweet[];\n  mentions: Mention[];\n  trends: Trend[];\n  sentiment: SentimentAnalysis;\n  timeContext: TimeContext;\n}\n\nclass TwitterContentGenerator {\n  private runtime: IAgentRuntime;\n\n  constructor(runtime: IAgentRuntime) {\n    this.runtime = runtime;\n  }\n\n  async generateTweet(context: ContentGenerationContext): Promise<string> {\n    // Build comprehensive context for AI generation\n    const prompt = this.buildContentPrompt(context);\n\n    // Generate content using AI model\n    const response = await this.runtime.model.generate({\n      prompt,\n      context: this.buildModelContext(context),\n      temperature: 0.8,\n      maxTokens: 100, // Twitter character limit consideration\n    });\n\n    // Post-process and validate content\n    return this.postProcessContent(response.text, context);\n  }\n\n  private buildContentPrompt(context: ContentGenerationContext): string {\n    return `\n      Generate a Twitter post for ${context.character.name} with the following context:\n      \n      Character Personality:\n      ${JSON.stringify(context.character.personality, null, 2)}\n      \n      Recent Activity:\n      ${context.recentTweets.map((t) => `- ${t.text}`).join('\\n')}\n      \n      Current Trends:\n      ${context.trends.map((t) => `- ${t.name}`).join('\\n')}\n      \n      Time Context: ${context.timeContext.timeOfDay} on ${context.timeContext.dayOfWeek}\n      \n      Requirements:\n      - Stay in character\n      - Be engaging and authentic\n      - Include relevant hashtags (2-3 max)\n      - Stay under 280 characters\n      - Avoid repetition of recent posts\n    `;\n  }\n\n  private postProcessContent(content: string, context: ContentGenerationContext): string {\n    // Remove unwanted characters\n    content = content.replace(/[^\\w\\s@#.,!?'\"-]/g, '');\n\n    // Ensure character limit\n    if (content.length > 280) {\n      content = content.substring(0, 277) + '...';\n    }\n\n    // Add context-appropriate hashtags\n    content = this.addRelevantHashtags(content, context);\n\n    return content.trim();\n  }\n\n  private addRelevantHashtags(content: string, context: ContentGenerationContext): string {\n    const character = context.character;\n    const hashtagsToAdd: string[] = [];\n\n    // Add character-specific hashtags\n    if (character.topics) {\n      const relevantTopics = character.topics.slice(0, 2);\n      hashtagsToAdd.push(...relevantTopics.map((topic) => `#${topic.replace(/\\s+/g, '')}`));\n    }\n\n    // Add trending hashtags if relevant\n    const relevantTrends = context.trends\n      .filter((trend) =>\n        character.topics?.some((topic) => trend.name.toLowerCase().includes(topic.toLowerCase()))\n      )\n      .slice(0, 1);\n\n    hashtagsToAdd.push(...relevantTrends.map((trend) => trend.name));\n\n    // Append hashtags if they fit within character limit\n    let finalContent = content;\n    for (const hashtag of hashtagsToAdd) {\n      const testContent = `${finalContent} ${hashtag}`;\n      if (testContent.length <= 280) {\n        finalContent = testContent;\n      } else {\n        break;\n      }\n    }\n\n    return finalContent;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"engagement-management",children:"Engagement Management"}),"\n",(0,r.jsx)(n.h3,{id:"intelligent-response-system",children:"Intelligent Response System"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface EngagementContext {\n  mention: Mention;\n  userHistory: UserInteraction[];\n  conversationThread: Tweet[];\n  userProfile: TwitterUser;\n  sentiment: SentimentScore;\n}\n\nclass TwitterEngagementManager {\n  private runtime: IAgentRuntime;\n  private responseStrategies: Map<string, ResponseStrategy>;\n\n  constructor(runtime: IAgentRuntime) {\n    this.runtime = runtime;\n    this.initializeResponseStrategies();\n  }\n\n  async handleMention(mention: Mention): Promise<void> {\n    // Analyze engagement context\n    const context = await this.buildEngagementContext(mention);\n\n    // Determine if response is appropriate\n    if (!(await this.shouldRespond(context))) {\n      return;\n    }\n\n    // Generate contextual response\n    const response = await this.generateResponse(context);\n\n    // Post response with rate limiting\n    await this.postResponse(mention, response);\n  }\n\n  private async shouldRespond(context: EngagementContext): Promise<boolean> {\n    // Check sentiment\n    if (context.sentiment.score < -0.5) {\n      console.log('Skipping negative sentiment mention');\n      return false;\n    }\n\n    // Check for spam indicators\n    if (this.isSpamLikely(context.mention)) {\n      return false;\n    }\n\n    // Check rate limiting\n    if (await this.isRateLimited(context.userProfile.id)) {\n      return false;\n    }\n\n    // Check if we can add value to the conversation\n    return this.canAddValue(context);\n  }\n\n  private async generateResponse(context: EngagementContext): Promise<string> {\n    const strategy = this.getResponseStrategy(context);\n\n    const prompt = `\n      Respond to this Twitter mention as ${this.runtime.character.name}:\n      \n      Original Tweet: \"${context.mention.text}\"\n      User: @${context.mention.user.username}\n      User Profile: ${context.userProfile.description}\n      Conversation Context: ${context.conversationThread.map((t) => t.text).join(' -> ')}\n      \n      Response Strategy: ${strategy.name}\n      Character Personality: ${JSON.stringify(this.runtime.character.personality)}\n      \n      Requirements:\n      - Stay in character\n      - Be helpful and engaging\n      - Keep response under 280 characters\n      - Match the tone of the conversation\n      - Add value to the discussion\n    `;\n\n    const response = await this.runtime.model.generate({\n      prompt,\n      temperature: 0.7,\n      maxTokens: 80,\n    });\n\n    return this.validateResponse(response.text, context);\n  }\n\n  private getResponseStrategy(context: EngagementContext): ResponseStrategy {\n    // Determine strategy based on context\n    if (context.mention.text.includes('?')) {\n      return this.responseStrategies.get('question')!;\n    }\n\n    if (context.sentiment.score > 0.7) {\n      return this.responseStrategies.get('positive')!;\n    }\n\n    if (context.userHistory.length > 5) {\n      return this.responseStrategies.get('familiar')!;\n    }\n\n    return this.responseStrategies.get('default')!;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"data-models-and-storage",children:"Data Models and Storage"}),"\n",(0,r.jsx)(n.h3,{id:"twitter-data-models",children:"Twitter Data Models"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface TwitterUser {\n  id: string;\n  username: string;\n  displayName: string;\n  description: string;\n  followersCount: number;\n  followingCount: number;\n  tweetCount: number;\n  verified: boolean;\n  createdAt: Date;\n}\n\ninterface Tweet {\n  id: string;\n  text: string;\n  authorId: string;\n  createdAt: Date;\n  replyToTweetId?: string;\n  quoteTweetId?: string;\n  retweetCount: number;\n  likeCount: number;\n  replyCount: number;\n  hashtags: string[];\n  mentions: string[];\n  urls: string[];\n  media?: MediaAttachment[];\n}\n\ninterface Mention extends Tweet {\n  mentionedUserId: string;\n  isReply: boolean;\n  isQuoteTweet: boolean;\n  conversationId: string;\n}\n\ninterface UserInteraction {\n  userId: string;\n  interactionType: 'mention' | 'reply' | 'retweet' | 'like';\n  tweetId: string;\n  timestamp: Date;\n  sentiment: SentimentScore;\n  responseGenerated: boolean;\n  responseId?: string;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"database-schema",children:"Database Schema"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- Twitter users table\nCREATE TABLE twitter_users (\n  id VARCHAR(255) PRIMARY KEY,\n  username VARCHAR(255) UNIQUE NOT NULL,\n  display_name VARCHAR(255),\n  description TEXT,\n  followers_count INTEGER DEFAULT 0,\n  following_count INTEGER DEFAULT 0,\n  tweet_count INTEGER DEFAULT 0,\n  verified BOOLEAN DEFAULT FALSE,\n  created_at TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Tweets table\nCREATE TABLE tweets (\n  id VARCHAR(255) PRIMARY KEY,\n  text TEXT NOT NULL,\n  author_id VARCHAR(255) REFERENCES twitter_users(id),\n  created_at TIMESTAMP,\n  reply_to_tweet_id VARCHAR(255),\n  quote_tweet_id VARCHAR(255),\n  retweet_count INTEGER DEFAULT 0,\n  like_count INTEGER DEFAULT 0,\n  reply_count INTEGER DEFAULT 0,\n  hashtags JSON,\n  mentions JSON,\n  urls JSON,\n  media JSON,\n  INDEX idx_author_created (author_id, created_at),\n  INDEX idx_mentions (mentions),\n  INDEX idx_created_at (created_at)\n);\n\n-- User interactions table\nCREATE TABLE user_interactions (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id VARCHAR(255) REFERENCES twitter_users(id),\n  interaction_type VARCHAR(50) NOT NULL,\n  tweet_id VARCHAR(255) REFERENCES tweets(id),\n  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  sentiment_score DECIMAL(3,2),\n  response_generated BOOLEAN DEFAULT FALSE,\n  response_id VARCHAR(255),\n  INDEX idx_user_timestamp (user_id, timestamp),\n  INDEX idx_interaction_type (interaction_type),\n  INDEX idx_timestamp (timestamp)\n);\n\n-- Content generation history\nCREATE TABLE content_generation_history (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  agent_id VARCHAR(255) NOT NULL,\n  content_type VARCHAR(50) NOT NULL,\n  generated_content TEXT NOT NULL,\n  context_data JSON,\n  generation_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  posted_tweet_id VARCHAR(255),\n  engagement_metrics JSON,\n  INDEX idx_agent_timestamp (agent_id, generation_timestamp),\n  INDEX idx_content_type (content_type)\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-features-implementation",children:"Advanced Features Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"trend-analysis-and-topic-detection",children:"Trend Analysis and Topic Detection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class TwitterTrendAnalyzer {\n  private runtime: IAgentRuntime;\n  private trendCache: Map<string, TrendData[]>;\n\n  constructor(runtime: IAgentRuntime) {\n    this.runtime = runtime;\n    this.trendCache = new Map();\n  }\n\n  async analyzeTrends(location: string = 'worldwide'): Promise<TrendData[]> {\n    // Check cache first\n    const cached = this.trendCache.get(location);\n    if (cached && this.isCacheValid(cached)) {\n      return cached;\n    }\n\n    // Fetch trends from Twitter API\n    const trends = await this.fetchTrendsFromAPI(location);\n\n    // Analyze trend relevance to character\n    const relevantTrends = await this.filterRelevantTrends(trends);\n\n    // Cache results\n    this.trendCache.set(location, relevantTrends);\n\n    return relevantTrends;\n  }\n\n  private async filterRelevantTrends(trends: RawTrend[]): Promise<TrendData[]> {\n    const character = this.runtime.character;\n    const relevantTrends: TrendData[] = [];\n\n    for (const trend of trends) {\n      const relevanceScore = await this.calculateTrendRelevance(trend, character);\n\n      if (relevanceScore > 0.3) {\n        relevantTrends.push({\n          ...trend,\n          relevanceScore,\n          suggestedHashtags: this.generateHashtagSuggestions(trend),\n          contentOpportunities: await this.identifyContentOpportunities(trend, character),\n        });\n      }\n    }\n\n    return relevantTrends.sort((a, b) => b.relevanceScore - a.relevanceScore);\n  }\n\n  private async calculateTrendRelevance(trend: RawTrend, character: Character): Promise<number> {\n    // Use AI to calculate relevance score\n    const prompt = `\n      Rate the relevance of this trending topic to the character on a scale of 0-1:\n      \n      Trending Topic: ${trend.name}\n      Topic Description: ${trend.description || 'No description'}\n      \n      Character Interests: ${character.topics?.join(', ') || 'General'}\n      Character Bio: ${character.bio?.join(' ') || 'No bio'}\n      Character Personality: ${JSON.stringify(character.personality)}\n      \n      Return only a number between 0 and 1.\n    `;\n\n    const response = await this.runtime.model.generate({\n      prompt,\n      temperature: 0.1,\n      maxTokens: 5,\n    });\n\n    return Math.min(1, Math.max(0, parseFloat(response.text) || 0));\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sentiment-analysis-integration",children:"Sentiment Analysis Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface SentimentAnalysisResult {\n  score: number; // -1 to 1\n  magnitude: number; // 0 to 1\n  emotions: {\n    joy: number;\n    anger: number;\n    fear: number;\n    sadness: number;\n    surprise: number;\n  };\n  confidence: number;\n}\n\nclass TwitterSentimentAnalyzer {\n  private sentimentAPI: SentimentAPI;\n\n  constructor() {\n    this.sentimentAPI = new SentimentAPI();\n  }\n\n  async analyzeTweet(tweet: string): Promise<SentimentAnalysisResult> {\n    // Clean tweet text\n    const cleanText = this.cleanTweetForAnalysis(tweet);\n\n    // Analyze sentiment using multiple methods\n    const [basicSentiment, emotionAnalysis, contextualSentiment] = await Promise.all([\n      this.basicSentimentAnalysis(cleanText),\n      this.emotionAnalysis(cleanText),\n      this.contextualSentimentAnalysis(cleanText),\n    ]);\n\n    // Combine results\n    return this.combineSentimentResults(basicSentiment, emotionAnalysis, contextualSentiment);\n  }\n\n  private cleanTweetForAnalysis(tweet: string): string {\n    return tweet\n      .replace(/https?:\\/\\/[^\\s]+/g, '') // Remove URLs\n      .replace(/@\\w+/g, '') // Remove mentions\n      .replace(/#\\w+/g, '') // Remove hashtags\n      .replace(/[^\\w\\s.,!?]/g, '') // Remove special characters\n      .trim();\n  }\n\n  private async basicSentimentAnalysis(text: string): Promise<SentimentScore> {\n    // Implement basic sentiment analysis\n    const response = await this.sentimentAPI.analyze(text);\n    return {\n      score: response.compound,\n      positive: response.pos,\n      negative: response.neg,\n      neutral: response.neu,\n    };\n  }\n\n  private async emotionAnalysis(text: string): Promise<EmotionScores> {\n    // Implement emotion detection\n    const emotions = await this.sentimentAPI.analyzeEmotions(text);\n    return emotions;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"rate-limiting-and-request-management",children:"Rate Limiting and Request Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class TwitterRateLimiter {\n  private endpoints: Map<string, RateLimitInfo>;\n  private requestQueue: RequestQueue;\n\n  constructor() {\n    this.endpoints = new Map();\n    this.requestQueue = new RequestQueue();\n    this.initializeRateLimits();\n  }\n\n  async makeRequest<T>(endpoint: string, requestFn: () => Promise<T>): Promise<T> {\n    // Check rate limit\n    await this.checkRateLimit(endpoint);\n\n    // Add to queue\n    return this.requestQueue.add(async () => {\n      try {\n        const result = await requestFn();\n        this.updateRateLimitInfo(endpoint);\n        return result;\n      } catch (error) {\n        if (this.isRateLimitError(error)) {\n          await this.handleRateLimitError(endpoint, error);\n          throw error;\n        }\n        throw error;\n      }\n    });\n  }\n\n  private async checkRateLimit(endpoint: string): Promise<void> {\n    const rateLimitInfo = this.endpoints.get(endpoint);\n\n    if (!rateLimitInfo) {\n      return; // No rate limit info, proceed\n    }\n\n    const now = Date.now();\n    const timeSinceReset = now - rateLimitInfo.resetTime;\n\n    if (timeSinceReset < 0 && rateLimitInfo.remaining <= 0) {\n      // Wait until reset time\n      const waitTime = -timeSinceReset;\n      console.log(`Rate limit reached for ${endpoint}, waiting ${waitTime}ms`);\n      await this.sleep(waitTime);\n    }\n  }\n\n  private updateRateLimitInfo(endpoint: string): void {\n    const info = this.endpoints.get(endpoint);\n    if (info) {\n      info.remaining = Math.max(0, info.remaining - 1);\n    }\n  }\n\n  private async handleRateLimitError(endpoint: string, error: any): Promise<void> {\n    // Extract rate limit info from error headers\n    const resetTime = parseInt(error.headers?.['x-rate-limit-reset']) * 1000;\n    const remaining = parseInt(error.headers?.['x-rate-limit-remaining']) || 0;\n\n    this.endpoints.set(endpoint, {\n      limit: parseInt(error.headers?.['x-rate-limit-limit']) || 300,\n      remaining,\n      resetTime,\n    });\n\n    // Wait until reset if needed\n    const waitTime = resetTime - Date.now();\n    if (waitTime > 0) {\n      await this.sleep(waitTime);\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"caching-strategy",children:"Caching Strategy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class TwitterCacheManager {\n  private cache: Map<string, CacheEntry>;\n  private readonly defaultTTL = 5 * 60 * 1000; // 5 minutes\n\n  constructor() {\n    this.cache = new Map();\n    this.startCleanupInterval();\n  }\n\n  async get<T>(key: string, fetcher: () => Promise<T>, ttl?: number): Promise<T> {\n    const cached = this.cache.get(key);\n\n    if (cached && !this.isExpired(cached)) {\n      return cached.data as T;\n    }\n\n    // Fetch fresh data\n    const data = await fetcher();\n\n    // Cache the result\n    this.set(key, data, ttl);\n\n    return data;\n  }\n\n  set<T>(key: string, data: T, ttl?: number): void {\n    const expiresAt = Date.now() + (ttl || this.defaultTTL);\n\n    this.cache.set(key, {\n      data,\n      expiresAt,\n      createdAt: Date.now(),\n    });\n  }\n\n  private isExpired(entry: CacheEntry): boolean {\n    return Date.now() > entry.expiresAt;\n  }\n\n  private startCleanupInterval(): void {\n    setInterval(() => {\n      const now = Date.now();\n      for (const [key, entry] of this.cache.entries()) {\n        if (now > entry.expiresAt) {\n          this.cache.delete(key);\n        }\n      }\n    }, 60000); // Cleanup every minute\n  }\n\n  // Cache strategies for different data types\n  async getUserProfile(userId: string): Promise<TwitterUser> {\n    return this.get(\n      `user:${userId}`,\n      () => this.fetchUserProfile(userId),\n      30 * 60 * 1000 // 30 minutes TTL for user profiles\n    );\n  }\n\n  async getTrends(location: string): Promise<TrendData[]> {\n    return this.get(\n      `trends:${location}`,\n      () => this.fetchTrends(location),\n      15 * 60 * 1000 // 15 minutes TTL for trends\n    );\n  }\n\n  async getConversationHistory(tweetId: string): Promise<Tweet[]> {\n    return this.get(\n      `conversation:${tweetId}`,\n      () => this.fetchConversationHistory(tweetId),\n      10 * 60 * 1000 // 10 minutes TTL for conversations\n    );\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing-and-quality-assurance",children:"Testing and Quality Assurance"}),"\n",(0,r.jsx)(n.h3,{id:"unit-testing-framework",children:"Unit Testing Framework"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"describe('TwitterClient', () => {\n  let client: TwitterClient;\n  let mockRuntime: jest.Mocked<IAgentRuntime>;\n  let mockTwitterApi: jest.Mocked<TwitterApi>;\n\n  beforeEach(() => {\n    mockRuntime = createMockRuntime();\n    mockTwitterApi = createMockTwitterApi();\n    client = new TwitterClient(mockRuntime);\n  });\n\n  describe('Content Generation', () => {\n    it('should generate tweet within character limit', async () => {\n      const context = createTestContext();\n      const tweet = await client.generateTweet(context);\n\n      expect(tweet.length).toBeLessThanOrEqual(280);\n      expect(tweet).toContain('#');\n      expect(tweet).not.toContain('undefined');\n    });\n\n    it('should maintain character personality', async () => {\n      const context = createTestContext({\n        character: { personality: 'professional and helpful' },\n      });\n\n      const tweet = await client.generateTweet(context);\n\n      // Use AI to verify personality consistency\n      const personalityScore = await analyzePersonality(tweet, context.character);\n      expect(personalityScore).toBeGreaterThan(0.7);\n    });\n  });\n\n  describe('Engagement Management', () => {\n    it('should respond to appropriate mentions', async () => {\n      const mention = createTestMention({ sentiment: 0.8 });\n\n      await client.handleMention(mention);\n\n      expect(mockTwitterApi.v2.reply).toHaveBeenCalledWith(expect.stringMatching(/.+/), mention.id);\n    });\n\n    it('should ignore negative sentiment mentions', async () => {\n      const mention = createTestMention({ sentiment: -0.8 });\n\n      await client.handleMention(mention);\n\n      expect(mockTwitterApi.v2.reply).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Rate Limiting', () => {\n    it('should respect rate limits', async () => {\n      // Simulate rate limit reached\n      mockTwitterApi.v2.tweet.mockRejectedValueOnce(new Error('Rate limit exceeded'));\n\n      const postPromise = client.postTweet('Test tweet');\n\n      // Should wait and retry\n      await expect(postPromise).resolves.not.toThrow();\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"describe('Twitter Integration', () => {\n  let testAgent: TestAgent;\n  let twitterClient: TwitterClient;\n\n  beforeAll(async () => {\n    testAgent = await createTestAgent({\n      character: loadTestCharacter('twitter-test-character.json'),\n      clients: ['twitter'],\n    });\n\n    twitterClient = testAgent.getClient('twitter') as TwitterClient;\n  });\n\n  afterAll(async () => {\n    await testAgent.cleanup();\n  });\n\n  it('should handle full tweet lifecycle', async () => {\n    // 1. Generate and post tweet\n    const tweet = await twitterClient.generateAndPostTweet();\n    expect(tweet.id).toBeDefined();\n\n    // 2. Monitor for engagement\n    const mention = await simulateMention(tweet.id);\n\n    // 3. Generate response\n    await waitForResponse(mention.id);\n\n    // 4. Verify response was posted\n    const responses = await twitterClient.getResponses(mention.id);\n    expect(responses).toHaveLength(1);\n    expect(responses[0].text).toMatch(/^@/); // Should start with mention\n  });\n\n  it('should maintain conversation context', async () => {\n    const conversation = await simulateConversation([\n      { text: '@testagent what do you think about AI?', user: 'testuser' },\n      { text: '@testagent can you elaborate?', user: 'testuser' },\n    ]);\n\n    const responses = await twitterClient.getConversationResponses(conversation.id);\n\n    expect(responses).toHaveLength(2);\n    expect(responses[1].text).toContain(conversation.context);\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"deployment-and-monitoring",children:"Deployment and Monitoring"}),"\n",(0,r.jsx)(n.h3,{id:"production-configuration",children:"Production Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Production configuration example\nconst productionConfig: TwitterConfig = {\n  authentication: {\n    apiKey: process.env.TWITTER_API_KEY!,\n    apiSecret: process.env.TWITTER_API_SECRET!,\n    accessToken: process.env.TWITTER_ACCESS_TOKEN!,\n    accessTokenSecret: process.env.TWITTER_ACCESS_TOKEN_SECRET!,\n  },\n\n  rateLimit: {\n    tweetsPerHour: 20,\n    repliesPerHour: 50,\n    requestsPerMinute: 300,\n  },\n\n  monitoring: {\n    enableMetrics: true,\n    enableLogging: true,\n    logLevel: 'info',\n    metricsEndpoint: '/metrics',\n  },\n\n  safety: {\n    contentFiltering: true,\n    sentimentThreshold: -0.5,\n    spamDetection: true,\n    rateLimitProtection: true,\n  },\n\n  performance: {\n    cacheEnabled: true,\n    cacheTTL: 300000, // 5 minutes\n    maxConcurrentRequests: 5,\n    requestTimeout: 30000, // 30 seconds\n  },\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"monitoring-and-alerting",children:"Monitoring and Alerting"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class TwitterMonitoring {\n  private metrics: MetricsCollector;\n  private alerts: AlertManager;\n\n  constructor() {\n    this.metrics = new MetricsCollector();\n    this.alerts = new AlertManager();\n    this.setupMetrics();\n  }\n\n  private setupMetrics(): void {\n    // Tweet metrics\n    this.metrics.createCounter('tweets_posted_total');\n    this.metrics.createCounter('tweets_failed_total');\n    this.metrics.createHistogram('tweet_generation_duration');\n\n    // Engagement metrics\n    this.metrics.createCounter('mentions_received_total');\n    this.metrics.createCounter('replies_sent_total');\n    this.metrics.createGauge('engagement_rate');\n\n    // Performance metrics\n    this.metrics.createHistogram('api_request_duration');\n    this.metrics.createCounter('rate_limit_hits_total');\n    this.metrics.createGauge('cache_hit_rate');\n  }\n\n  trackTweetPosted(tweet: Tweet, duration: number): void {\n    this.metrics.incrementCounter('tweets_posted_total');\n    this.metrics.recordHistogram('tweet_generation_duration', duration);\n  }\n\n  trackTweetFailed(error: Error): void {\n    this.metrics.incrementCounter('tweets_failed_total', { error: error.name });\n\n    // Alert on high failure rate\n    if (this.getTweetFailureRate() > 0.1) {\n      this.alerts.send({\n        severity: 'warning',\n        message: 'High tweet failure rate detected',\n        metadata: { error: error.message },\n      });\n    }\n  }\n\n  trackEngagement(mention: Mention, responseGenerated: boolean): void {\n    this.metrics.incrementCounter('mentions_received_total');\n\n    if (responseGenerated) {\n      this.metrics.incrementCounter('replies_sent_total');\n    }\n\n    this.updateEngagementRate();\n  }\n\n  private updateEngagementRate(): void {\n    const totalMentions = this.metrics.getCounterValue('mentions_received_total');\n    const totalReplies = this.metrics.getCounterValue('replies_sent_total');\n    const engagementRate = totalReplies / totalMentions;\n\n    this.metrics.setGauge('engagement_rate', engagementRate);\n  }\n\n  private getTweetFailureRate(): number {\n    const failed = this.metrics.getCounterValue('tweets_failed_total');\n    const total = this.metrics.getCounterValue('tweets_posted_total') + failed;\n    return total > 0 ? failed / total : 0;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"api-key-management",children:"API Key Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class TwitterSecurityManager {\n  private keyRotationInterval: number = 30 * 24 * 60 * 60 * 1000; // 30 days\n  private encryptionService: EncryptionService;\n\n  constructor() {\n    this.encryptionService = new EncryptionService();\n    this.setupKeyRotation();\n  }\n\n  encryptCredentials(credentials: TwitterCredentials): EncryptedCredentials {\n    return {\n      apiKey: this.encryptionService.encrypt(credentials.apiKey),\n      apiSecret: this.encryptionService.encrypt(credentials.apiSecret),\n      accessToken: this.encryptionService.encrypt(credentials.accessToken),\n      accessTokenSecret: this.encryptionService.encrypt(credentials.accessTokenSecret),\n      encryptedAt: Date.now(),\n    };\n  }\n\n  decryptCredentials(encryptedCreds: EncryptedCredentials): TwitterCredentials {\n    return {\n      apiKey: this.encryptionService.decrypt(encryptedCreds.apiKey),\n      apiSecret: this.encryptionService.decrypt(encryptedCreds.apiSecret),\n      accessToken: this.encryptionService.decrypt(encryptedCreds.accessToken),\n      accessTokenSecret: this.encryptionService.decrypt(encryptedCreds.accessTokenSecret),\n    };\n  }\n\n  private setupKeyRotation(): void {\n    setInterval(\n      async () => {\n        await this.rotateKeysIfNeeded();\n      },\n      24 * 60 * 60 * 1000\n    ); // Check daily\n  }\n\n  private async rotateKeysIfNeeded(): Promise<void> {\n    const credentials = await this.getStoredCredentials();\n\n    if (this.shouldRotateKeys(credentials)) {\n      console.log('Rotating Twitter API keys...');\n      await this.rotateApiKeys();\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"content-safety",children:"Content Safety"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class TwitterContentSafety {\n  private contentFilter: ContentFilter;\n  private sentimentAnalyzer: SentimentAnalyzer;\n\n  constructor() {\n    this.contentFilter = new ContentFilter();\n    this.sentimentAnalyzer = new SentimentAnalyzer();\n  }\n\n  async validateContent(content: string): Promise<ContentValidationResult> {\n    const validations = await Promise.all([\n      this.checkProfanity(content),\n      this.checkToxicity(content),\n      this.checkSentiment(content),\n      this.checkComplianceRules(content),\n    ]);\n\n    return {\n      isValid: validations.every((v) => v.passed),\n      violations: validations.filter((v) => !v.passed),\n      riskScore: this.calculateRiskScore(validations),\n    };\n  }\n\n  private async checkProfanity(content: string): Promise<ValidationCheck> {\n    const hasProfanity = await this.contentFilter.containsProfanity(content);\n    return {\n      type: 'profanity',\n      passed: !hasProfanity,\n      severity: hasProfanity ? 'high' : 'none',\n    };\n  }\n\n  private async checkToxicity(content: string): Promise<ValidationCheck> {\n    const toxicityScore = await this.contentFilter.analyzeToxicity(content);\n    return {\n      type: 'toxicity',\n      passed: toxicityScore < 0.3,\n      severity: toxicityScore > 0.7 ? 'high' : toxicityScore > 0.3 ? 'medium' : 'none',\n      score: toxicityScore,\n    };\n  }\n\n  private async checkSentiment(content: string): Promise<ValidationCheck> {\n    const sentiment = await this.sentimentAnalyzer.analyze(content);\n    return {\n      type: 'sentiment',\n      passed: sentiment.score > -0.8, // Allow slightly negative content\n      severity: sentiment.score < -0.8 ? 'medium' : 'none',\n      score: sentiment.score,\n    };\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting-and-debugging",children:"Troubleshooting and Debugging"}),"\n",(0,r.jsx)(n.h3,{id:"debug-logging",children:"Debug Logging"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class TwitterDebugger {\n  private logger: Logger;\n  private debugMode: boolean;\n\n  constructor(debugMode: boolean = false) {\n    this.debugMode = debugMode;\n    this.logger = new Logger('TwitterClient');\n  }\n\n  logApiRequest(endpoint: string, params: any): void {\n    if (this.debugMode) {\n      this.logger.debug('API Request', {\n        endpoint,\n        params: this.sanitizeParams(params),\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  logContentGeneration(context: ContentGenerationContext, result: string): void {\n    if (this.debugMode) {\n      this.logger.debug('Content Generated', {\n        characterName: context.character.name,\n        contentLength: result.length,\n        hashtags: this.extractHashtags(result),\n        mentions: this.extractMentions(result),\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n\n  logEngagement(mention: Mention, response?: string): void {\n    this.logger.info('Engagement Event', {\n      mentionId: mention.id,\n      userId: mention.authorId,\n      hasResponse: !!response,\n      responseLength: response?.length || 0,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  logError(error: Error, context?: any): void {\n    this.logger.error('Twitter Error', {\n      error: error.message,\n      stack: error.stack,\n      context: this.sanitizeContext(context),\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  private sanitizeParams(params: any): any {\n    // Remove sensitive information from logs\n    const sanitized = { ...params };\n    delete sanitized.accessToken;\n    delete sanitized.accessSecret;\n    delete sanitized.apiKey;\n    delete sanitized.apiSecret;\n    return sanitized;\n  }\n\n  private sanitizeContext(context: any): any {\n    if (!context) return context;\n\n    const sanitized = { ...context };\n    // Remove sensitive user data\n    if (sanitized.user) {\n      delete sanitized.user.email;\n      delete sanitized.user.phone;\n    }\n    return sanitized;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This comprehensive technical guide covers all aspects of Twitter integration in ElizaOS, from basic implementation to advanced features, security, monitoring, and troubleshooting. It provides developers with the technical depth needed to effectively implement, customize, and maintain Twitter functionality in their ElizaOS agents."})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(14041);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);