"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[71435],{39107:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"core/tasks","title":"Tasks","description":"Tasks in ElizaOS provide a powerful way to manage deferred, scheduled, and interactive operations. The Task system allows agents to queue work for later execution, repeat actions at defined intervals, await user input, and implement complex workflows across multiple interactions.","source":"@site/docs/core/tasks.md","sourceDirName":"core","slug":"/core/tasks","permalink":"/docs/core/tasks","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/main/docs/docs/core/tasks.md","tags":[],"version":"current","lastUpdatedBy":"Shaw","lastUpdatedAt":1742108548000,"sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Services","permalink":"/docs/core/services"},"next":{"title":"Worlds","permalink":"/docs/core/worlds"}}');var s=t(31085),r=t(71184);const i={sidebar_position:9},o="Tasks",d={},c=[{value:"Task Structure",id:"task-structure",level:2},{value:"Task Workers",id:"task-workers",level:2},{value:"Creating and Managing Tasks",id:"creating-and-managing-tasks",level:2},{value:"Registering a Task Worker",id:"registering-a-task-worker",level:3},{value:"Creating a One-time Task",id:"creating-a-one-time-task",level:3},{value:"Creating a Recurring Task",id:"creating-a-recurring-task",level:3},{value:"Creating a Task Awaiting User Choice",id:"creating-a-task-awaiting-user-choice",level:3},{value:"Managing Tasks",id:"managing-tasks",level:3},{value:"Task Processing",id:"task-processing",level:2},{value:"One-time Tasks",id:"one-time-tasks",level:3},{value:"Recurring Tasks",id:"recurring-tasks",level:3},{value:"Tasks Awaiting User Input",id:"tasks-awaiting-user-input",level:3},{value:"Common Task Patterns",id:"common-task-patterns",level:2},{value:"Deferred Follow-ups",id:"deferred-follow-ups",level:3},{value:"Multi-step Workflows",id:"multi-step-workflows",level:3},{value:"Scheduled Reports",id:"scheduled-reports",level:3},{value:"Task Events and Monitoring",id:"task-events-and-monitoring",level:2},{value:"Best Practices",id:"best-practices",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"tasks",children:"Tasks"})}),"\n",(0,s.jsx)(n.p,{children:"Tasks in ElizaOS provide a powerful way to manage deferred, scheduled, and interactive operations. The Task system allows agents to queue work for later execution, repeat actions at defined intervals, await user input, and implement complex workflows across multiple interactions."}),"\n",(0,s.jsx)(n.h2,{id:"task-structure",children:"Task Structure"}),"\n",(0,s.jsx)(n.p,{children:"A task in ElizaOS has the following properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface Task {\n  id?: UUID; // Unique identifier (auto-generated if not provided)\n  name: string; // Name of the task (must match a registered task worker)\n  updatedAt?: number; // Timestamp when the task was last updated\n  metadata?: {\n    // Optional additional configuration\n    updateInterval?: number; // For repeating tasks: milliseconds between executions\n    options?: {\n      // For choice tasks: options for user selection\n      name: string;\n      description: string;\n    }[];\n    [key: string]: unknown; // Additional custom metadata\n  };\n  description: string; // Human-readable description of the task\n  roomId?: UUID; // Optional room association (for room-specific tasks)\n  worldId?: UUID; // Optional world association (for world-specific tasks)\n  tags: string[]; // Tags for categorizing and filtering tasks\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"task-workers",children:"Task Workers"}),"\n",(0,s.jsx)(n.p,{children:"Task workers define the actual logic that executes when a task runs. Each task worker is registered with the runtime and is identified by name."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface TaskWorker {\n  name: string; // Matches the name in the Task\n  execute: (\n    runtime: IAgentRuntime,\n    options: { [key: string]: unknown }, // Options passed during execution\n    task: Task // The task being executed\n  ) => Promise<void>;\n  validate?: (\n    // Optional validation before execution\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State\n  ) => Promise<boolean>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"creating-and-managing-tasks",children:"Creating and Managing Tasks"}),"\n",(0,s.jsx)(n.h3,{id:"registering-a-task-worker",children:"Registering a Task Worker"}),"\n",(0,s.jsx)(n.p,{children:"Before creating tasks, you must register a worker to handle the execution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"runtime.registerTaskWorker({\n  name: 'SEND_REMINDER',\n  validate: async (runtime, message, state) => {\n    // Optional validation logic\n    return true;\n  },\n  execute: async (runtime, options, task) => {\n    // Task execution logic\n    const { roomId } = task;\n    const { reminder, userId } = options;\n\n    await runtime.createMemory(\n      {\n        entityId: runtime.agentId,\n        roomId,\n        content: {\n          text: `Reminder for <@${userId}>: ${reminder}`,\n        },\n      },\n      'messages'\n    );\n\n    // Delete the task after it's completed\n    await runtime.deleteTask(task.id);\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"creating-a-one-time-task",children:"Creating a One-time Task"}),"\n",(0,s.jsx)(n.p,{children:"Create a task that will execute once:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"await runtime.createTask({\n  name: 'SEND_REMINDER',\n  description: 'Send a reminder message to the user',\n  roomId: currentRoomId,\n  tags: ['reminder', 'one-time'],\n  metadata: {\n    userId: message.entityId,\n    reminder: 'Submit your weekly report',\n    scheduledFor: Date.now() + 86400000, // 24 hours from now\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"creating-a-recurring-task",children:"Creating a Recurring Task"}),"\n",(0,s.jsx)(n.p,{children:"Create a task that repeats at regular intervals:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"await runtime.createTask({\n  name: 'DAILY_REPORT',\n  description: 'Generate and post the daily report',\n  roomId: announcementChannelId,\n  worldId: serverWorldId,\n  tags: ['report', 'repeat', 'daily'],\n  metadata: {\n    updateInterval: 86400000, // 24 hours in milliseconds\n    updatedAt: Date.now(), // When the task was last updated/executed\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"creating-a-task-awaiting-user-choice",children:"Creating a Task Awaiting User Choice"}),"\n",(0,s.jsx)(n.p,{children:"Create a task that presents options and waits for user input:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"await runtime.createTask({\n  name: 'CONFIRM_ACTION',\n  description: 'Confirm the requested action',\n  roomId: message.roomId,\n  tags: ['confirmation', 'AWAITING_CHOICE'],\n  metadata: {\n    options: [\n      { name: 'confirm', description: 'Proceed with the action' },\n      { name: 'cancel', description: 'Cancel the action' },\n    ],\n    action: 'DELETE_FILES',\n    files: ['document1.txt', 'document2.txt'],\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"managing-tasks",children:"Managing Tasks"}),"\n",(0,s.jsx)(n.p,{children:"Retrieve, update, and delete tasks as needed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get tasks by specific criteria\nconst reminderTasks = await runtime.getTasks({\n  roomId: currentRoomId,\n  tags: ['reminder'],\n});\n\n// Get tasks by name\nconst reportTasks = await runtime.getTasksByName('DAILY_REPORT');\n\n// Get a specific task\nconst task = await runtime.getTask(taskId);\n\n// Update a task\nawait runtime.updateTask(taskId, {\n  description: 'Updated description',\n  metadata: {\n    ...task.metadata,\n    priority: 'high',\n  },\n});\n\n// Delete a task\nawait runtime.deleteTask(taskId);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"task-processing",children:"Task Processing"}),"\n",(0,s.jsx)(n.p,{children:"Tasks are processed based on their configuration:"}),"\n",(0,s.jsx)(n.h3,{id:"one-time-tasks",children:"One-time Tasks"}),"\n",(0,s.jsxs)(n.p,{children:["Tasks without an ",(0,s.jsx)(n.code,{children:"updateInterval"})," are executed once when triggered by your code. You are responsible for scheduling their execution by checking for pending tasks in appropriate contexts."]}),"\n",(0,s.jsx)(n.h3,{id:"recurring-tasks",children:"Recurring Tasks"}),"\n",(0,s.jsxs)(n.p,{children:["Tasks with an ",(0,s.jsx)(n.code,{children:"updateInterval"})," are automatically considered for re-execution when:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The current time exceeds ",(0,s.jsx)(n.code,{children:"updatedAt + updateInterval"})]}),"\n",(0,s.jsx)(n.li,{children:"Your code explicitly checks for pending recurring tasks"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To process recurring tasks, implement logic like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// In an initialization function or periodic check\nasync function processRecurringTasks() {\n  const now = Date.now();\n  const recurringTasks = await runtime.getTasks({\n    tags: ['repeat'],\n  });\n\n  for (const task of recurringTasks) {\n    if (!task.metadata?.updateInterval) continue;\n\n    const lastUpdate = task.metadata.updatedAt || 0;\n    const interval = task.metadata.updateInterval;\n\n    if (now >= lastUpdate + interval) {\n      const worker = runtime.getTaskWorker(task.name);\n      if (worker) {\n        try {\n          await worker.execute(runtime, {}, task);\n\n          // Update the task's last update time\n          await runtime.updateTask(task.id, {\n            metadata: {\n              ...task.metadata,\n              updatedAt: now,\n            },\n          });\n        } catch (error) {\n          logger.error(`Error executing task ${task.name}: ${error}`);\n        }\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tasks-awaiting-user-input",children:"Tasks Awaiting User Input"}),"\n",(0,s.jsxs)(n.p,{children:["Tasks tagged with ",(0,s.jsx)(n.code,{children:"AWAITING_CHOICE"})," are presented to users and wait for their input. These tasks use:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"choice"})," provider to display available options to users"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"CHOOSE_OPTION"})," action to process user selections"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-task-patterns",children:"Common Task Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"deferred-follow-ups",children:"Deferred Follow-ups"}),"\n",(0,s.jsx)(n.p,{children:"Create a task to follow up with a user later:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"runtime.registerTaskWorker({\n  name: 'FOLLOW_UP',\n  execute: async (runtime, options, task) => {\n    const { roomId } = task;\n    const { userId, topic } = task.metadata;\n\n    await runtime.createMemory(\n      {\n        entityId: runtime.agentId,\n        roomId,\n        content: {\n          text: `Hi <@${userId}>, I'm following up about ${topic}. Do you have any updates?`,\n        },\n      },\n      'messages'\n    );\n\n    await runtime.deleteTask(task.id);\n  },\n});\n\n// Create a follow-up task for 2 days later\nawait runtime.createTask({\n  name: 'FOLLOW_UP',\n  description: 'Follow up with user about project status',\n  roomId: message.roomId,\n  tags: ['follow-up', 'one-time'],\n  metadata: {\n    userId: message.entityId,\n    topic: 'the project timeline',\n    scheduledFor: Date.now() + 2 * 86400000, // 2 days\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"multi-step-workflows",children:"Multi-step Workflows"}),"\n",(0,s.jsx)(n.p,{children:"Implement complex workflows that span multiple interactions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// First step: Gather requirements\nruntime.registerTaskWorker({\n  name: 'GATHER_REQUIREMENTS',\n  execute: async (runtime, options, task) => {\n    // Ask user for requirements and create a new task for the next step\n    await runtime.createTask({\n      name: 'CONFIRM_REQUIREMENTS',\n      description: 'Confirm gathered requirements',\n      roomId: task.roomId,\n      tags: ['workflow', 'AWAITING_CHOICE'],\n      metadata: {\n        previousStep: 'GATHER_REQUIREMENTS',\n        requirements: options.requirements,\n        options: [\n          { name: 'confirm', description: 'Confirm requirements are correct' },\n          { name: 'revise', description: 'Need to revise requirements' },\n        ],\n      },\n    });\n\n    await runtime.deleteTask(task.id);\n  },\n});\n\n// Second step: Confirm requirements\nruntime.registerTaskWorker({\n  name: 'CONFIRM_REQUIREMENTS',\n  execute: async (runtime, options, task) => {\n    if (options.option === 'confirm') {\n      // Move to the next step\n      await runtime.createTask({\n        name: 'GENERATE_SOLUTION',\n        description: 'Generate solution based on requirements',\n        roomId: task.roomId,\n        tags: ['workflow'],\n        metadata: {\n          previousStep: 'CONFIRM_REQUIREMENTS',\n          requirements: task.metadata.requirements,\n        },\n      });\n    } else {\n      // Go back to requirements gathering\n      await runtime.createTask({\n        name: 'GATHER_REQUIREMENTS',\n        description: 'Revise requirements',\n        roomId: task.roomId,\n        tags: ['workflow'],\n        metadata: {\n          previousStep: 'CONFIRM_REQUIREMENTS',\n          previousRequirements: task.metadata.requirements,\n        },\n      });\n    }\n\n    await runtime.deleteTask(task.id);\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scheduled-reports",children:"Scheduled Reports"}),"\n",(0,s.jsx)(n.p,{children:"Create tasks that generate and post reports on a schedule:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"runtime.registerTaskWorker({\n  name: 'GENERATE_WEEKLY_REPORT',\n  execute: async (runtime, options, task) => {\n    const { roomId } = task;\n\n    // Generate report content\n    const reportData = await generateWeeklyReport(runtime);\n\n    // Post the report\n    await runtime.createMemory(\n      {\n        entityId: runtime.agentId,\n        roomId,\n        content: {\n          text: `# Weekly Report\\n\\n${reportData}`,\n        },\n      },\n      'messages'\n    );\n\n    // The task stays active for next week (updateInterval handles timing)\n  },\n});\n\n// Create a weekly report task\nawait runtime.createTask({\n  name: 'GENERATE_WEEKLY_REPORT',\n  description: 'Generate and post weekly activity report',\n  roomId: reportChannelId,\n  worldId: serverWorldId,\n  tags: ['report', 'repeat', 'weekly'],\n  metadata: {\n    updateInterval: 7 * 86400000, // 7 days\n    updatedAt: Date.now(),\n    format: 'markdown',\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"task-events-and-monitoring",children:"Task Events and Monitoring"}),"\n",(0,s.jsx)(n.p,{children:"ElizaOS doesn't currently provide built-in events for task lifecycle, so implement your own monitoring if needed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Custom monitoring for task execution\nasync function executeTaskWithMonitoring(runtime, taskWorker, task) {\n  try {\n    // Create a start log\n    await runtime.log({\n      body: { taskId: task.id, action: 'start' },\n      entityId: runtime.agentId,\n      roomId: task.roomId,\n      type: 'TASK_EXECUTION',\n    });\n\n    // Execute the task\n    await taskWorker.execute(runtime, {}, task);\n\n    // Create a completion log\n    await runtime.log({\n      body: { taskId: task.id, action: 'complete', success: true },\n      entityId: runtime.agentId,\n      roomId: task.roomId,\n      type: 'TASK_EXECUTION',\n    });\n  } catch (error) {\n    // Create an error log\n    await runtime.log({\n      body: { taskId: task.id, action: 'error', error: error.message },\n      entityId: runtime.agentId,\n      roomId: task.roomId,\n      type: 'TASK_EXECUTION',\n    });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use descriptive names and descriptions"}),": Make tasks easily identifiable with clear names and descriptions"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Clean up completed tasks"}),": Delete one-time tasks after execution to prevent database bloat"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Add error handling"}),": Implement robust error handling in task workers to prevent failures from breaking workflows"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use appropriate tags"}),": Tag tasks effectively for easy retrieval and categorization"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Validate carefully"}),": Use the ",(0,s.jsx)(n.code,{children:"validate"})," function to ensure tasks only execute in appropriate contexts"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Keep tasks atomic"}),": Design tasks to perform specific, well-defined operations rather than complex actions"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Provide clear choices"}),": When creating choice tasks, make option names and descriptions clear and unambiguous"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Manage task lifecycles"}),": Have a clear strategy for when tasks are created, updated, and deleted"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Set reasonable intervals"}),": For recurring tasks, choose appropriate update intervals that balance timeliness and resource usage"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Handle concurrent execution"}),": Ensure task execution is idempotent to handle potential concurrent executions"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(14041);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);