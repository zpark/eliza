"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[90452],{53357:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"technical/integrations/telegram-technical","title":"Telegram Technical Integration","description":"Comprehensive technical guide for integrating ElizaOS with Telegram, including bot development, advanced features, and production deployment.","source":"@site/docs/technical/integrations/telegram-technical.md","sourceDirName":"technical/integrations","slug":"/technical/integrations/telegram-technical","permalink":"/docs/technical/integrations/telegram-technical","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/technical/integrations/telegram-technical.md","tags":[],"version":"current","lastUpdatedBy":"Sayo","lastUpdatedAt":1751802400000,"frontMatter":{},"sidebar":"technicalSidebar","previous":{"title":"\ud83c\udfae Discord Technical Integration","permalink":"/docs/technical/integrations/discord-technical"},"next":{"title":"\ud83d\udc26 Twitter Technical Integration","permalink":"/docs/technical/integrations/twitter-technical"}}');var i=t(31085),s=t(71184);const r={},o="Telegram Technical Integration",c={},l=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Telegram Service Architecture",id:"telegram-service-architecture",level:3},{value:"Message Flow Architecture",id:"message-flow-architecture",level:3},{value:"Implementation Guide",id:"implementation-guide",level:2},{value:"1. Service Initialization",id:"1-service-initialization",level:3},{value:"2. Custom Update Handlers",id:"2-custom-update-handlers",level:3},{value:"3. Command System Implementation",id:"3-command-system-implementation",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"1. Inline Keyboards &amp; Buttons",id:"1-inline-keyboards--buttons",level:3},{value:"2. Rich Media Handling",id:"2-rich-media-handling",level:3},{value:"3. Session Management",id:"3-session-management",level:3},{value:"Webhook vs Polling",id:"webhook-vs-polling",level:2},{value:"1. Webhook Configuration",id:"1-webhook-configuration",level:3},{value:"2. Polling Configuration",id:"2-polling-configuration",level:3},{value:"Rate Limiting &amp; Throttling",id:"rate-limiting--throttling",level:2},{value:"Group Chat Management",id:"group-chat-management",level:2},{value:"Error Handling &amp; Recovery",id:"error-handling--recovery",level:2},{value:"Testing Strategies",id:"testing-strategies",level:2},{value:"1. Unit Testing",id:"1-unit-testing",level:3},{value:"2. Integration Testing",id:"2-integration-testing",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"1. Message Queue",id:"1-message-queue",level:3},{value:"2. Caching Strategy",id:"2-caching-strategy",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"1. Input Validation",id:"1-input-validation",level:3},{value:"2. Authentication Middleware",id:"2-authentication-middleware",level:3},{value:"Production Deployment",id:"production-deployment",level:2},{value:"1. Environment Configuration",id:"1-environment-configuration",level:3},{value:"2. Docker Configuration",id:"2-docker-configuration",level:3},{value:"Monitoring &amp; Analytics",id:"monitoring--analytics",level:2},{value:"Resources",id:"resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"telegram-technical-integration",children:"Telegram Technical Integration"})}),"\n",(0,i.jsx)(n.p,{children:"Comprehensive technical guide for integrating ElizaOS with Telegram, including bot development, advanced features, and production deployment."}),"\n",(0,i.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(n.h3,{id:"telegram-service-architecture",children:"Telegram Service Architecture"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface TelegramService extends Service {\n  bot: TelegramBot;\n  updateHandler: UpdateHandler;\n  commandRegistry: CommandRegistry;\n  sessionManager: SessionManager;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"message-flow-architecture",children:"Message Flow Architecture"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TD\n    A[Telegram API] --\x3e B[Webhook/Polling]\n    B --\x3e C[Update Handler]\n    C --\x3e D{Update Type}\n    D --\x3e|Message| E[Message Handler]\n    D --\x3e|Command| F[Command Handler]\n    D --\x3e|Callback| G[Callback Handler]\n    E --\x3e H[Agent Runtime]\n    F --\x3e H\n    G --\x3e H\n    H --\x3e I[Response Builder]\n    I --\x3e A"}),"\n",(0,i.jsx)(n.h2,{id:"implementation-guide",children:"Implementation Guide"}),"\n",(0,i.jsx)(n.h3,{id:"1-service-initialization",children:"1. Service Initialization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { TelegramService } from '@elizaos/plugin-telegram';\nimport { Telegraf } from 'telegraf';\n\n// Initialize Telegram service\nconst telegramService = new TelegramService({\n  token: process.env.TELEGRAM_BOT_TOKEN,\n  webhookUrl: process.env.WEBHOOK_URL, // Optional\n  polling: !process.env.WEBHOOK_URL,\n  rateLimit: {\n    window: 1000,\n    limit: 30,\n  },\n});\n\n// Register with runtime\nruntime.registerService(telegramService);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-custom-update-handlers",children:"2. Custom Update Handlers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Custom update handler implementation\nclass CustomUpdateHandler extends UpdateHandler {\n  constructor(\n    private bot: Telegraf,\n    private runtime: IAgentRuntime\n  ) {\n    super();\n    this.registerHandlers();\n  }\n\n  private registerHandlers(): void {\n    // Text messages\n    this.bot.on('text', this.handleTextMessage.bind(this));\n\n    // Voice messages\n    this.bot.on('voice', this.handleVoiceMessage.bind(this));\n\n    // Documents\n    this.bot.on('document', this.handleDocument.bind(this));\n\n    // Inline queries\n    this.bot.on('inline_query', this.handleInlineQuery.bind(this));\n\n    // Callback queries\n    this.bot.on('callback_query', this.handleCallbackQuery.bind(this));\n  }\n\n  private async handleTextMessage(ctx: Context): Promise<void> {\n    const message = ctx.message;\n    const userId = message.from.id.toString();\n    const chatId = message.chat.id.toString();\n\n    // Build context\n    const context = {\n      userId,\n      roomId: chatId,\n      content: message.text,\n      platform: 'telegram',\n      metadata: {\n        username: message.from.username,\n        firstName: message.from.first_name,\n        messageId: message.message_id,\n        chatType: message.chat.type,\n      },\n    };\n\n    // Process with runtime\n    const response = await this.runtime.process(context);\n\n    // Send response\n    await this.sendResponse(ctx, response);\n  }\n\n  private async handleVoiceMessage(ctx: Context): Promise<void> {\n    const voice = ctx.message.voice;\n\n    // Download voice file\n    const fileLink = await ctx.telegram.getFileLink(voice.file_id);\n    const audioBuffer = await downloadFile(fileLink.toString());\n\n    // Transcribe audio\n    const transcription = await this.transcribeAudio(audioBuffer);\n\n    // Process as text\n    await this.handleTextMessage({\n      ...ctx,\n      message: {\n        ...ctx.message,\n        text: transcription,\n      },\n    });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-command-system-implementation",children:"3. Command System Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Command registry\nclass CommandRegistry {\n  private commands: Map<string, CommandHandler> = new Map();\n\n  register(command: string, handler: CommandHandler): void {\n    this.commands.set(command, handler);\n  }\n\n  async execute(command: string, ctx: Context): Promise<void> {\n    const handler = this.commands.get(command);\n    if (!handler) {\n      await ctx.reply('Unknown command. Type /help for available commands.');\n      return;\n    }\n\n    try {\n      await handler.execute(ctx);\n    } catch (error) {\n      await ctx.reply('An error occurred processing your command.');\n      console.error(`Command error: ${command}`, error);\n    }\n  }\n}\n\n// Command handler interface\ninterface CommandHandler {\n  description: string;\n  usage: string;\n  execute(ctx: Context): Promise<void>;\n}\n\n// Example command implementation\nclass HelpCommand implements CommandHandler {\n  description = 'Show available commands';\n  usage = '/help';\n\n  async execute(ctx: Context): Promise<void> {\n    const commands = [\n      '/start - Start conversation',\n      '/help - Show this message',\n      '/settings - Configure preferences',\n      '/stats - View your statistics',\n      '/clear - Clear conversation history',\n    ];\n\n    await ctx.reply(`\ud83e\udd16 *Available Commands*\\n\\n${commands.join('\\n')}`, {\n      parse_mode: 'Markdown',\n    });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,i.jsx)(n.h3,{id:"1-inline-keyboards--buttons",children:"1. Inline Keyboards & Buttons"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Interactive keyboard builder\nclass KeyboardBuilder {\n  static mainMenu(): InlineKeyboardMarkup {\n    return {\n      inline_keyboard: [\n        [\n          { text: '\ud83d\udcac Chat', callback_data: 'action:chat' },\n          { text: '\u2699\ufe0f Settings', callback_data: 'action:settings' },\n        ],\n        [\n          { text: '\ud83d\udcca Stats', callback_data: 'action:stats' },\n          { text: '\u2753 Help', callback_data: 'action:help' },\n        ],\n      ],\n    };\n  }\n\n  static settings(): InlineKeyboardMarkup {\n    return {\n      inline_keyboard: [\n        [\n          { text: '\ud83c\udf10 Language', callback_data: 'settings:language' },\n          { text: '\ud83d\udd14 Notifications', callback_data: 'settings:notifications' },\n        ],\n        [\n          { text: '\ud83c\udfa8 Theme', callback_data: 'settings:theme' },\n          { text: '\ud83d\udc64 Profile', callback_data: 'settings:profile' },\n        ],\n        [{ text: '\u2b05\ufe0f Back', callback_data: 'action:back' }],\n      ],\n    };\n  }\n\n  static confirmation(action: string): InlineKeyboardMarkup {\n    return {\n      inline_keyboard: [\n        [\n          { text: '\u2705 Yes', callback_data: `confirm:${action}:yes` },\n          { text: '\u274c No', callback_data: `confirm:${action}:no` },\n        ],\n      ],\n    };\n  }\n}\n\n// Callback query handler\nbot.on('callback_query', async (ctx) => {\n  const data = ctx.callbackQuery.data;\n  const [type, action, ...params] = data.split(':');\n\n  switch (type) {\n    case 'action':\n      await handleAction(ctx, action);\n      break;\n    case 'settings':\n      await handleSettings(ctx, action);\n      break;\n    case 'confirm':\n      await handleConfirmation(ctx, action, params[0]);\n      break;\n  }\n\n  // Answer callback query\n  await ctx.answerCbQuery();\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-rich-media-handling",children:"2. Rich Media Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Media message builder\nclass MediaMessageBuilder {\n  static async photo(ctx: Context, photoUrl: string, caption?: string): Promise<void> {\n    await ctx.replyWithPhoto(photoUrl, {\n      caption,\n      parse_mode: 'HTML',\n      reply_markup: KeyboardBuilder.mainMenu(),\n    });\n  }\n\n  static async document(ctx: Context, document: Buffer | string, filename: string): Promise<void> {\n    await ctx.replyWithDocument(\n      {\n        source: document,\n        filename,\n      },\n      {\n        caption: `\ud83d\udcce ${filename}`,\n        parse_mode: 'Markdown',\n      }\n    );\n  }\n\n  static async voice(ctx: Context, audioBuffer: Buffer): Promise<void> {\n    await ctx.replyWithVoice({\n      source: audioBuffer,\n    });\n  }\n\n  static async mediaGroup(ctx: Context, media: InputMedia[]): Promise<void> {\n    await ctx.replyWithMediaGroup(media);\n  }\n}\n\n// Process image with vision\nasync function processImage(ctx: Context): Promise<void> {\n  const photo = ctx.message.photo.pop(); // Highest resolution\n  const file = await ctx.telegram.getFile(photo.file_id);\n  const imageUrl = `https://api.telegram.org/file/bot${BOT_TOKEN}/${file.file_path}`;\n\n  // Process with vision model\n  const analysis = await runtime.process({\n    content: 'Analyze this image',\n    images: [imageUrl],\n    userId: ctx.from.id.toString(),\n  });\n\n  await ctx.reply(analysis.text);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-session-management",children:"3. Session Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Session manager for conversation state\nclass SessionManager {\n  private sessions: Map<string, UserSession> = new Map();\n  private readonly SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes\n\n  async getSession(userId: string): Promise<UserSession> {\n    let session = this.sessions.get(userId);\n\n    if (!session || this.isExpired(session)) {\n      session = await this.createSession(userId);\n      this.sessions.set(userId, session);\n    }\n\n    session.lastActivity = Date.now();\n    return session;\n  }\n\n  private async createSession(userId: string): Promise<UserSession> {\n    // Load user data from database\n    const userData = await this.loadUserData(userId);\n\n    return {\n      userId,\n      conversationHistory: [],\n      preferences: userData?.preferences || defaultPreferences,\n      metadata: {},\n      createdAt: Date.now(),\n      lastActivity: Date.now(),\n    };\n  }\n\n  private isExpired(session: UserSession): boolean {\n    return Date.now() - session.lastActivity > this.SESSION_TIMEOUT;\n  }\n\n  // Middleware for session management\n  middleware() {\n    return async (ctx: Context, next: () => Promise<void>) => {\n      if (ctx.from) {\n        ctx.session = await this.getSession(ctx.from.id.toString());\n      }\n      await next();\n    };\n  }\n}\n\n// Use session in handlers\nbot.use(sessionManager.middleware());\n\nbot.on('text', async (ctx) => {\n  const session = ctx.session;\n\n  // Add to conversation history\n  session.conversationHistory.push({\n    role: 'user',\n    content: ctx.message.text,\n    timestamp: Date.now(),\n  });\n\n  // Process with context\n  const response = await runtime.process({\n    content: ctx.message.text,\n    conversationHistory: session.conversationHistory,\n    preferences: session.preferences,\n  });\n\n  // Update history\n  session.conversationHistory.push({\n    role: 'assistant',\n    content: response.text,\n    timestamp: Date.now(),\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"webhook-vs-polling",children:"Webhook vs Polling"}),"\n",(0,i.jsx)(n.h3,{id:"1-webhook-configuration",children:"1. Webhook Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Webhook setup\nclass WebhookManager {\n  private app: Express;\n  private bot: Telegraf;\n\n  constructor(bot: Telegraf, webhookUrl: string) {\n    this.bot = bot;\n    this.app = express();\n    this.setupWebhook(webhookUrl);\n  }\n\n  private setupWebhook(webhookUrl: string): void {\n    const webhookPath = `/telegram/${this.bot.secretPathComponent()}`;\n\n    // Set webhook\n    this.bot.telegram.setWebhook(`${webhookUrl}${webhookPath}`);\n\n    // Setup express middleware\n    this.app.use(express.json());\n\n    // Webhook endpoint\n    this.app.post(webhookPath, (req, res) => {\n      this.bot.handleUpdate(req.body);\n      res.sendStatus(200);\n    });\n\n    // Health check\n    this.app.get('/health', (req, res) => {\n      res.json({ status: 'ok', service: 'telegram-bot' });\n    });\n  }\n\n  start(port: number): void {\n    this.app.listen(port, () => {\n      console.log(`Webhook server listening on port ${port}`);\n    });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-polling-configuration",children:"2. Polling Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Enhanced polling with error handling\nclass PollingManager {\n  private bot: Telegraf;\n  private pollingOptions: Telegraf.LaunchOptions;\n\n  constructor(bot: Telegraf) {\n    this.bot = bot;\n    this.pollingOptions = {\n      allowedUpdates: [\n        'message',\n        'edited_message',\n        'callback_query',\n        'inline_query',\n        'chosen_inline_result',\n        'channel_post',\n        'edited_channel_post',\n      ],\n      dropPendingUpdates: true,\n      pollingTimeout: 30,\n    };\n  }\n\n  async start(): Promise<void> {\n    try {\n      await this.bot.launch(this.pollingOptions);\n      console.log('Bot started with long polling');\n    } catch (error) {\n      console.error('Failed to start bot:', error);\n      // Retry logic\n      setTimeout(() => this.start(), 5000);\n    }\n  }\n\n  stop(): void {\n    this.bot.stop('SIGTERM');\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"rate-limiting--throttling",children:"Rate Limiting & Throttling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Rate limiter implementation\nclass TelegramRateLimiter {\n  private limits: Map<string, RateLimit> = new Map();\n\n  constructor(\n    private config: {\n      messagesPerMinute: number;\n      burstSize: number;\n      globalLimit: number;\n    }\n  ) {}\n\n  async checkLimit(userId: string): Promise<boolean> {\n    const userLimit = this.limits.get(userId) || this.createLimit();\n    const now = Date.now();\n\n    // Refill tokens\n    const elapsed = now - userLimit.lastRefill;\n    const tokensToAdd = Math.floor((elapsed / 60000) * this.config.messagesPerMinute);\n\n    userLimit.tokens = Math.min(userLimit.tokens + tokensToAdd, this.config.burstSize);\n    userLimit.lastRefill = now;\n\n    // Check if user has tokens\n    if (userLimit.tokens > 0) {\n      userLimit.tokens--;\n      this.limits.set(userId, userLimit);\n      return true;\n    }\n\n    return false;\n  }\n\n  middleware() {\n    return async (ctx: Context, next: () => Promise<void>) => {\n      if (!ctx.from) {\n        await next();\n        return;\n      }\n\n      const allowed = await this.checkLimit(ctx.from.id.toString());\n\n      if (!allowed) {\n        await ctx.reply(\n          '\u23f3 Rate limit exceeded. Please wait a moment before sending more messages.',\n          { reply_to_message_id: ctx.message?.message_id }\n        );\n        return;\n      }\n\n      await next();\n    };\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"group-chat-management",children:"Group Chat Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Group chat handler\nclass GroupChatHandler {\n  private groupSettings: Map<string, GroupSettings> = new Map();\n\n  async handleGroupMessage(ctx: Context): Promise<void> {\n    const chatId = ctx.chat.id.toString();\n    const settings = await this.getGroupSettings(chatId);\n\n    // Check if bot was mentioned\n    const botUsername = ctx.botInfo.username;\n    const wasMentioned = ctx.message.text?.includes(`@${botUsername}`);\n    const wasRepliedTo = ctx.message.reply_to_message?.from?.id === ctx.botInfo.id;\n\n    // Only respond if configured to or mentioned\n    if (!settings.alwaysRespond && !wasMentioned && !wasRepliedTo) {\n      return;\n    }\n\n    // Process message\n    await this.processGroupMessage(ctx, settings);\n  }\n\n  private async processGroupMessage(ctx: Context, settings: GroupSettings): Promise<void> {\n    // Clean mention from text\n    const text = ctx.message.text.replace(/@\\w+/g, '').trim();\n\n    const response = await runtime.process({\n      content: text,\n      roomId: ctx.chat.id.toString(),\n      userId: ctx.from.id.toString(),\n      isGroupChat: true,\n      groupSettings: settings,\n    });\n\n    // Send response with reply\n    await ctx.reply(response.text, {\n      reply_to_message_id: ctx.message.message_id,\n      allow_sending_without_reply: true,\n    });\n  }\n}\n\n// Group administration commands\nbot.command('config', adminOnly(), async (ctx) => {\n  const keyboard = {\n    inline_keyboard: [\n      [{ text: '\ud83d\udd0a Always Respond', callback_data: 'group:toggle:always_respond' }],\n      [{ text: '\ud83d\udeab Ignore List', callback_data: 'group:ignore_list' }],\n      [{ text: '\u23f0 Quiet Hours', callback_data: 'group:quiet_hours' }],\n    ],\n  };\n\n  await ctx.reply('Group Configuration:', { reply_markup: keyboard });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling--recovery",children:"Error Handling & Recovery"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Comprehensive error handler\nclass TelegramErrorHandler {\n  private errorCounts: Map<string, number> = new Map();\n  private readonly MAX_RETRIES = 3;\n\n  async handle(error: any, ctx: Context): Promise<void> {\n    const errorKey = this.getErrorKey(error);\n    const count = (this.errorCounts.get(errorKey) || 0) + 1;\n    this.errorCounts.set(errorKey, count);\n\n    console.error('Telegram error:', error);\n\n    // Handle specific errors\n    if (error.code === 429) {\n      // Rate limit\n      const retryAfter = error.parameters?.retry_after || 60;\n      await this.handleRateLimit(ctx, retryAfter);\n    } else if (error.code === 'ETELEGRAM') {\n      // Telegram API error\n      await this.handleApiError(ctx, error);\n    } else if (count < this.MAX_RETRIES) {\n      // Retry\n      await this.retry(ctx, error);\n    } else {\n      // Final failure\n      await this.handleFinalFailure(ctx, error);\n    }\n  }\n\n  private async handleRateLimit(ctx: Context, retryAfter: number): Promise<void> {\n    console.log(`Rate limited. Retry after ${retryAfter} seconds`);\n\n    setTimeout(async () => {\n      try {\n        await ctx.reply('Sorry for the delay. Processing your request now...');\n      } catch (e) {\n        console.error('Failed to send delayed message:', e);\n      }\n    }, retryAfter * 1000);\n  }\n\n  private async retry(ctx: Context, error: any): Promise<void> {\n    const delay = Math.pow(2, this.errorCounts.get(this.getErrorKey(error)) || 1) * 1000;\n\n    setTimeout(async () => {\n      try {\n        // Retry the operation\n        await ctx.scene.reenter();\n      } catch (e) {\n        await this.handle(e, ctx);\n      }\n    }, delay);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"1-unit-testing",children:"1. Unit Testing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Test Telegram handlers\ndescribe('TelegramService', () => {\n  let service: TelegramService;\n  let mockBot: jest.Mocked<Telegraf>;\n  let mockRuntime: jest.Mocked<IAgentRuntime>;\n\n  beforeEach(() => {\n    mockBot = createMockBot();\n    mockRuntime = createMockRuntime();\n    service = new TelegramService({ bot: mockBot });\n  });\n\n  test('handles text message', async () => {\n    const ctx = createMockContext({\n      message: { text: 'Hello bot' },\n      from: { id: 123, username: 'testuser' },\n    });\n\n    await service.handleMessage(ctx);\n\n    expect(mockRuntime.process).toHaveBeenCalledWith({\n      content: 'Hello bot',\n      userId: '123',\n      platform: 'telegram',\n    });\n\n    expect(ctx.reply).toHaveBeenCalled();\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-integration-testing",children:"2. Integration Testing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Test bot flow\ndescribe('Telegram Bot Flow', () => {\n  let bot: Telegraf;\n\n  beforeAll(async () => {\n    bot = new Telegraf(process.env.TEST_BOT_TOKEN);\n    await bot.launch();\n  });\n\n  afterAll(() => {\n    bot.stop();\n  });\n\n  test('command flow', async () => {\n    const response = await sendCommand('/start');\n    expect(response.text).toContain('Welcome');\n\n    const helpResponse = await sendCommand('/help');\n    expect(helpResponse.text).toContain('Available commands');\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(n.h3,{id:"1-message-queue",children:"1. Message Queue"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Queue for handling high volume\nclass MessageQueue {\n  private queue: Queue<QueuedMessage>;\n  private processing = false;\n\n  constructor(private concurrency: number = 5) {\n    this.queue = new Queue('telegram-messages', {\n      connection: redis,\n    });\n\n    this.queue.process(this.concurrency, async (job) => {\n      await this.processMessage(job.data);\n    });\n  }\n\n  async add(message: QueuedMessage): Promise<void> {\n    await this.queue.add(message, {\n      attempts: 3,\n      backoff: {\n        type: 'exponential',\n        delay: 2000,\n      },\n    });\n  }\n\n  private async processMessage(message: QueuedMessage): Promise<void> {\n    const response = await runtime.process(message.context);\n    await this.sendResponse(message.chatId, response);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-caching-strategy",children:"2. Caching Strategy"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Response cache\nclass ResponseCache {\n  private cache: Redis;\n  private readonly TTL = 300; // 5 minutes\n\n  async get(key: string): Promise<string | null> {\n    return await this.cache.get(key);\n  }\n\n  async set(key: string, value: string): Promise<void> {\n    await this.cache.setex(key, this.TTL, value);\n  }\n\n  generateKey(message: string, userId: string): string {\n    return `telegram:response:${createHash('md5').update(`${message}:${userId}`).digest('hex')}`;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-input-validation",children:"1. Input Validation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Validate and sanitize input\nclass InputValidator {\n  static validateCommand(input: string): boolean {\n    const commandRegex = /^\\/[a-zA-Z0-9_]{1,32}(\\s.*)?$/;\n    return commandRegex.test(input);\n  }\n\n  static sanitizeText(text: string): string {\n    return text\n      .replace(/[<>]/g, '') // Remove potential HTML\n      .substring(0, 4096); // Telegram message limit\n  }\n\n  static validateCallbackData(data: string): boolean {\n    return data.length <= 64; // Telegram limit\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-authentication-middleware",children:"2. Authentication Middleware"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// User authentication\nconst authenticate = () => {\n  return async (ctx: Context, next: () => Promise<void>) => {\n    const userId = ctx.from?.id;\n\n    if (!userId) {\n      await ctx.reply('Authentication required.');\n      return;\n    }\n\n    const user = await userService.authenticate(userId.toString());\n\n    if (!user) {\n      await ctx.reply('Please register first using /start');\n      return;\n    }\n\n    ctx.state.user = user;\n    await next();\n  };\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"production-deployment",children:"Production Deployment"}),"\n",(0,i.jsx)(n.h3,{id:"1-environment-configuration",children:"1. Environment Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-env",children:"# Required\nTELEGRAM_BOT_TOKEN=your_bot_token\n\n# Webhook (production)\nWEBHOOK_URL=https://your-domain.com\nWEBHOOK_PORT=8443\nWEBHOOK_SECRET=random_secret_string\n\n# Database\nPOSTGRES_URL=postgresql://...\nREDIS_URL=redis://...\n\n# Monitoring\nSENTRY_DSN=your_sentry_dsn\nLOG_LEVEL=info\n\n# Features\nENABLE_VOICE=true\nENABLE_GROUPS=true\nMAX_MESSAGE_LENGTH=4096\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-docker-configuration",children:"2. Docker Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dockerfile",children:'FROM node:18-alpine\n\nWORKDIR /app\n\nCOPY package*.json ./\nRUN bun install --production\n\nCOPY . .\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD node healthcheck.js\n\nEXPOSE 8443\n\nCMD ["node", "dist/index.js"]\n'})}),"\n",(0,i.jsx)(n.h2,{id:"monitoring--analytics",children:"Monitoring & Analytics"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Analytics tracker\nclass TelegramAnalytics {\n  async trackEvent(event: string, properties: any): Promise<void> {\n    await analytics.track({\n      event,\n      properties: {\n        ...properties,\n        platform: 'telegram',\n        timestamp: new Date(),\n      },\n    });\n  }\n\n  async trackMessage(ctx: Context): Promise<void> {\n    await this.trackEvent('message_received', {\n      userId: ctx.from?.id,\n      chatType: ctx.chat?.type,\n      messageType: ctx.message?.text ? 'text' : 'other',\n      hasCommand: ctx.message?.text?.startsWith('/'),\n    });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://core.telegram.org/bots/api",children:"Telegram Bot API Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://telegraf.js.org/",children:"Telegraf Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/elizaOS/eliza/tree/main/packages/plugin-telegram",children:"ElizaOS Telegram Plugin Source"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next:"})," ",(0,i.jsx)(n.a,{href:"./slack-technical",children:"Slack Technical Integration \u2192"})]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(14041);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);