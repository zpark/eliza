"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[50531],{21993:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>c,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"plugins/extending-service-types","title":"Extending Service Types","description":"The Eliza runtime allows plugins to extend the core service types through TypeScript module augmentation. This provides full type safety while allowing plugins to register their own custom services.","source":"@site/docs/plugins/extending-service-types.md","sourceDirName":"plugins","slug":"/plugins/extending-service-types","permalink":"/docs/plugins/extending-service-types","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/plugins/extending-service-types.md","tags":[],"version":"current","lastUpdatedBy":"Shaw","lastUpdatedAt":1747957163000,"frontMatter":{}}');var s=i(31085),r=i(71184);const c={},l="Extending Service Types",o={},a=[{value:"How to Extend Service Types",id:"how-to-extend-service-types",level:2},{value:"1. In your plugin&#39;s type definitions",id:"1-in-your-plugins-type-definitions",level:3},{value:"2. Implement your service class",id:"2-implement-your-service-class",level:3},{value:"3. Register the service in your plugin",id:"3-register-the-service-in-your-plugin",level:3},{value:"4. Use the service with full type safety",id:"4-use-the-service-with-full-type-safety",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Example: Complete Plugin Structure",id:"example-complete-plugin-structure",level:2},{value:"Runtime Behavior",id:"runtime-behavior",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"extending-service-types",children:"Extending Service Types"})}),"\n",(0,s.jsx)(n.p,{children:"The Eliza runtime allows plugins to extend the core service types through TypeScript module augmentation. This provides full type safety while allowing plugins to register their own custom services."}),"\n",(0,s.jsx)(n.h2,{id:"how-to-extend-service-types",children:"How to Extend Service Types"}),"\n",(0,s.jsx)(n.h3,{id:"1-in-your-plugins-type-definitions",children:"1. In your plugin's type definitions"}),"\n",(0,s.jsxs)(n.p,{children:["Create a type declaration file (e.g., ",(0,s.jsx)(n.code,{children:"types.ts"}),") in your plugin:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// In your plugin's types.ts or index.ts\ndeclare module '@elizaos/core' {\n  interface ServiceTypeRegistry {\n    // Add your custom service types here\n    BLOCKCHAIN: 'blockchain';\n    WEATHER: 'weather';\n    NOTIFICATION: 'notification';\n    CUSTOM_AI: 'custom_ai';\n  }\n}\n\n// Export your service type constants for use in your plugin\nexport const MyPluginServiceType = {\n  BLOCKCHAIN: 'blockchain' as const,\n  WEATHER: 'weather' as const,\n  NOTIFICATION: 'notification' as const,\n  CUSTOM_AI: 'custom_ai' as const,\n} satisfies Partial<import('@elizaos/core').ServiceTypeRegistry>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-implement-your-service-class",children:"2. Implement your service class"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Service, type IAgentRuntime } from '@elizaos/core';\nimport { MyPluginServiceType } from './types';\n\nexport class BlockchainService extends Service {\n  static serviceType = MyPluginServiceType.BLOCKCHAIN;\n  capabilityDescription = 'Provides blockchain interaction capabilities';\n\n  static async start(runtime: IAgentRuntime): Promise<BlockchainService> {\n    const service = new BlockchainService(runtime);\n    // Initialize your service\n    return service;\n  }\n\n  async stop(): Promise<void> {\n    // Cleanup logic\n  }\n\n  // Your service implementation\n  async getBalance(address: string): Promise<string> {\n    // Implementation\n    return '0';\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-register-the-service-in-your-plugin",children:"3. Register the service in your plugin"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { type Plugin } from '@elizaos/core';\nimport { BlockchainService } from './services/blockchain';\nimport './types'; // Ensure module augmentation is loaded\n\nexport const myPlugin: Plugin = {\n  name: 'my-blockchain-plugin',\n  description: 'Adds blockchain capabilities',\n  services: [BlockchainService],\n  // ... other plugin properties\n};\n\nexport * from './types';\nexport * from './services/blockchain';\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-use-the-service-with-full-type-safety",children:"4. Use the service with full type safety"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// In your actions, evaluators, or other plugin code\nconst blockchainService = runtime.getService<BlockchainService>(MyPluginServiceType.BLOCKCHAIN);\nif (blockchainService) {\n  const balance = await blockchainService.getBalance('0x...');\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"benefits",children:"Benefits"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Full Type Safety"}),": TypeScript will provide autocomplete and type checking for your custom service types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"IDE Support"}),": Your IDE will show your custom service types in autocomplete"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Runtime Safety"}),": The runtime will properly handle your custom services"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No Conflicts"}),": Multiple plugins can extend service types without conflicts"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-complete-plugin-structure",children:"Example: Complete Plugin Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"my-plugin/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 types.ts          # Service type extensions\n\u2502   \u2502   \u2514\u2500\u2500 weather.ts    # Service implementation\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u2514\u2500\u2500 getWeather.ts # Actions using the service\n\u2502   \u2514\u2500\u2500 index.ts          # Plugin definition\n\u2514\u2500\u2500 package.json\n"})}),"\n",(0,s.jsx)(n.h2,{id:"runtime-behavior",children:"Runtime Behavior"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Services are registered during plugin initialization"}),"\n",(0,s.jsxs)(n.li,{children:["The runtime maintains a ",(0,s.jsx)(n.code,{children:"Map<ServiceTypeName, Service>"})," of all registered services"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"runtime.getService()"})," provides type-safe access to any registered service"]}),"\n",(0,s.jsx)(n.li,{children:"Services can be accessed by any part of the runtime (actions, evaluators, providers, etc.)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This approach ensures that your plugin's service types are fully integrated into the Eliza type system while maintaining clean separation between core and plugin functionality."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},71184:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>l});var t=i(14041);const s={},r=t.createContext(s);function c(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);