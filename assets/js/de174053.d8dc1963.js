"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[21170],{23881:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"technical/architecture/state-management","title":"State Management Architecture","description":"ElizaOS implements a sophisticated state management system that handles dynamic state composition, memory persistence, and efficient caching across multiple agents and platforms.","source":"@site/docs/technical/architecture/state-management.md","sourceDirName":"technical/architecture","slug":"/technical/architecture/state-management","permalink":"/docs/technical/architecture/state-management","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/technical/architecture/state-management.md","tags":[],"version":"current","lastUpdatedBy":"Sayo","lastUpdatedAt":1751802400000,"frontMatter":{},"sidebar":"technicalSidebar","previous":{"title":"\ud83e\udde0 Core Concepts","permalink":"/docs/technical/architecture/core-concepts"},"next":{"title":"\ud83e\udde9 Memory System","permalink":"/docs/technical/architecture/memory-system"}}');var s=t(31085),i=t(71184);const a={},o="State Management Architecture",c={},l=[{value:"Overview",id:"overview",level:2},{value:"State Architecture",id:"state-architecture",level:2},{value:"State Interface",id:"state-interface",level:3},{value:"State Composition Process",id:"state-composition-process",level:3},{value:"Provider Aggregation",id:"provider-aggregation",level:4},{value:"Provider Position System",id:"provider-position-system",level:4},{value:"Memory System",id:"memory-system",level:2},{value:"Memory Types",id:"memory-types",level:3},{value:"Memory Structure",id:"memory-structure",level:3},{value:"Memory Operations",id:"memory-operations",level:3},{value:"Creating Memories",id:"creating-memories",level:4},{value:"Retrieving Memories",id:"retrieving-memories",level:4},{value:"Memory Scoping",id:"memory-scoping",level:3},{value:"Semantic Search",id:"semantic-search",level:3},{value:"Caching System",id:"caching-system",level:2},{value:"State Cache",id:"state-cache",level:3},{value:"Cache Invalidation",id:"cache-invalidation",level:3},{value:"Database Integration",id:"database-integration",level:2},{value:"Database Adapter Pattern",id:"database-adapter-pattern",level:3},{value:"Supported Databases",id:"supported-databases",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"State Management",id:"state-management",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"State Composition Errors",id:"state-composition-errors",level:3},{value:"Memory Operation Errors",id:"memory-operation-errors",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Custom Provider",id:"custom-provider",level:3},{value:"Memory-Backed Provider",id:"memory-backed-provider",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"state-management-architecture",children:"State Management Architecture"})}),"\n",(0,s.jsx)(n.p,{children:"ElizaOS implements a sophisticated state management system that handles dynamic state composition, memory persistence, and efficient caching across multiple agents and platforms."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The state management system is built around three core concepts:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Composition"})," - Dynamic aggregation of context from multiple providers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory System"})," - Persistent storage with semantic search capabilities"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Caching Layer"})," - Efficient state retrieval and composition optimization"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"state-architecture",children:"State Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"state-interface",children:"State Interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface State {\n  values: { [key: string]: any }; // Direct state values\n  data: { [key: string]: any }; // Structured/provider data\n  text: string; // Textual context summary\n  [key: string]: any; // Dynamic properties\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The state object serves as the primary context container that agents use to make decisions and generate responses."}),"\n",(0,s.jsx)(n.h3,{id:"state-composition-process",children:"State Composition Process"}),"\n",(0,s.jsx)(n.p,{children:"State composition follows a structured pipeline:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Provider Registration"})," - Providers register with the runtime during initialization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Context Assembly"})," - State is dynamically composed by aggregating provider outputs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Caching"})," - Composed states are cached by message ID for performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Template Rendering"})," - State is used to render prompt templates"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"provider-aggregation",children:"Provider Aggregation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/runtime.ts:composeState()\nasync composeState(\n  message: Memory,\n  additionalKeys?: { [key: string]: string }\n): Promise<State> {\n  // 1. Check cache for existing state\n  const cachedState = this.stateCache.get(message.id);\n  if (cachedState) return cachedState;\n\n  // 2. Initialize base state\n  const state: State = {\n    values: {},\n    data: {},\n    text: ''\n  };\n\n  // 3. Aggregate provider data\n  const providerOutputs = await Promise.all(\n    this.providers\n      .filter(provider => shouldIncludeProvider(provider, message))\n      .sort((a, b) => (a.position || 0) - (b.position || 0))\n      .map(provider => provider.get(this, message, state))\n  );\n\n  // 4. Merge provider outputs into state\n  for (const output of providerOutputs) {\n    if (output?.text) state.text += output.text + '\\n';\n    if (output?.data) Object.assign(state.data, output.data);\n    if (output?.values) Object.assign(state.values, output.values);\n  }\n\n  // 5. Cache and return composed state\n  this.stateCache.set(message.id, state);\n  return state;\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"provider-position-system",children:"Provider Position System"}),"\n",(0,s.jsxs)(n.p,{children:["Providers are executed in order based on their ",(0,s.jsx)(n.code,{children:"position"})," property:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Low numbers (0-100)"}),": Base context (character, world state)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Medium numbers (100-500)"}),": Dynamic context (recent messages, entities)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High numbers (500+)"}),": Real-time context (current conversation, immediate state)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"memory-system",children:"Memory System"}),"\n",(0,s.jsx)(n.h3,{id:"memory-types",children:"Memory Types"}),"\n",(0,s.jsx)(n.p,{children:"ElizaOS supports multiple memory types for different use cases:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"enum MemoryType {\n  DOCUMENT = 'document', // Complete documents or large text chunks\n  FRAGMENT = 'fragment', // Document segments for embedding/search\n  MESSAGE = 'message', // Conversational messages\n  DESCRIPTION = 'description', // Descriptive information about entities\n  CUSTOM = 'custom', // Extension point for custom types\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"memory-structure",children:"Memory Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface Memory {\n  id: UUID;\n  entityId: UUID; // User/agent who created this memory\n  worldId?: UUID; // World/server context\n  roomId?: UUID; // Room/channel context\n  content: Content; // Text content with metadata\n  type: MemoryType;\n  metadata?: {\n    scope: 'shared' | 'private' | 'room';\n    source?: string; // Origin platform/service\n    timestamp: number;\n    sequence?: number; // Ordering within conversation\n    [key: string]: any; // Custom metadata\n  };\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"memory-operations",children:"Memory Operations"}),"\n",(0,s.jsx)(n.h4,{id:"creating-memories",children:"Creating Memories"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Store a new memory\nawait runtime.memory.create({\n  entityId: message.entityId,\n  worldId: message.worldId,\n  roomId: message.roomId,\n  content: {\n    text: 'Important information to remember',\n    metadata: { type: 'fact' },\n  },\n  type: MemoryType.DESCRIPTION,\n  metadata: {\n    scope: 'shared',\n    source: 'discord',\n    timestamp: Date.now(),\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"retrieving-memories",children:"Retrieving Memories"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Search memories by content similarity\nconst memories = await runtime.memory.searchMemoriesByEmbedding(embedding, {\n  match_threshold: 0.8,\n  count: 10,\n  tableName: 'memories',\n  worldId: message.worldId,\n  roomId: message.roomId,\n});\n\n// Get recent memories in a room\nconst recent = await runtime.memory.getMemories({\n  roomId: message.roomId,\n  count: 20,\n  unique: false,\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"memory-scoping",children:"Memory Scoping"}),"\n",(0,s.jsx)(n.p,{children:"ElizaOS implements three memory scoping levels:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Private"})," (",(0,s.jsx)(n.code,{children:"scope: 'private'"}),") - Only accessible to the creating agent"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Room"})," (",(0,s.jsx)(n.code,{children:"scope: 'room'"}),") - Shared within a specific room/channel"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Shared"})," (",(0,s.jsx)(n.code,{children:"scope: 'shared'"}),") - Globally accessible across the world"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"semantic-search",children:"Semantic Search"}),"\n",(0,s.jsx)(n.p,{children:"Memory retrieval uses vector embeddings for semantic search:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/memory.ts\nasync searchMemoriesByEmbedding(\n  embedding: number[],\n  options: {\n    match_threshold?: number;  // Similarity threshold (0-1)\n    count?: number;            // Maximum results\n    tableName: string;         // Target memory table\n    worldId?: UUID;            // World context filter\n    roomId?: UUID;             // Room context filter\n  }\n): Promise<Memory[]>\n"})}),"\n",(0,s.jsx)(n.h2,{id:"caching-system",children:"Caching System"}),"\n",(0,s.jsx)(n.h3,{id:"state-cache",children:"State Cache"}),"\n",(0,s.jsx)(n.p,{children:"The runtime maintains an in-memory cache of composed states:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/runtime.ts\nprivate stateCache = new Map<UUID, State>();\n\n// Cache management\nprivate pruneStateCache(): void {\n  if (this.stateCache.size > 1000) {\n    // Remove oldest entries when cache grows too large\n    const entries = Array.from(this.stateCache.entries());\n    entries.slice(0, 500).forEach(([key]) => {\n      this.stateCache.delete(key);\n    });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cache-invalidation",children:"Cache Invalidation"}),"\n",(0,s.jsx)(n.p,{children:"State cache is automatically managed:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache Hit"}),": Returns cached state if available for message ID"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache Miss"}),": Composes new state and caches result"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache Pruning"}),": Automatic cleanup when cache size exceeds limits"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Manual Invalidation"}),": Cache can be cleared during runtime operations"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"database-integration",children:"Database Integration"}),"\n",(0,s.jsx)(n.h3,{id:"database-adapter-pattern",children:"Database Adapter Pattern"}),"\n",(0,s.jsxs)(n.p,{children:["ElizaOS uses the ",(0,s.jsx)(n.code,{children:"IDatabaseAdapter"})," interface to abstract database operations:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface IDatabaseAdapter {\n  // Memory operations\n  createMemory(memory: Memory, tableName: string): Promise<void>;\n  getMemories(params: GetMemoriesParams): Promise<Memory[]>;\n  searchMemoriesByEmbedding(embedding: number[], options: SearchOptions): Promise<Memory[]>;\n\n  // Entity operations\n  createEntity(entity: Entity): Promise<boolean>;\n  getEntity(params: { id: UUID }): Promise<Entity | null>;\n\n  // World operations\n  createWorld(world: World): Promise<boolean>;\n  getWorlds(params: { entityId: UUID }): Promise<World[]>;\n\n  // Room operations\n  createRoom(room: Room): Promise<boolean>;\n  getRoom(params: { id: UUID }): Promise<Room | null>;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"supported-databases",children:"Supported Databases"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"PostgreSQL"})," - Production database with full feature support"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"PGLite"})," - Lightweight SQLite-compatible database for development"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Custom Adapters"})," - Extensible adapter system for other databases"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"state-management",children:"State Management"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Provider Positioning"})," - Use appropriate position values to control execution order"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient Providers"})," - Keep provider logic lightweight and fast"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Immutability"})," - Don't modify state objects after composition"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache Awareness"})," - Consider caching behavior when designing providers"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Appropriate Scoping"})," - Choose correct scope level for memory visibility"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Metadata Usage"})," - Include relevant metadata for filtering and organization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Types"})," - Use specific memory types for semantic organization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Search Optimization"})," - Structure content for effective semantic search"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Provider Efficiency"})," - Minimize database queries in providers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batch Operations"})," - Use batch operations for multiple memory writes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Embedding Caching"})," - Cache embeddings when possible to avoid recomputation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Cleanup"})," - Implement periodic cleanup of old memories"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"state-composition-errors",children:"State Composition Errors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"try {\n  const state = await runtime.composeState(message);\n} catch (error) {\n  console.error('State composition failed:', error);\n  // Fallback to minimal state\n  return {\n    values: {},\n    data: {},\n    text: message.content.text || '',\n  };\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"memory-operation-errors",children:"Memory Operation Errors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"try {\n  await runtime.memory.create(memory);\n} catch (error) {\n  if (error.code === 'DUPLICATE_KEY') {\n    // Handle duplicate memory\n  } else {\n    // Log and continue\n    console.error('Memory creation failed:', error);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,s.jsx)(n.h3,{id:"custom-provider",children:"Custom Provider"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const customProvider: Provider = {\n  get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\n    // Fetch relevant context data\n    const context = await fetchCustomContext(message);\n\n    return {\n      text: `Custom context: ${context.summary}`,\n      data: { customData: context },\n      values: { hasCustomContext: true },\n    };\n  },\n};\n\n// Register provider\nruntime.registerProvider(customProvider);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"memory-backed-provider",children:"Memory-Backed Provider"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const memoryProvider: Provider = {\n  get: async (runtime: IAgentRuntime, message: Memory) => {\n    // Search for relevant memories\n    const memories = await runtime.memory.searchMemoriesByEmbedding(\n      await runtime.embed(message.content.text),\n      {\n        match_threshold: 0.7,\n        count: 5,\n        tableName: 'memories',\n        roomId: message.roomId,\n      }\n    );\n\n    return {\n      text: memories.map((m) => m.content.text).join('\\n'),\n      data: { relevantMemories: memories },\n    };\n  },\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"This state management system provides the foundation for ElizaOS's intelligent agent behavior, enabling dynamic context composition, persistent memory, and efficient state handling across complex multi-agent environments."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(14041);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);