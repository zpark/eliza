"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[71435],{28763:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"core/tasks","title":"Tasks System","description":"Understanding ElizaOS tasks - managing deferred, scheduled, and interactive operations","source":"@site/docs/core/tasks.md","sourceDirName":"core","slug":"/core/tasks","permalink":"/docs/core/tasks","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/core/tasks.md","tags":[],"version":"current","lastUpdatedBy":"0xbbjoker","lastUpdatedAt":1750196313000,"sidebarPosition":9,"frontMatter":{"sidebar_position":9,"title":"Tasks System","description":"Understanding ElizaOS tasks - managing deferred, scheduled, and interactive operations","keywords":["tasks","scheduling","automation","workers","recurring tasks","task management"],"image":"/img/tasks.jpg"},"sidebar":"tutorialSidebar","previous":{"title":"Services","permalink":"/docs/core/services"},"next":{"title":"Worlds","permalink":"/docs/core/worlds"}}');var a=s(31085),i=s(71184);const r={sidebar_position:9,title:"Tasks System",description:"Understanding ElizaOS tasks - managing deferred, scheduled, and interactive operations",keywords:["tasks","scheduling","automation","workers","recurring tasks","task management"],image:"/img/tasks.jpg"},o="Tasks",c={},d=[{value:"Task Structure",id:"task-structure",level:2},{value:"Task Service",id:"task-service",level:2},{value:"Task Workers",id:"task-workers",level:2},{value:"Creating and Managing Tasks",id:"creating-and-managing-tasks",level:2},{value:"Registering a Task Worker",id:"registering-a-task-worker",level:3},{value:"Creating a One-time Task",id:"creating-a-one-time-task",level:3},{value:"Creating a Recurring Task",id:"creating-a-recurring-task",level:3},{value:"Creating a Task Awaiting User Choice",id:"creating-a-task-awaiting-user-choice",level:3},{value:"Managing Tasks",id:"managing-tasks",level:3},{value:"Task Processing",id:"task-processing",level:2},{value:"Automatic Processing with Task Service",id:"automatic-processing-with-task-service",level:3},{value:"Recurring Task Logic",id:"recurring-task-logic",level:3},{value:"Choice Tasks with AWAITING_CHOICE",id:"choice-tasks-with-awaiting_choice",level:3},{value:"Common Task Patterns",id:"common-task-patterns",level:2},{value:"Immediate Execution Tasks",id:"immediate-execution-tasks",level:3},{value:"Conditional Recurring Tasks",id:"conditional-recurring-tasks",level:3},{value:"Multi-step Workflows",id:"multi-step-workflows",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Task Execution Flow",id:"task-execution-flow",level:2},{value:"Limitations",id:"limitations",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"tasks",children:"Tasks"})}),"\n",(0,a.jsx)(n.p,{children:"Tasks in ElizaOS provide a powerful way to manage deferred, scheduled, and interactive operations. The Task system allows agents to queue work for later execution, repeat actions at defined intervals, await user input, and implement complex workflows across multiple interactions."}),"\n",(0,a.jsx)(n.h2,{id:"task-structure",children:"Task Structure"}),"\n",(0,a.jsx)(n.p,{children:"A task in ElizaOS has the following properties:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface Task {\n  id?: UUID; // Unique identifier (auto-generated if not provided)\n  name: string; // Name of the task (must match a registered task worker)\n  description: string; // Human-readable description of the task\n  roomId?: UUID; // Optional room association (for room-specific tasks)\n  worldId?: UUID; // Optional world association (for world-specific tasks)\n  entityId?: UUID; // Optional entity association\n  tags: string[]; // Tags for categorizing and filtering tasks\n  updatedAt?: number; // Timestamp when the task was last updated\n  metadata?: {\n    // Optional additional configuration\n    updateInterval?: number; // For repeating tasks: milliseconds between executions\n    options?: {\n      // For choice tasks: options for user selection\n      name: string;\n      description: string;\n    }[];\n    [key: string]: unknown; // Additional custom metadata\n  };\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"task-service",children:"Task Service"}),"\n",(0,a.jsxs)(n.p,{children:["The Task Service (provided by ",(0,a.jsx)(n.code,{children:"@elizaos/plugin-bootstrap"}),") automatically manages task execution:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export class TaskService extends Service {\n  static serviceType = ServiceType.TASK;\n  private readonly TICK_INTERVAL = 1000; // Checks every second\n\n  // Automatically processes tasks with 'queue' tag\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The service:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Runs continuously, checking for tasks every second"}),"\n",(0,a.jsxs)(n.li,{children:["Automatically processes tasks with the ",(0,a.jsx)(n.code,{children:"queue"})," tag"]}),"\n",(0,a.jsx)(n.li,{children:"Handles both one-time and recurring task execution"}),"\n",(0,a.jsx)(n.li,{children:"Validates tasks before execution using the worker's validate function"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"task-workers",children:"Task Workers"}),"\n",(0,a.jsx)(n.p,{children:"Task workers define the actual logic that executes when a task runs. Each task worker is registered with the runtime and is identified by name."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface TaskWorker {\n  name: string; // Matches the name in the Task\n  execute: (\n    runtime: IAgentRuntime,\n    options: { [key: string]: unknown }, // Options passed during execution\n    task: Task // The task being executed\n  ) => Promise<void>;\n  validate?: (\n    // Optional validation before execution\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State\n  ) => Promise<boolean>;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"creating-and-managing-tasks",children:"Creating and Managing Tasks"}),"\n",(0,a.jsx)(n.h3,{id:"registering-a-task-worker",children:"Registering a Task Worker"}),"\n",(0,a.jsx)(n.p,{children:"Before creating tasks, you must register a worker to handle the execution:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"runtime.registerTaskWorker({\n  name: 'SEND_REMINDER',\n  validate: async (runtime, message, state) => {\n    // Optional validation logic\n    return true;\n  },\n  execute: async (runtime, options, task) => {\n    // Task execution logic\n    const { roomId } = task;\n    const { reminder, userId } = options;\n\n    await runtime.createMemory(\n      {\n        entityId: runtime.agentId,\n        roomId,\n        content: {\n          text: `Reminder for <@${userId}>: ${reminder}`,\n        },\n      },\n      'messages'\n    );\n\n    // Delete one-time tasks after execution (handled automatically if no 'repeat' tag)\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"creating-a-one-time-task",children:"Creating a One-time Task"}),"\n",(0,a.jsxs)(n.p,{children:["Create a task that will execute once. ",(0,a.jsx)(n.strong,{children:"Important"}),": Include the ",(0,a.jsx)(n.code,{children:"queue"})," tag for automatic processing:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"await runtime.createTask({\n  name: 'SEND_REMINDER',\n  description: 'Send a reminder message to the user',\n  roomId: currentRoomId,\n  worldId: currentWorldId, // Required field\n  tags: ['queue', 'reminder'], // 'queue' tag required for processing\n  metadata: {\n    userId: message.entityId,\n    reminder: 'Submit your weekly report',\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"creating-a-recurring-task",children:"Creating a Recurring Task"}),"\n",(0,a.jsxs)(n.p,{children:["Create a task that repeats at regular intervals. Include both ",(0,a.jsx)(n.code,{children:"queue"})," and ",(0,a.jsx)(n.code,{children:"repeat"})," tags:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"await runtime.createTask({\n  name: 'DAILY_REPORT',\n  description: 'Generate and post the daily report',\n  roomId: announcementChannelId,\n  worldId: serverWorldId, // Required field\n  tags: ['queue', 'repeat', 'daily'], // 'queue' and 'repeat' tags required\n  metadata: {\n    updateInterval: 86400000, // 24 hours in milliseconds\n    updatedAt: Date.now(), // When the task was last executed\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"creating-a-task-awaiting-user-choice",children:"Creating a Task Awaiting User Choice"}),"\n",(0,a.jsxs)(n.p,{children:["Create a task that presents options and waits for user input using the ",(0,a.jsx)(n.code,{children:"AWAITING_CHOICE"})," tag:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"await runtime.createTask({\n  name: 'CONFIRM_ACTION',\n  description: 'Confirm the requested action',\n  roomId: message.roomId,\n  worldId: message.worldId, // Required field\n  tags: ['AWAITING_CHOICE'], // Special tag for choice tasks\n  metadata: {\n    options: [\n      { name: 'confirm', description: 'Proceed with the action' },\n      { name: 'cancel', description: 'Cancel the action' },\n    ],\n    action: 'DELETE_FILES',\n    files: ['document1.txt', 'document2.txt'],\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"managing-tasks",children:"Managing Tasks"}),"\n",(0,a.jsx)(n.p,{children:"Retrieve, update, and delete tasks as needed:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Get tasks by specific criteria\nconst reminderTasks = await runtime.getTasks({\n  roomId: currentRoomId,\n  tags: ['reminder'],\n});\n\n// Get tasks by name\nconst reportTasks = await runtime.getTasksByName('DAILY_REPORT');\n\n// Get a specific task\nconst task = await runtime.getTask(taskId);\n\n// Update a task (metadata is replaced, not merged)\nawait runtime.updateTask(taskId, {\n  description: 'Updated description',\n  metadata: {\n    ...task.metadata,\n    priority: 'high',\n  },\n});\n\n// Delete a task\nawait runtime.deleteTask(taskId);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"task-processing",children:"Task Processing"}),"\n",(0,a.jsx)(n.h3,{id:"automatic-processing-with-task-service",children:"Automatic Processing with Task Service"}),"\n",(0,a.jsx)(n.p,{children:"The Task Service automatically processes tasks based on their tags:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Queue Tag"}),": Tasks must have the ",(0,a.jsx)(n.code,{children:"queue"})," tag to be processed by the Task Service"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Repeat Tag"}),": Tasks with the ",(0,a.jsx)(n.code,{children:"repeat"})," tag are kept after execution and re-executed based on their ",(0,a.jsx)(n.code,{children:"updateInterval"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"No Repeat Tag"}),": Tasks without the ",(0,a.jsx)(n.code,{children:"repeat"})," tag are automatically deleted after execution"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"recurring-task-logic",children:"Recurring Task Logic"}),"\n",(0,a.jsx)(n.p,{children:"For recurring tasks:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The task must have both ",(0,a.jsx)(n.code,{children:"queue"})," and ",(0,a.jsx)(n.code,{children:"repeat"})," tags"]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"updateInterval"})," in metadata defines the delay between executions"]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"updatedAt"})," field tracks when the task was last executed"]}),"\n",(0,a.jsxs)(n.li,{children:["Tasks with ",(0,a.jsx)(n.code,{children:"immediate"})," tag execute on first check regardless of interval"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"choice-tasks-with-awaiting_choice",children:"Choice Tasks with AWAITING_CHOICE"}),"\n",(0,a.jsxs)(n.p,{children:["Tasks tagged with ",(0,a.jsx)(n.code,{children:"AWAITING_CHOICE"})," work with the bootstrap plugin's choice system:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Choice Provider"}),": Displays available tasks with options to users"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"CHOOSE_OPTION Action"}),": Processes user selections"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"User Permissions"}),": Only OWNER and ADMIN roles can select options"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Example flow:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// 1. Create a choice task\nawait runtime.createTask({\n  name: 'DEPLOYMENT_CHOICE',\n  description: 'Choose deployment environment',\n  roomId: message.roomId,\n  worldId: message.worldId,\n  tags: ['AWAITING_CHOICE'],\n  metadata: {\n    options: [\n      { name: 'production', description: 'Deploy to production' },\n      { name: 'staging', description: 'Deploy to staging' },\n      { name: 'cancel', description: 'Cancel deployment' },\n    ],\n  },\n});\n\n// 2. User sees options via choice provider\n// \"Please select from: production, staging, cancel\"\n\n// 3. User responds with choice\n// \"production\"\n\n// 4. CHOOSE_OPTION action executes the task worker with selected option\nruntime.registerTaskWorker({\n  name: 'DEPLOYMENT_CHOICE',\n  execute: async (runtime, options, task) => {\n    if (options.option === 'production') {\n      // Deploy to production\n    } else if (options.option === 'staging') {\n      // Deploy to staging\n    }\n    // Task is automatically deleted after execution\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"common-task-patterns",children:"Common Task Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"immediate-execution-tasks",children:"Immediate Execution Tasks"}),"\n",(0,a.jsx)(n.p,{children:"For tasks that should run as soon as the Task Service checks:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"await runtime.createTask({\n  name: 'IMMEDIATE_ACTION',\n  description: 'Execute immediately',\n  roomId: message.roomId,\n  worldId: message.worldId,\n  tags: ['queue', 'immediate'], // 'immediate' tag for first-run execution\n  metadata: {\n    // Task data\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"conditional-recurring-tasks",children:"Conditional Recurring Tasks"}),"\n",(0,a.jsx)(n.p,{children:"Tasks that repeat but may stop based on conditions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"runtime.registerTaskWorker({\n  name: 'MONITOR_STATUS',\n  validate: async (runtime, message, state) => {\n    // Only execute if monitoring is still needed\n    const status = await checkSystemStatus();\n    return status !== 'completed';\n  },\n  execute: async (runtime, options, task) => {\n    const status = await checkSystemStatus();\n\n    if (status === 'completed') {\n      // Remove the repeat tag to stop recurrence\n      await runtime.updateTask(task.id, {\n        tags: task.tags.filter((tag) => tag !== 'repeat'),\n      });\n    }\n\n    // Report status\n    await runtime.createMemory(\n      {\n        entityId: runtime.agentId,\n        roomId: task.roomId,\n        content: { text: `Status: ${status}` },\n      },\n      'messages'\n    );\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"multi-step-workflows",children:"Multi-step Workflows"}),"\n",(0,a.jsx)(n.p,{children:"Implement workflows that progress through stages:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"runtime.registerTaskWorker({\n  name: 'WORKFLOW_STEP',\n  execute: async (runtime, options, task) => {\n    const currentStep = task.metadata?.step || 1;\n\n    switch (currentStep) {\n      case 1:\n        // Execute step 1\n        await executeStep1();\n\n        // Update task to next step\n        await runtime.updateTask(task.id, {\n          metadata: {\n            ...task.metadata,\n            step: 2,\n          },\n        });\n        break;\n\n      case 2:\n        // Execute step 2\n        await executeStep2();\n\n        // Create choice task for user confirmation\n        await runtime.createTask({\n          name: 'CONFIRM_COMPLETION',\n          description: 'Confirm workflow completion',\n          roomId: task.roomId,\n          worldId: task.worldId,\n          tags: ['AWAITING_CHOICE'],\n          metadata: {\n            options: [\n              { name: 'complete', description: 'Mark as complete' },\n              { name: 'restart', description: 'Start over' },\n            ],\n            workflowTaskId: task.id,\n          },\n        });\n        break;\n    }\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Always include required tags"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"queue"})," for automatic processing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"repeat"})," for recurring tasks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"AWAITING_CHOICE"})," for user selection tasks"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Set worldId"}),": The ",(0,a.jsx)(n.code,{children:"worldId"})," field is required when creating tasks"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Clean up one-time tasks"}),": Tasks without ",(0,a.jsx)(n.code,{children:"repeat"})," tag are automatically deleted after execution"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use validation wisely"}),": The ",(0,a.jsx)(n.code,{children:"validate"})," function can prevent task execution based on current conditions"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Handle errors gracefully"}),": Wrap task execution in try-catch blocks to prevent task worker failures"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Metadata management"}),": When updating tasks, remember that metadata is replaced, not merged"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use appropriate intervals"}),": For recurring tasks, choose intervals that balance timeliness with resource usage"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Secure choice tasks"}),": Only users with OWNER or ADMIN roles can select options for AWAITING_CHOICE tasks"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Short task IDs"}),": When displaying tasks to users, use shortened UUIDs (first 8 characters) for readability"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Task worker naming"}),": Use clear, descriptive names in UPPER_SNAKE_CASE for task workers"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"task-execution-flow",children:"Task Execution Flow"}),"\n",(0,a.jsx)(n.mermaid,{value:"graph TD\n    A[Task Created] --\x3e B{Has 'queue' tag?}\n    B --\x3e|No| C[Task not processed]\n    B --\x3e|Yes| D[Task Service checks every second]\n    D --\x3e E{Worker validates?}\n    E --\x3e|No| F[Skip task]\n    E --\x3e|Yes| G{Has 'repeat' tag?}\n    G --\x3e|Yes| H[Execute & Update timestamp]\n    G --\x3e|No| I[Execute & Delete task]\n    H --\x3e J[Wait for updateInterval]\n    J --\x3e D"}),"\n",(0,a.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Tasks are checked every second by the Task Service"}),"\n",(0,a.jsx)(n.li,{children:"Task metadata is limited to JSON-serializable data"}),"\n",(0,a.jsx)(n.li,{children:"Tasks require a registered worker with matching name"}),"\n",(0,a.jsx)(n.li,{children:"Only one Task Service instance should run per agent"}),"\n",(0,a.jsx)(n.li,{children:"Task execution is not guaranteed to be exactly on time (depends on check interval and system load)"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},71184:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var t=s(14041);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);