"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[282],{70488:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"tutorials/devschool/part2","title":"Part 2: Deep Dive into Actions, Providers, and Evaluators","description":"Deep Dive into Actions, Providers, and Evaluators","source":"@site/versioned_docs/version-0.25.9/tutorials/devschool/part2.md","sourceDirName":"tutorials/devschool","slug":"/tutorials/devschool/part2","permalink":"/docs/0.25.9/tutorials/devschool/part2","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/versioned_docs/version-0.25.9/tutorials/devschool/part2.md","tags":[],"version":"0.25.9","lastUpdatedBy":"madjin","lastUpdatedAt":1742171474000,"frontMatter":{"Title":"AI Agent Dev School Part 2","description":"Deep Dive into Actions, Providers, and Evaluators"},"sidebar":"tutorialSidebar","previous":{"title":"Part 1","permalink":"/docs/0.25.9/tutorials/devschool/part1"},"next":{"title":"Part 3","permalink":"/docs/0.25.9/tutorials/devschool/part3"}}');var s=t(31085),o=t(71184);const a={Title:"AI Agent Dev School Part 2",description:"Deep Dive into Actions, Providers, and Evaluators"},r="Part 2: Deep Dive into Actions, Providers, and Evaluators",c={},l=[];function d(e){const n={a:"a",code:"code",h1:"h1",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"part-2-deep-dive-into-actions-providers-and-evaluators",children:"Part 2: Deep Dive into Actions, Providers, and Evaluators"})}),"\n",(0,s.jsx)(n.p,{children:"In this second session of the AI Agent Dev School series, we take a deep dive into the key abstractions in the Eliza framework that enable developers to create powerful AI agents:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Actions"}),": The tasks and responses that agents can perform."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Providers"}),": Modules that provide information and state to the agent's context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Evaluators"}),": Modules that analyze situations and agent actions, often triggering further actions or modifications."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We explore each of these in detail, walking through code examples and common use cases. We also cover how to package up actions, providers and evaluators into reusable plugins."}),"\n",(0,s.jsx)("div",{className:"responsive-iframe",children:(0,s.jsx)("iframe",{src:"https://www.youtube.com/embed/XenGeAcPAQo",title:"YouTube video player",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowFullScreen:!0})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h1,{id:"key-sections",children:"Key Sections"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=213",children:[(0,s.jsx)(n.strong,{children:"00:03:33"})," - Shift in focus from characters (Dev School Part 1) to agent capabilities"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=429",children:[(0,s.jsx)(n.strong,{children:"00:07:09"})," - Deep dive into providers, actions, and evaluators, the core building blocks of Eliza"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=448",children:[(0,s.jsx)(n.strong,{children:"00:07:28"})," - Discussion about actions vs. tools, favoring decoupled intent and action execution"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=1082",children:[(0,s.jsx)(n.strong,{children:"00:18:02"})," - Explanation of providers and their function as information sources for agents"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=1215",children:[(0,s.jsx)(n.strong,{children:"00:20:15"})," - Introduction to evaluators and their role in agent reflection and state analysis"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=1762",children:[(0,s.jsx)(n.strong,{children:"00:29:22"})," - Brief overview of clients as connectors to external platforms"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=1862",children:[(0,s.jsx)(n.strong,{children:"00:31:02"})," - Description of adapters and their function in database interactions"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=2042",children:[(0,s.jsx)(n.strong,{children:"00:34:02"})," - Discussion about plugins as bundles of core components, examples, and recommendations"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=2431",children:[(0,s.jsx)(n.strong,{children:"00:40:31"})," - Live Coding Demo begins: Creating a new plugin from scratch (DevSchoolExamplePlugin)"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=2791",children:[(0,s.jsx)(n.strong,{children:"00:47:54"})," - Implementing the simple HelloWorldAction"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=3626",children:[(0,s.jsx)(n.strong,{children:"01:00:26"})," - Implementing the CurrentNewsAction (fetching and formatting news data)"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=4929",children:[(0,s.jsx)(n.strong,{children:"01:22:09"})," - Demonstrating the Eliza Client for interacting with agents locally"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=5034",children:[(0,s.jsx)(n.strong,{children:"01:23:54"})," - Q&A: Plugin usage in character files, installation, Eliza vs. Eliza Starter"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=5777",children:[(0,s.jsx)(n.strong,{children:"01:36:17"})," - Saving agent responses as memories in the database"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=6186",children:[(0,s.jsx)(n.strong,{children:"01:43:06"})," - Using prompts for data extraction within actions"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=6714",children:[(0,s.jsx)(n.strong,{children:"01:51:54"})," - Importance of deleting the database during development to avoid context issues"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=7024",children:[(0,s.jsx)(n.strong,{children:"01:57:04"})," - Viewing agent context via console logs to understand model inputs"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=7627",children:[(0,s.jsx)(n.strong,{children:"02:07:07"})," - Explanation of memory management with knowledge, facts, and lore"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=8213",children:[(0,s.jsx)(n.strong,{children:"02:16:53"})," - Q&A: Prompt engineering opportunities, knowledge chunking and retrieval"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=8577",children:[(0,s.jsx)(n.strong,{children:"02:22:57"})," - Call for contributions: Encouraging viewers to create their own actions and plugins"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=XenGeAcPAQo&t=8791",children:[(0,s.jsx)(n.strong,{children:"02:26:31"})," - Closing remarks and future DevSchool session announcements"]})}),"\n"]}),"\n",(0,s.jsx)(n.h1,{id:"working-with-actions",children:"Working with Actions"}),"\n",(0,s.jsx)(n.p,{children:"Actions represent the core capabilities of an AI agent - the things it can actually do. In Eliza, an action is defined by:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Name"}),": The unique name used to reference the action"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description"}),": Used to inform the agent when this action should be invoked"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handler"}),": The code that actually executes the action logic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validator"}),": Determines if the action is valid to be called given the current context"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Some key points about actions in Eliza:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The agent decides which action to call based on the name and description. It does not have insight into the actual action code."}),"\n",(0,s.jsx)(n.li,{children:"The handler receives the agent runtime, the triggering message, the current state, and a callback function to send messages back to the user."}),"\n",(0,s.jsx)(n.li,{children:"The validate function allows for complex logic to determine action availability based on context and state."}),"\n"]}),"\n",(0,s.jsx)(n.h1,{id:"providers-injecting-state-and-context",children:"Providers: Injecting State and Context"}),"\n",(0,s.jsx)(n.p,{children:"Providers allow developers to dynamically inject relevant information into the agent's context. This could be real-time data, user information, results of previous conversations, or any other state the agent may need."}),"\n",(0,s.jsx)(n.p,{children:"Key aspects of providers:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Defined by a single ",(0,s.jsx)(n.code,{children:"get"})," function that returns relevant state"]}),"\n",(0,s.jsx)(n.li,{children:"Called before each agent execution to hydrate the context"}),"\n",(0,s.jsx)(n.li,{children:"Can conditionally provide state based on the current context"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Common provider examples include current time, user preferences, conversation history, and external API data."}),"\n",(0,s.jsx)(n.h1,{id:"evaluators-reflection-and-analysis",children:"Evaluators: Reflection and Analysis"}),"\n",(0,s.jsx)(n.p,{children:"Evaluators run after each agent action, allowing the agent to reflect on what happened and potentially trigger additional actions. They are a key component in creating agents that can learn and adapt."}),"\n",(0,s.jsx)(n.p,{children:"Some common use cases for evaluators:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Extracting and storing facts from a conversation for future reference"}),"\n",(0,s.jsx)(n.li,{children:"Analyzing user sentiment to measure trust and relationship"}),"\n",(0,s.jsx)(n.li,{children:"Identifying key intents and entities to inform future actions"}),"\n",(0,s.jsx)(n.li,{children:"Implementing feedback loops for agent improvement"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Evaluators work in close conjunction with providers - often an evaluator will extract some insight that a provider will then inject into future context."}),"\n",(0,s.jsx)(n.h1,{id:"packaging-plugins",children:"Packaging Plugins"}),"\n",(0,s.jsx)(n.p,{children:"The plugin system in Eliza allows developers to package up related actions, providers and evaluators into reusable modules. A plugin is defined by:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"package.json"}),": Metadata about the plugin"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tsconfig.json"}),": TypeScript configuration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"index.ts"}),": Registers the plugin's actions, providers and evaluators"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"src"})," directory: Contains the actual action, provider and evaluator code"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Plugins can be published to npm and then easily imported into any Eliza agent. This enables a powerful ecosystem of reusable agent capabilities."}),"\n",(0,s.jsx)(n.h1,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.p,{children:"The session walks through several code examples to illustrate these concepts:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'Defining a simple "Hello World" action'}),"\n",(0,s.jsx)(n.li,{children:'Creating a "Current News" action that retrieves news headlines'}),"\n",(0,s.jsx)(n.li,{children:"Implementing a provider that injects a random emotion into the context"}),"\n",(0,s.jsx)(n.li,{children:"Registering actions and providers in a plugin"}),"\n"]}),"\n",(0,s.jsx)(n.h1,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Actions, providers and evaluators are the core building blocks of agent behavior in Eliza"}),"\n",(0,s.jsx)(n.li,{children:"Actions define what agents can do, providers manage context and state, and evaluators allow for reflection and adaptation"}),"\n",(0,s.jsx)(n.li,{children:"The plugin system enables reusable packaging of agent capabilities"}),"\n",(0,s.jsx)(n.li,{children:"Effective prompt engineering around the composition of the agent context is a key area for optimization"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"With a solid understanding of these abstractions, developers have immense power and flexibility to create agent behaviors in Eliza. The next session will dive into an end-to-end example."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(14041);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);