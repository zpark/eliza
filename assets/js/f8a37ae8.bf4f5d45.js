"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[44770],{71184:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var t=i(14041);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},88185:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"technical/integrations/discord-technical","title":"Discord Technical Integration","description":"Complete technical guide for integrating ElizaOS with Discord, including advanced features, event handling, and custom implementations.","source":"@site/docs/technical/integrations/discord-technical.md","sourceDirName":"technical/integrations","slug":"/technical/integrations/discord-technical","permalink":"/docs/technical/integrations/discord-technical","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/technical/integrations/discord-technical.md","tags":[],"version":"current","lastUpdatedBy":"Sayo","lastUpdatedAt":1751802400000,"frontMatter":{},"sidebar":"technicalSidebar","previous":{"title":"\ud83d\udd27 Plugin Development","permalink":"/docs/technical/development/plugin-development"},"next":{"title":"\ud83d\udcf1 Telegram Technical Integration","permalink":"/docs/technical/integrations/telegram-technical"}}');var s=i(31085),r=i(71184);const a={},c="Discord Technical Integration",o={},l=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Discord Service Architecture",id:"discord-service-architecture",level:3},{value:"Event Flow",id:"event-flow",level:3},{value:"Implementation Guide",id:"implementation-guide",level:2},{value:"1. Service Registration",id:"1-service-registration",level:3},{value:"2. Custom Event Handlers",id:"2-custom-event-handlers",level:3},{value:"3. Voice Integration",id:"3-voice-integration",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"1. Slash Commands Implementation",id:"1-slash-commands-implementation",level:3},{value:"2. Embed Builders",id:"2-embed-builders",level:3},{value:"3. Reaction Handlers",id:"3-reaction-handlers",level:3},{value:"Permission Management",id:"permission-management",level:2},{value:"1. Role-Based Access Control",id:"1-role-based-access-control",level:3},{value:"2. Command Restrictions",id:"2-command-restrictions",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"1. Message Caching",id:"1-message-caching",level:3},{value:"2. Rate Limiting",id:"2-rate-limiting",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"1. Comprehensive Error Management",id:"1-comprehensive-error-management",level:3},{value:"2. Graceful Degradation",id:"2-graceful-degradation",level:3},{value:"Testing Strategies",id:"testing-strategies",level:2},{value:"1. Unit Testing",id:"1-unit-testing",level:3},{value:"2. Integration Testing",id:"2-integration-testing",level:3},{value:"Deployment Considerations",id:"deployment-considerations",level:2},{value:"1. Environment Configuration",id:"1-environment-configuration",level:3},{value:"2. Scaling Strategies",id:"2-scaling-strategies",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Security",id:"1-security",level:3},{value:"2. Performance",id:"2-performance",level:3},{value:"3. User Experience",id:"3-user-experience",level:3},{value:"Resources",id:"resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"discord-technical-integration",children:"Discord Technical Integration"})}),"\n",(0,s.jsx)(n.p,{children:"Complete technical guide for integrating ElizaOS with Discord, including advanced features, event handling, and custom implementations."}),"\n",(0,s.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,s.jsx)(n.h3,{id:"discord-service-architecture",children:"Discord Service Architecture"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface DiscordService extends Service {\n  client: Client;\n  voiceManager: VoiceManager;\n  messageHandler: MessageHandler;\n  eventEmitter: EventEmitter;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"event-flow",children:"Event Flow"}),"\n",(0,s.jsx)(n.mermaid,{value:"graph LR\n    A[Discord API] --\x3e B[Discord.js Client]\n    B --\x3e C[ElizaOS Service]\n    C --\x3e D[Message Handler]\n    D --\x3e E[Agent Runtime]\n    E --\x3e F[Response]\n    F --\x3e B\n    B --\x3e A"}),"\n",(0,s.jsx)(n.h2,{id:"implementation-guide",children:"Implementation Guide"}),"\n",(0,s.jsx)(n.h3,{id:"1-service-registration",children:"1. Service Registration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { DiscordService } from '@elizaos/plugin-discord';\n\n// Register the Discord service\nruntime.registerService(\n  new DiscordService({\n    botToken: process.env.DISCORD_API_TOKEN,\n    applicationId: process.env.DISCORD_APPLICATION_ID,\n    intents: [\n      GatewayIntentBits.Guilds,\n      GatewayIntentBits.GuildMessages,\n      GatewayIntentBits.MessageContent,\n      GatewayIntentBits.GuildVoiceStates,\n    ],\n  })\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-custom-event-handlers",children:"2. Custom Event Handlers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Custom message handler\nclass CustomDiscordHandler extends MessageHandler {\n  async handleMessage(message: Message): Promise<void> {\n    // Pre-processing\n    if (message.author.bot) return;\n\n    // Custom logic\n    const context = await this.buildContext(message);\n    const response = await this.runtime.process(context);\n\n    // Post-processing\n    await this.sendResponse(message, response);\n  }\n\n  private async buildContext(message: Message): Promise<Context> {\n    return {\n      userId: message.author.id,\n      roomId: message.channelId,\n      worldId: message.guildId,\n      content: message.content,\n      attachments: message.attachments.map((a) => ({\n        url: a.url,\n        type: a.contentType,\n      })),\n    };\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-voice-integration",children:"3. Voice Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Voice connection manager\nclass VoiceManager {\n  private connections: Map<string, VoiceConnection> = new Map();\n\n  async joinChannel(channelId: string): Promise<VoiceConnection> {\n    const channel = await this.client.channels.fetch(channelId);\n    if (!channel.isVoiceBased()) {\n      throw new Error('Not a voice channel');\n    }\n\n    const connection = joinVoiceChannel({\n      channelId: channel.id,\n      guildId: channel.guild.id,\n      adapterCreator: channel.guild.voiceAdapterCreator,\n    });\n\n    this.connections.set(channelId, connection);\n    return connection;\n  }\n\n  async playAudio(channelId: string, audioUrl: string): Promise<void> {\n    const connection = this.connections.get(channelId);\n    if (!connection) throw new Error('Not connected to channel');\n\n    const player = createAudioPlayer();\n    const resource = createAudioResource(audioUrl);\n\n    player.play(resource);\n    connection.subscribe(player);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,s.jsx)(n.h3,{id:"1-slash-commands-implementation",children:"1. Slash Commands Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Command registration\nconst commands = [\n  {\n    name: 'ask',\n    description: 'Ask the AI a question',\n    options: [\n      {\n        name: 'question',\n        type: ApplicationCommandOptionType.String,\n        description: 'Your question',\n        required: true,\n      },\n    ],\n  },\n  {\n    name: 'imagine',\n    description: 'Generate an image',\n    options: [\n      {\n        name: 'prompt',\n        type: ApplicationCommandOptionType.String,\n        description: 'Image description',\n        required: true,\n      },\n    ],\n  },\n];\n\n// Command handler\nclient.on('interactionCreate', async (interaction) => {\n  if (!interaction.isChatInputCommand()) return;\n\n  switch (interaction.commandName) {\n    case 'ask':\n      await handleAskCommand(interaction);\n      break;\n    case 'imagine':\n      await handleImagineCommand(interaction);\n      break;\n  }\n});\n\nasync function handleAskCommand(interaction: ChatInputCommandInteraction) {\n  await interaction.deferReply();\n\n  const question = interaction.options.getString('question');\n  const response = await runtime.process({\n    content: question,\n    userId: interaction.user.id,\n    roomId: interaction.channelId,\n  });\n\n  await interaction.editReply(response.text);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-embed-builders",children:"2. Embed Builders"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Rich embed responses\nfunction createRichEmbed(data: any): EmbedBuilder {\n  return new EmbedBuilder()\n    .setTitle(data.title)\n    .setDescription(data.description)\n    .setColor(0x0099ff)\n    .addFields(\n      { name: 'Status', value: data.status, inline: true },\n      { name: 'Time', value: new Date().toISOString(), inline: true }\n    )\n    .setFooter({ text: 'Powered by ElizaOS' })\n    .setTimestamp();\n}\n\n// Usage in response\nconst embed = createRichEmbed({\n  title: 'Analysis Complete',\n  description: 'Here are the results...',\n  status: 'Success',\n});\n\nawait message.channel.send({ embeds: [embed] });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-reaction-handlers",children:"3. Reaction Handlers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Reaction-based interactions\nclient.on('messageReactionAdd', async (reaction, user) => {\n  if (user.bot) return;\n\n  // Handle specific reactions\n  switch (reaction.emoji.name) {\n    case '\ud83d\udc4d':\n      await handlePositiveFeedback(reaction.message, user);\n      break;\n    case '\ud83d\udc4e':\n      await handleNegativeFeedback(reaction.message, user);\n      break;\n    case '\ud83d\udd04':\n      await regenerateResponse(reaction.message, user);\n      break;\n  }\n});\n\nasync function regenerateResponse(message: Message, user: User) {\n  // Get original context\n  const context = await getMessageContext(message.id);\n\n  // Generate new response\n  const newResponse = await runtime.process({\n    ...context,\n    regenerate: true,\n  });\n\n  // Update message\n  await message.edit(newResponse.text);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"permission-management",children:"Permission Management"}),"\n",(0,s.jsx)(n.h3,{id:"1-role-based-access-control",children:"1. Role-Based Access Control"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Permission checker\nclass PermissionManager {\n  private roleHierarchy: Map<string, number> = new Map([\n    ['admin', 100],\n    ['moderator', 50],\n    ['member', 10],\n    ['guest', 0],\n  ]);\n\n  async checkPermission(userId: string, guildId: string, requiredLevel: number): Promise<boolean> {\n    const member = await this.getMember(guildId, userId);\n    const userLevel = this.getUserLevel(member);\n\n    return userLevel >= requiredLevel;\n  }\n\n  private getUserLevel(member: GuildMember): number {\n    let maxLevel = 0;\n\n    member.roles.cache.forEach((role) => {\n      const level = this.roleHierarchy.get(role.name.toLowerCase());\n      if (level && level > maxLevel) {\n        maxLevel = level;\n      }\n    });\n\n    return maxLevel;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-command-restrictions",children:"2. Command Restrictions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Restricted command example\nconst restrictedCommands = {\n  admin: ['shutdown', 'config', 'reset'],\n  moderator: ['mute', 'kick', 'warn'],\n  member: ['help', 'info', 'stats'],\n};\n\nasync function executeCommand(command: string, user: User, guild: Guild): Promise<void> {\n  const permission = await permissionManager.getUserRole(user.id, guild.id);\n\n  const allowedCommands = Object.entries(restrictedCommands)\n    .filter(([role, _]) => permission.includes(role))\n    .flatMap(([_, commands]) => commands);\n\n  if (!allowedCommands.includes(command)) {\n    throw new Error('Insufficient permissions');\n  }\n\n  // Execute command\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"1-message-caching",children:"1. Message Caching"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// LRU cache for messages\nclass MessageCache {\n  private cache: LRUCache<string, ProcessedMessage>;\n\n  constructor(maxSize: number = 1000) {\n    this.cache = new LRUCache({ max: maxSize });\n  }\n\n  async get(messageId: string): Promise<ProcessedMessage | null> {\n    return this.cache.get(messageId) || null;\n  }\n\n  async set(messageId: string, data: ProcessedMessage): Promise<void> {\n    this.cache.set(messageId, data);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-rate-limiting",children:"2. Rate Limiting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Rate limiter implementation\nclass RateLimiter {\n  private limits: Map<string, number[]> = new Map();\n\n  constructor(\n    private maxRequests: number = 5,\n    private windowMs: number = 60000\n  ) {}\n\n  async checkLimit(userId: string): Promise<boolean> {\n    const now = Date.now();\n    const userLimits = this.limits.get(userId) || [];\n\n    // Remove old entries\n    const recent = userLimits.filter((time) => now - time < this.windowMs);\n\n    if (recent.length >= this.maxRequests) {\n      return false;\n    }\n\n    recent.push(now);\n    this.limits.set(userId, recent);\n    return true;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"1-comprehensive-error-management",children:"1. Comprehensive Error Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Error handler\nclass DiscordErrorHandler {\n  async handle(error: Error, context: ErrorContext): Promise<void> {\n    console.error(`Discord Error: ${error.message}`, context);\n\n    // Notify user\n    if (context.channel) {\n      await context.channel.send({\n        content: 'An error occurred. Please try again later.',\n        ephemeral: true,\n      });\n    }\n\n    // Log to monitoring\n    await this.logToMonitoring(error, context);\n\n    // Attempt recovery\n    if (error.code === 'CONNECTION_LOST') {\n      await this.reconnect();\n    }\n  }\n\n  private async reconnect(): Promise<void> {\n    // Implement reconnection logic\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-graceful-degradation",children:"2. Graceful Degradation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Fallback mechanisms\nasync function sendMessage(channel: TextChannel, content: string): Promise<void> {\n  try {\n    // Try rich embed\n    const embed = createRichEmbed(content);\n    await channel.send({ embeds: [embed] });\n  } catch (embedError) {\n    try {\n      // Fallback to plain text\n      await channel.send(content);\n    } catch (textError) {\n      // Log failure\n      console.error('Failed to send message', textError);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"1-unit-testing",children:"1. Unit Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Test Discord service\ndescribe('DiscordService', () => {\n  let service: DiscordService;\n  let mockClient: jest.Mocked<Client>;\n\n  beforeEach(() => {\n    mockClient = createMockClient();\n    service = new DiscordService({ client: mockClient });\n  });\n\n  test('handles message correctly', async () => {\n    const mockMessage = createMockMessage({\n      content: 'Hello bot',\n      author: { bot: false },\n    });\n\n    await service.handleMessage(mockMessage);\n\n    expect(mockClient.channels.send).toHaveBeenCalledWith(\n      expect.objectContaining({\n        content: expect.stringContaining('Hello'),\n      })\n    );\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-integration-testing",children:"2. Integration Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Test full flow\ndescribe('Discord Integration', () => {\n  test('processes command end-to-end', async () => {\n    const response = await sendCommand('/ask What is ElizaOS?');\n\n    expect(response).toMatchObject({\n      success: true,\n      reply: expect.stringContaining('ElizaOS'),\n    });\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"deployment-considerations",children:"Deployment Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"1-environment-configuration",children:"1. Environment Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-env",children:"# Required\nDISCORD_APPLICATION_ID=123456789012345678\nDISCORD_API_TOKEN=Bot.Token.Here\nDISCORD_PUBLIC_KEY=public_key_for_interactions\n\n# Optional\nDISCORD_GUILD_ID=specific_guild_id\nDISCORD_LOG_CHANNEL=logs_channel_id\nDISCORD_ERROR_WEBHOOK=webhook_url\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-scaling-strategies",children:"2. Scaling Strategies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Sharding for large bots\nconst manager = new ShardingManager('./bot.js', {\n  token: process.env.DISCORD_API_TOKEN,\n  totalShards: 'auto',\n});\n\nmanager.on('shardCreate', (shard) => {\n  console.log(`Launched shard ${shard.id}`);\n});\n\nmanager.spawn();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-security",children:"1. Security"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Never expose bot tokens"}),"\n",(0,s.jsx)(n.li,{children:"Validate all user inputs"}),"\n",(0,s.jsx)(n.li,{children:"Implement proper rate limiting"}),"\n",(0,s.jsx)(n.li,{children:"Use environment variables"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-performance",children:"2. Performance"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cache frequently accessed data"}),"\n",(0,s.jsx)(n.li,{children:"Use bulk operations when possible"}),"\n",(0,s.jsx)(n.li,{children:"Implement connection pooling"}),"\n",(0,s.jsx)(n.li,{children:"Monitor memory usage"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-user-experience",children:"3. User Experience"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provide clear error messages"}),"\n",(0,s.jsx)(n.li,{children:"Use typing indicators for long operations"}),"\n",(0,s.jsx)(n.li,{children:"Implement command help system"}),"\n",(0,s.jsx)(n.li,{children:"Support multiple languages"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://discord.js.org/",children:"Discord.js Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://discord.com/developers",children:"Discord Developer Portal"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/elizaOS/eliza/tree/main/packages/plugin-discord",children:"ElizaOS Discord Plugin Source"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Next:"})," ",(0,s.jsx)(n.a,{href:"./telegram-technical",children:"Telegram Technical Integration \u2192"})]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);