"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[403],{69839:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"plugins/migration/claude-code/testing-guide","title":"ElizaOS Plugin Testing Guide","description":"This guide provides comprehensive instructions for writing tests for ElizaOS plugins using Bun\'s test runner.","source":"@site/docs/plugins/migration/claude-code/testing-guide.md","sourceDirName":"plugins/migration/claude-code","slug":"/plugins/migration/claude-code/testing-guide","permalink":"/docs/plugins/migration/claude-code/testing-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/plugins/migration/claude-code/testing-guide.md","tags":[],"version":"current","lastUpdatedBy":"0xbbjoker","lastUpdatedAt":1751365903000,"frontMatter":{}}');var a=t(31085),i=t(71184);const o={},c="ElizaOS Plugin Testing Guide",r={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"1. Test Environment Setup",id:"1-test-environment-setup",level:2},{value:"Directory Structure",id:"directory-structure",level:3},{value:"Required Dependencies",id:"required-dependencies",level:3},{value:"Base Test Imports",id:"base-test-imports",level:3},{value:"2. Creating Test Utilities",id:"2-creating-test-utilities",level:2},{value:"3. Testing Actions",id:"3-testing-actions",level:2},{value:"Basic Action Test Structure",id:"basic-action-test-structure",level:3},{value:"Testing Async Actions",id:"testing-async-actions",level:3},{value:"4. Testing Providers",id:"4-testing-providers",level:2},{value:"5. Testing Evaluators",id:"5-testing-evaluators",level:2},{value:"6. Testing Services",id:"6-testing-services",level:2},{value:"7. Testing Event Handlers",id:"7-testing-event-handlers",level:2},{value:"8. Advanced Testing Patterns",id:"8-advanced-testing-patterns",level:2},{value:"Testing with Complex State",id:"testing-with-complex-state",level:3},{value:"Testing with Multiple Mock Responses",id:"testing-with-multiple-mock-responses",level:3},{value:"Testing Error Recovery",id:"testing-error-recovery",level:3},{value:"9. Best Practices",id:"9-best-practices",level:2},{value:"1. Test Organization",id:"1-test-organization",level:3},{value:"2. Mock Management",id:"2-mock-management",level:3},{value:"3. Assertion Patterns",id:"3-assertion-patterns",level:3},{value:"4. Testing Edge Cases",id:"4-testing-edge-cases",level:3},{value:"5. Async Testing Best Practices",id:"5-async-testing-best-practices",level:3},{value:"6. Cleanup",id:"6-cleanup",level:3},{value:"7. Test Coverage Requirements",id:"7-test-coverage-requirements",level:3},{value:"10. Running Tests",id:"10-running-tests",level:2},{value:"Basic Commands",id:"basic-commands",level:3},{value:"Test Configuration",id:"test-configuration",level:3},{value:"Debugging Tests",id:"debugging-tests",level:3},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Issue: Mock not being called",id:"issue-mock-not-being-called",level:4},{value:"Issue: Tests timing out",id:"issue-tests-timing-out",level:4},{value:"Issue: Inconsistent test results",id:"issue-inconsistent-test-results",level:4},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"elizaos-plugin-testing-guide",children:"ElizaOS Plugin Testing Guide"})}),"\n",(0,a.jsx)(n.p,{children:"This guide provides comprehensive instructions for writing tests for ElizaOS plugins using Bun's test runner."}),"\n",(0,a.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#1-test-environment-setup",children:"Test Environment Setup"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#2-creating-test-utilities",children:"Creating Test Utilities"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#3-testing-actions",children:"Testing Actions"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#4-testing-providers",children:"Testing Providers"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#5-testing-evaluators",children:"Testing Evaluators"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#6-testing-services",children:"Testing Services"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#7-testing-event-handlers",children:"Testing Event Handlers"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#8-advanced-testing-patterns",children:"Advanced Testing Patterns"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#9-best-practices",children:"Best Practices"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#10-running-tests",children:"Running Tests"})}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"1-test-environment-setup",children:"1. Test Environment Setup"}),"\n",(0,a.jsx)(n.h3,{id:"directory-structure",children:"Directory Structure"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"src/\n  __tests__/\n    test-utils.ts         # Shared test utilities and mocks\n    index.test.ts         # Main plugin tests\n    actions.test.ts       # Action tests\n    providers.test.ts     # Provider tests\n    evaluators.test.ts    # Evaluator tests\n    services.test.ts      # Service tests\n  actions/\n  providers/\n  evaluators/\n  services/\n  index.ts\n"})}),"\n",(0,a.jsx)(n.h3,{id:"required-dependencies",children:"Required Dependencies"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "devDependencies": {\n    "@types/bun": "latest",\n    "bun-types": "latest"\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"base-test-imports",children:"Base Test Imports"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { describe, expect, it, mock, beforeEach, afterEach, spyOn } from 'bun:test';\nimport {\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  type Action,\n  type Provider,\n  type Evaluator,\n  ModelType,\n  logger,\n} from '@elizaos/core';\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"2-creating-test-utilities",children:"2. Creating Test Utilities"}),"\n",(0,a.jsxs)(n.p,{children:["Create a comprehensive ",(0,a.jsx)(n.code,{children:"test-utils.ts"})," file with reusable mock objects and helper functions:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { mock } from 'bun:test';\nimport {\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type Character,\n  type UUID,\n  type Content,\n  type Room,\n  type Entity,\n  ChannelType,\n} from '@elizaos/core';\n\n// Mock Runtime Type\nexport type MockRuntime = Partial<IAgentRuntime> & {\n  agentId: UUID;\n  character: Character;\n  getSetting: ReturnType<typeof mock>;\n  useModel: ReturnType<typeof mock>;\n  composeState: ReturnType<typeof mock>;\n  createMemory: ReturnType<typeof mock>;\n  getMemories: ReturnType<typeof mock>;\n  searchMemories: ReturnType<typeof mock>;\n  updateMemory: ReturnType<typeof mock>;\n  getRoom: ReturnType<typeof mock>;\n  getParticipantUserState: ReturnType<typeof mock>;\n  setParticipantUserState: ReturnType<typeof mock>;\n  emitEvent: ReturnType<typeof mock>;\n  getTasks: ReturnType<typeof mock>;\n  providers: any[];\n  actions: any[];\n  evaluators: any[];\n  services: any[];\n};\n\n// Create Mock Runtime\nexport function createMockRuntime(overrides: Partial<MockRuntime> = {}): MockRuntime {\n  return {\n    agentId: 'test-agent-id' as UUID,\n    character: {\n      name: 'Test Agent',\n      bio: 'A test agent for unit testing',\n      templates: {\n        messageHandlerTemplate: 'Test template {{recentMessages}}',\n        shouldRespondTemplate: 'Should respond {{recentMessages}}',\n      },\n    } as Character,\n\n    // Core methods with default implementations\n    useModel: mock().mockResolvedValue('Mock response'),\n    composeState: mock().mockResolvedValue({\n      values: {\n        agentName: 'Test Agent',\n        recentMessages: 'Test message',\n      },\n      data: {\n        room: {\n          id: 'test-room-id',\n          type: ChannelType.DIRECT,\n        },\n      },\n    }),\n    createMemory: mock().mockResolvedValue({ id: 'memory-id' }),\n    getMemories: mock().mockResolvedValue([]),\n    searchMemories: mock().mockResolvedValue([]),\n    updateMemory: mock().mockResolvedValue(undefined),\n    getSetting: mock().mockImplementation((key: string) => {\n      const settings: Record<string, string> = {\n        TEST_SETTING: 'test-value',\n        API_KEY: 'test-api-key',\n        // Add common settings your plugin might need\n      };\n      return settings[key];\n    }),\n    getRoom: mock().mockResolvedValue({\n      id: 'test-room-id',\n      type: ChannelType.DIRECT,\n      worldId: 'test-world-id',\n      serverId: 'test-server-id',\n      source: 'test',\n    }),\n    getParticipantUserState: mock().mockResolvedValue('ACTIVE'),\n    setParticipantUserState: mock().mockResolvedValue(undefined),\n    emitEvent: mock().mockResolvedValue(undefined),\n    getTasks: mock().mockResolvedValue([]),\n\n    // Provider/action/evaluator lists\n    providers: [],\n    actions: [],\n    evaluators: [],\n    services: [],\n\n    // Override with custom implementations\n    ...overrides,\n  };\n}\n\n// Create Mock Memory\nexport function createMockMemory(overrides: Partial<Memory> = {}): Partial<Memory> {\n  return {\n    id: 'test-message-id' as UUID,\n    roomId: 'test-room-id' as UUID,\n    entityId: 'test-entity-id' as UUID,\n    agentId: 'test-agent-id' as UUID,\n    content: {\n      text: 'Test message',\n      channelType: ChannelType.DIRECT,\n      source: 'direct',\n    } as Content,\n    createdAt: Date.now(),\n    userId: 'test-user-id' as UUID,\n    ...overrides,\n  };\n}\n\n// Create Mock State\nexport function createMockState(overrides: Partial<State> = {}): Partial<State> {\n  return {\n    values: {\n      agentName: 'Test Agent',\n      recentMessages: 'User: Test message',\n      ...overrides.values,\n    },\n    data: {\n      room: {\n        id: 'test-room-id',\n        type: ChannelType.DIRECT,\n      },\n      ...overrides.data,\n    },\n    ...overrides,\n  };\n}\n\n// Setup Action Test Helper\nexport function setupActionTest(\n  options: {\n    runtimeOverrides?: Partial<MockRuntime>;\n    messageOverrides?: Partial<Memory>;\n    stateOverrides?: Partial<State>;\n  } = {}\n) {\n  const mockRuntime = createMockRuntime(options.runtimeOverrides);\n  const mockMessage = createMockMemory(options.messageOverrides);\n  const mockState = createMockState(options.stateOverrides);\n  const callbackFn = mock().mockResolvedValue([]);\n\n  return {\n    mockRuntime,\n    mockMessage,\n    mockState,\n    callbackFn,\n  };\n}\n\n// Mock Logger Helper\nexport function mockLogger() {\n  spyOn(logger, 'error').mockImplementation(() => {});\n  spyOn(logger, 'warn').mockImplementation(() => {});\n  spyOn(logger, 'info').mockImplementation(() => {});\n  spyOn(logger, 'debug').mockImplementation(() => {});\n}\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"3-testing-actions",children:"3. Testing Actions"}),"\n",(0,a.jsx)(n.h3,{id:"basic-action-test-structure",children:"Basic Action Test Structure"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// src/__tests__/actions.test.ts\nimport { describe, expect, it, mock, beforeEach, afterEach } from 'bun:test';\nimport { myAction } from '../actions/myAction';\nimport { setupActionTest, mockLogger } from './test-utils';\nimport type { MockRuntime } from './test-utils';\nimport {\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  ModelType,\n} from '@elizaos/core';\n\ndescribe('My Action', () => {\n  let mockRuntime: MockRuntime;\n  let mockMessage: Partial<Memory>;\n  let mockState: Partial<State>;\n  let callbackFn: HandlerCallback;\n\n  beforeEach(() => {\n    mockLogger();\n    const setup = setupActionTest();\n    mockRuntime = setup.mockRuntime;\n    mockMessage = setup.mockMessage;\n    mockState = setup.mockState;\n    callbackFn = setup.callbackFn as HandlerCallback;\n  });\n\n  afterEach(() => {\n    mock.restore();\n  });\n\n  describe('validation', () => {\n    it('should validate when conditions are met', async () => {\n      // Setup message content that should validate\n      mockMessage.content = {\n        text: 'perform action',\n        channelType: 'direct',\n      };\n\n      const isValid = await myAction.validate(\n        mockRuntime as IAgentRuntime,\n        mockMessage as Memory,\n        mockState as State\n      );\n\n      expect(isValid).toBe(true);\n    });\n\n    it('should not validate when conditions are not met', async () => {\n      // Setup message content that should not validate\n      mockMessage.content = {\n        text: 'unrelated message',\n        channelType: 'direct',\n      };\n\n      const isValid = await myAction.validate(\n        mockRuntime as IAgentRuntime,\n        mockMessage as Memory,\n        mockState as State\n      );\n\n      expect(isValid).toBe(false);\n    });\n  });\n\n  describe('handler', () => {\n    it('should handle action successfully', async () => {\n      // Mock runtime methods specific to this action\n      mockRuntime.useModel = mock().mockResolvedValue({\n        action: 'PERFORM',\n        parameters: { value: 'test' },\n      });\n\n      const result = await myAction.handler(\n        mockRuntime as IAgentRuntime,\n        mockMessage as Memory,\n        mockState as State,\n        {},\n        callbackFn\n      );\n\n      expect(result).toBe(true);\n      expect(callbackFn).toHaveBeenCalledWith(\n        expect.objectContaining({\n          text: expect.any(String),\n          content: expect.any(Object),\n        })\n      );\n    });\n\n    it('should handle errors gracefully', async () => {\n      // Mock an error scenario\n      mockRuntime.useModel = mock().mockRejectedValue(new Error('Model error'));\n\n      await myAction.handler(\n        mockRuntime as IAgentRuntime,\n        mockMessage as Memory,\n        mockState as State,\n        {},\n        callbackFn\n      );\n\n      expect(callbackFn).toHaveBeenCalledWith(\n        expect.objectContaining({\n          text: expect.stringContaining('error'),\n        })\n      );\n    });\n  });\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"testing-async-actions",children:"Testing Async Actions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"describe('Async Action', () => {\n  it('should handle async operations', async () => {\n    const setup = setupActionTest({\n      runtimeOverrides: {\n        useModel: mock().mockImplementation(async (modelType) => {\n          // Simulate async delay\n          await new Promise((resolve) => setTimeout(resolve, 100));\n          return { result: 'async result' };\n        }),\n      },\n    });\n\n    const result = await asyncAction.handler(\n      setup.mockRuntime as IAgentRuntime,\n      setup.mockMessage as Memory,\n      setup.mockState as State,\n      {},\n      setup.callbackFn as HandlerCallback\n    );\n\n    expect(result).toBe(true);\n    expect(setup.callbackFn).toHaveBeenCalled();\n  });\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"4-testing-providers",children:"4. Testing Providers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// src/__tests__/providers.test.ts\nimport { describe, expect, it, mock, beforeEach, afterEach } from 'bun:test';\nimport { myProvider } from '../providers/myProvider';\nimport { createMockRuntime, createMockMemory, createMockState } from './test-utils';\nimport { type IAgentRuntime, type Memory, type State } from '@elizaos/core';\n\ndescribe('My Provider', () => {\n  let mockRuntime: any;\n  let mockMessage: Partial<Memory>;\n  let mockState: Partial<State>;\n\n  beforeEach(() => {\n    mockRuntime = createMockRuntime();\n    mockMessage = createMockMemory();\n    mockState = createMockState();\n  });\n\n  afterEach(() => {\n    mock.restore();\n  });\n\n  it('should have required properties', () => {\n    expect(myProvider.name).toBe('MY_PROVIDER');\n    expect(myProvider.get).toBeDefined();\n    expect(typeof myProvider.get).toBe('function');\n  });\n\n  it('should return data in correct format', async () => {\n    // Mock any runtime methods the provider uses\n    mockRuntime.getMemories = mock().mockResolvedValue([\n      { content: { text: 'Memory 1' }, createdAt: Date.now() },\n      { content: { text: 'Memory 2' }, createdAt: Date.now() - 1000 },\n    ]);\n\n    const result = await myProvider.get(\n      mockRuntime as IAgentRuntime,\n      mockMessage as Memory,\n      mockState as State\n    );\n\n    expect(result).toMatchObject({\n      text: expect.any(String),\n      data: expect.any(Object),\n    });\n  });\n\n  it('should handle empty data gracefully', async () => {\n    mockRuntime.getMemories = mock().mockResolvedValue([]);\n\n    const result = await myProvider.get(\n      mockRuntime as IAgentRuntime,\n      mockMessage as Memory,\n      mockState as State\n    );\n\n    expect(result).toBeDefined();\n    expect(result.text).toContain('No data available');\n  });\n\n  it('should handle errors gracefully', async () => {\n    mockRuntime.getMemories = mock().mockRejectedValue(new Error('Database error'));\n\n    const result = await myProvider.get(\n      mockRuntime as IAgentRuntime,\n      mockMessage as Memory,\n      mockState as State\n    );\n\n    expect(result).toBeDefined();\n    expect(result.text).toContain('Error retrieving data');\n  });\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"5-testing-evaluators",children:"5. Testing Evaluators"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// src/__tests__/evaluators.test.ts\nimport { describe, expect, it, mock, beforeEach, afterEach } from 'bun:test';\nimport { myEvaluator } from '../evaluators/myEvaluator';\nimport { createMockRuntime, createMockMemory, createMockState } from './test-utils';\nimport { type IAgentRuntime, type Memory, type State } from '@elizaos/core';\n\ndescribe('My Evaluator', () => {\n  let mockRuntime: any;\n  let mockMessage: Partial<Memory>;\n  let mockState: Partial<State>;\n\n  beforeEach(() => {\n    mockRuntime = createMockRuntime();\n    mockMessage = createMockMemory();\n    mockState = createMockState();\n  });\n\n  afterEach(() => {\n    mock.restore();\n  });\n\n  it('should have required properties', () => {\n    expect(myEvaluator.name).toBe('MY_EVALUATOR');\n    expect(myEvaluator.evaluate).toBeDefined();\n    expect(myEvaluator.validate).toBeDefined();\n  });\n\n  it('should validate when conditions are met', async () => {\n    const isValid = await myEvaluator.validate(\n      mockRuntime as IAgentRuntime,\n      mockMessage as Memory,\n      mockState as State\n    );\n\n    expect(isValid).toBe(true);\n  });\n\n  it('should evaluate and create memory', async () => {\n    mockRuntime.createMemory = mock().mockResolvedValue({ id: 'new-memory-id' });\n\n    await myEvaluator.evaluate(\n      mockRuntime as IAgentRuntime,\n      mockMessage as Memory,\n      mockState as State,\n      {}\n    );\n\n    expect(mockRuntime.createMemory).toHaveBeenCalledWith(\n      expect.objectContaining({\n        content: expect.objectContaining({\n          text: expect.any(String),\n        }),\n      }),\n      expect.any(String) // tableName\n    );\n  });\n\n  it('should not create memory when evaluation fails', async () => {\n    // Mock a scenario where evaluation should fail\n    mockMessage.content = { text: 'invalid content' };\n\n    await myEvaluator.evaluate(\n      mockRuntime as IAgentRuntime,\n      mockMessage as Memory,\n      mockState as State,\n      {}\n    );\n\n    expect(mockRuntime.createMemory).not.toHaveBeenCalled();\n  });\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"6-testing-services",children:"6. Testing Services"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// src/__tests__/services.test.ts\nimport { describe, expect, it, mock, beforeEach, afterEach } from 'bun:test';\nimport { myService } from '../services/myService';\nimport { createMockRuntime } from './test-utils';\nimport { type IAgentRuntime } from '@elizaos/core';\n\ndescribe('My Service', () => {\n  let mockRuntime: any;\n\n  beforeEach(() => {\n    mockRuntime = createMockRuntime();\n  });\n\n  afterEach(() => {\n    mock.restore();\n  });\n\n  it('should initialize service', async () => {\n    const service = await myService.initialize(mockRuntime as IAgentRuntime);\n\n    expect(service).toBeDefined();\n    expect(service.start).toBeDefined();\n    expect(service.stop).toBeDefined();\n  });\n\n  it('should start service successfully', async () => {\n    const service = await myService.initialize(mockRuntime as IAgentRuntime);\n    const startSpy = mock(service.start);\n\n    await service.start();\n\n    expect(startSpy).toHaveBeenCalled();\n  });\n\n  it('should stop service successfully', async () => {\n    const service = await myService.initialize(mockRuntime as IAgentRuntime);\n    await service.start();\n\n    const stopSpy = mock(service.stop);\n    await service.stop();\n\n    expect(stopSpy).toHaveBeenCalled();\n  });\n\n  it('should handle service errors', async () => {\n    const service = await myService.initialize(mockRuntime as IAgentRuntime);\n    service.start = mock().mockRejectedValue(new Error('Service start failed'));\n\n    await expect(service.start()).rejects.toThrow('Service start failed');\n  });\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"7-testing-event-handlers",children:"7. Testing Event Handlers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// src/__tests__/events.test.ts\nimport { describe, expect, it, mock, beforeEach, afterEach } from 'bun:test';\nimport { myPlugin } from '../index';\nimport { setupActionTest } from './test-utils';\nimport {\n  type IAgentRuntime,\n  type Memory,\n  EventType,\n  type MessagePayload,\n  type EntityPayload,\n} from '@elizaos/core';\n\ndescribe('Event Handlers', () => {\n  let mockRuntime: any;\n  let mockMessage: Partial<Memory>;\n  let mockCallback: any;\n\n  beforeEach(() => {\n    const setup = setupActionTest();\n    mockRuntime = setup.mockRuntime;\n    mockMessage = setup.mockMessage;\n    mockCallback = setup.callbackFn;\n  });\n\n  afterEach(() => {\n    mock.restore();\n  });\n\n  it('should handle MESSAGE_RECEIVED event', async () => {\n    const messageHandler = myPlugin.events?.[EventType.MESSAGE_RECEIVED]?.[0];\n    expect(messageHandler).toBeDefined();\n\n    if (messageHandler) {\n      await messageHandler({\n        runtime: mockRuntime as IAgentRuntime,\n        message: mockMessage as Memory,\n        callback: mockCallback,\n        source: 'test',\n      } as MessagePayload);\n\n      expect(mockRuntime.createMemory).toHaveBeenCalledWith(mockMessage, 'messages');\n    }\n  });\n\n  it('should handle ENTITY_JOINED event', async () => {\n    const entityHandler = myPlugin.events?.[EventType.ENTITY_JOINED]?.[0];\n    expect(entityHandler).toBeDefined();\n\n    if (entityHandler) {\n      await entityHandler({\n        runtime: mockRuntime as IAgentRuntime,\n        entityId: 'test-entity-id',\n        worldId: 'test-world-id',\n        roomId: 'test-room-id',\n        metadata: {\n          type: 'user',\n          username: 'testuser',\n        },\n        source: 'test',\n      } as EntityPayload);\n\n      expect(mockRuntime.ensureConnection).toHaveBeenCalled();\n    }\n  });\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"8-advanced-testing-patterns",children:"8. Advanced Testing Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"testing-with-complex-state",children:"Testing with Complex State"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"describe('Complex State Action', () => {\n  it('should handle complex state transformations', async () => {\n    const setup = setupActionTest({\n      stateOverrides: {\n        values: {\n          taskList: ['task1', 'task2'],\n          currentStep: 2,\n          metadata: { key: 'value' },\n        },\n        data: {\n          customData: {\n            nested: {\n              value: 'deep',\n            },\n          },\n        },\n      },\n    });\n\n    const result = await complexAction.handler(\n      setup.mockRuntime as IAgentRuntime,\n      setup.mockMessage as Memory,\n      setup.mockState as State,\n      {},\n      setup.callbackFn as HandlerCallback\n    );\n\n    expect(result).toBe(true);\n  });\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"testing-with-multiple-mock-responses",children:"Testing with Multiple Mock Responses"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"describe('Sequential Operations', () => {\n  it('should handle sequential API calls', async () => {\n    const setup = setupActionTest({\n      runtimeOverrides: {\n        useModel: mock()\n          .mockResolvedValueOnce({ step: 1, data: 'first' })\n          .mockResolvedValueOnce({ step: 2, data: 'second' })\n          .mockResolvedValueOnce({ step: 3, data: 'final' }),\n      },\n    });\n\n    await sequentialAction.handler(\n      setup.mockRuntime as IAgentRuntime,\n      setup.mockMessage as Memory,\n      setup.mockState as State,\n      {},\n      setup.callbackFn as HandlerCallback\n    );\n\n    expect(setup.mockRuntime.useModel).toHaveBeenCalledTimes(3);\n    expect(setup.callbackFn).toHaveBeenCalledWith(\n      expect.objectContaining({\n        text: expect.stringContaining('final'),\n      })\n    );\n  });\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"testing-error-recovery",children:"Testing Error Recovery"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"describe('Error Recovery', () => {\n  it('should retry on failure', async () => {\n    let attempts = 0;\n    const setup = setupActionTest({\n      runtimeOverrides: {\n        useModel: mock().mockImplementation(async () => {\n          attempts++;\n          if (attempts < 3) {\n            throw new Error('Temporary failure');\n          }\n          return { success: true };\n        }),\n      },\n    });\n\n    await retryAction.handler(\n      setup.mockRuntime as IAgentRuntime,\n      setup.mockMessage as Memory,\n      setup.mockState as State,\n      {},\n      setup.callbackFn as HandlerCallback\n    );\n\n    expect(attempts).toBe(3);\n    expect(setup.callbackFn).toHaveBeenCalledWith(\n      expect.objectContaining({\n        content: expect.objectContaining({ success: true }),\n      })\n    );\n  });\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"9-best-practices",children:"9. Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-test-organization",children:"1. Test Organization"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Group related tests using ",(0,a.jsx)(n.code,{children:"describe"})," blocks"]}),"\n",(0,a.jsx)(n.li,{children:"Use clear, descriptive test names"}),"\n",(0,a.jsx)(n.li,{children:"Follow the Arrange-Act-Assert pattern"}),"\n",(0,a.jsx)(n.li,{children:"Keep tests focused and independent"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-mock-management",children:"2. Mock Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Good: Specific mocks for each test\nit('should handle specific scenario', async () => {\n  const setup = setupActionTest({\n    runtimeOverrides: {\n      useModel: mock().mockResolvedValue({ specific: 'response' }),\n    },\n  });\n  // ... test implementation\n});\n\n// Bad: Global mocks that affect all tests\nbeforeAll(() => {\n  globalMock = mock().mockResolvedValue('global response');\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-assertion-patterns",children:"3. Assertion Patterns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Check callback was called with correct structure\nexpect(callbackFn).toHaveBeenCalledWith(\n  expect.objectContaining({\n    text: expect.stringContaining('expected text'),\n    content: expect.objectContaining({\n      success: true,\n      data: expect.arrayContaining(['item1', 'item2']),\n    }),\n  })\n);\n\n// Check multiple calls in sequence\nconst calls = (callbackFn as any).mock.calls;\nexpect(calls).toHaveLength(3);\nexpect(calls[0][0].text).toContain('step 1');\nexpect(calls[1][0].text).toContain('step 2');\nexpect(calls[2][0].text).toContain('completed');\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-testing-edge-cases",children:"4. Testing Edge Cases"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"describe('Edge Cases', () => {\n  it('should handle empty input', async () => {\n    mockMessage.content = { text: '' };\n    // ... test implementation\n  });\n\n  it('should handle null values', async () => {\n    mockMessage.content = null as any;\n    // ... test implementation\n  });\n\n  it('should handle very long input', async () => {\n    mockMessage.content = { text: 'a'.repeat(10000) };\n    // ... test implementation\n  });\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"5-async-testing-best-practices",children:"5. Async Testing Best Practices"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Always await async operations\nit('should handle async operations', async () => {\n  const promise = someAsyncOperation();\n  await expect(promise).resolves.toBe(expectedValue);\n});\n\n// Test rejected promises\nit('should handle errors', async () => {\n  const promise = failingOperation();\n  await expect(promise).rejects.toThrow('Expected error');\n});\n\n// Use async/await instead of .then()\nit('should process data', async () => {\n  const result = await processData();\n  expect(result).toBeDefined();\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"6-cleanup",children:"6. Cleanup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"afterEach(() => {\n  // Reset all mocks after each test\n  mock.restore();\n\n  // Clean up any side effects\n  // Clear timers, close connections, etc.\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"7-test-coverage-requirements",children:"7. Test Coverage Requirements"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"IMPORTANT"}),": All ElizaOS plugins must maintain 100% test coverage or as close to it as possible (minimum 95%)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Ensure all code paths are tested\ndescribe('Complete Coverage', () => {\n  it('should test success path', async () => {\n    // Test the happy path\n  });\n\n  it('should test error handling', async () => {\n    // Test error scenarios\n  });\n\n  it('should test edge cases', async () => {\n    // Test boundary conditions\n  });\n\n  it('should test all conditional branches', async () => {\n    // Test if/else, switch cases, etc.\n  });\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Coverage Best Practices:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"bun test --coverage"})," to check coverage regularly"]}),"\n",(0,a.jsx)(n.li,{children:"Set up CI/CD to fail builds with coverage below 95%"}),"\n",(0,a.jsx)(n.li,{children:"Document any legitimate reasons for uncovered code"}),"\n",(0,a.jsx)(n.li,{children:"Focus on meaningful tests, not just hitting coverage numbers"}),"\n",(0,a.jsx)(n.li,{children:"Test all exports from your plugin (actions, providers, evaluators, services)"}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"10-running-tests",children:"10. Running Tests"}),"\n",(0,a.jsx)(n.h3,{id:"basic-commands",children:"Basic Commands"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'# Run all tests\nbun run test\n\n# Run tests in watch mode\nbun run test --watch\n\n# Run specific test file\nbun run test src/__tests__/actions.test.ts\n\n# Run tests with coverage\nbun run test:coverage\n\n# Run tests matching pattern\nbun run test --test-name-pattern "should validate"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"test-configuration",children:"Test Configuration"}),"\n",(0,a.jsxs)(n.p,{children:["Create a ",(0,a.jsx)(n.code,{children:"bunfig.toml"})," file in your project root:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",children:'[test]\nroot = "./src/__tests__"\ncoverage = true\ncoverageThreshold = 95  # Minimum 95% coverage required, aim for 100%\n'})}),"\n",(0,a.jsx)(n.h3,{id:"debugging-tests",children:"Debugging Tests"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Add console.logs for debugging\nit('should debug test', async () => {\n    console.log('Current state:', mockState);\n\n    const result = await action.handler(...);\n\n    console.log('Result:', result);\n    console.log('Callback calls:', (callbackFn as any).mock.calls);\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,a.jsx)(n.h4,{id:"issue-mock-not-being-called",children:"Issue: Mock not being called"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Solution: Ensure the mock is set before the action is called\nmockRuntime.useModel = mock().mockResolvedValue(response);\n// THEN call the action\nawait action.handler(...);\n"})}),"\n",(0,a.jsx)(n.h4,{id:"issue-tests-timing-out",children:"Issue: Tests timing out"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Solution: Mock all async dependencies\nbeforeEach(() => {\n  // Mock all external calls\n  mockRuntime.getMemories = mock().mockResolvedValue([]);\n  mockRuntime.searchMemories = mock().mockResolvedValue([]);\n  mockRuntime.createMemory = mock().mockResolvedValue({ id: 'test' });\n});\n"})}),"\n",(0,a.jsx)(n.h4,{id:"issue-inconsistent-test-results",children:"Issue: Inconsistent test results"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Solution: Reset mocks between tests\nafterEach(() => {\n  mock.restore();\n});\n\n// And use fresh setup for each test\nbeforeEach(() => {\n  const setup = setupActionTest();\n  // ... assign to test variables\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"This guide provides a comprehensive approach to testing ElizaOS plugins. Key takeaways:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Setup a consistent test environment"})," with reusable utilities"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Test all plugin components"}),": actions, providers, evaluators, services, and event handlers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Mock external dependencies"})," properly to ensure isolated tests"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handle async operations"})," correctly with proper awaits"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Follow best practices"})," for organization, assertions, and cleanup"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Run tests regularly"})," as part of your development workflow"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Remember: Good tests are as important as good code. They ensure your plugin works correctly and continues to work as the codebase evolves."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(14041);const a={},i=s.createContext(a);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);