"use strict";(self.webpackChunkeliza_docs=self.webpackChunkeliza_docs||[]).push([[97396],{71837:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"guides/secrets-management","title":"\ud83d\udd10 Secrets Management","description":"A comprehensive guide for managing secrets, API keys, and sensitive configuration in Eliza.","source":"@site/docs/guides/secrets-management.md","sourceDirName":"guides","slug":"/guides/secrets-management","permalink":"/eliza/docs/guides/secrets-management","draft":false,"unlisted":false,"editUrl":"https://github.com/ai16z/eliza/tree/main/docs/docs/guides/secrets-management.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Advanced Usage","permalink":"/eliza/docs/guides/advanced"},"next":{"title":"Local Development","permalink":"/eliza/docs/guides/local-development"}}');var i=r(74848),s=r(28453);const a={sidebar_position:11},c="\ud83d\udd10 Secrets Management",o={},l=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Environment Variables",id:"environment-variables",level:3},{value:"Secret Types",id:"secret-types",level:3},{value:"Implementation Guide",id:"implementation-guide",level:2},{value:"Basic Setup",id:"basic-setup",level:3},{value:"Character-Specific Secrets",id:"character-specific-secrets",level:3},{value:"Secure Storage",id:"secure-storage",level:3},{value:"Database Secrets",id:"database-secrets",level:4},{value:"Wallet Management",id:"wallet-management",level:4},{value:"Secret Rotation",id:"secret-rotation",level:3},{value:"Access Control",id:"access-control",level:3},{value:"Encryption at Rest",id:"encryption-at-rest",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Environment Segregation",id:"1-environment-segregation",level:3},{value:"2. Git Security",id:"2-git-security",level:3},{value:"3. Secret Validation",id:"3-secret-validation",level:3},{value:"4. Error Handling",id:"4-error-handling",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"1. Handling API Keys",id:"1-handling-api-keys",level:3},{value:"2. Secure Configuration Loading",id:"2-secure-configuration-loading",level:3},{value:"3. Memory Security",id:"3-memory-security",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Related Resources",id:"related-resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"-secrets-management",children:"\ud83d\udd10 Secrets Management"})}),"\n",(0,i.jsx)(n.p,{children:"A comprehensive guide for managing secrets, API keys, and sensitive configuration in Eliza."}),"\n",(0,i.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"environment-variables",children:"Environment Variables"}),"\n",(0,i.jsx)(n.p,{children:"Eliza uses a hierarchical environment variable system:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Character-specific secrets (highest priority)"}),"\n",(0,i.jsx)(n.li,{children:"Environment variables"}),"\n",(0,i.jsx)(n.li,{children:"Default values (lowest priority)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"secret-types",children:"Secret Types"}),"\n",(0,i.jsx)(n.p,{children:"Common secrets you'll need to manage:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# API Keys\nOPENAI_API_KEY=sk-*\nANTHROPIC_API_KEY=your-key\nELEVENLABS_XI_API_KEY=your-key\nGOOGLE_GENERATIVE_AI_API_KEY=your-key\n\n# Client Authentication\nDISCORD_API_TOKEN=your-token\nTELEGRAM_BOT_TOKEN=your-token\n\n# Database Credentials\nSUPABASE_URL=your-url\nSUPABASE_SERVICE_API_KEY=your-key\n\n# EVM\nEVM_PRIVATE_KEY=EXAMPLE_WALLET_PRIVATE_KEY\n\n# Solana\nSOLANA_PRIVATE_KEY=EXAMPLE_WALLET_PRIVATE_KEY\nSOLANA_PUBLIC_KEY=EXAMPLE_WALLET_PUBLIC_KEY\n\n# Fallback Wallet Configuration (deprecated)\nWALLET_PRIVATE_KEY=EXAMPLE_WALLET_PRIVATE_KEY\nWALLET_PUBLIC_KEY=EXAMPLE_WALLET_PUBLIC_KEY\n"})}),"\n",(0,i.jsx)(n.h2,{id:"implementation-guide",children:"Implementation Guide"}),"\n",(0,i.jsx)(n.h3,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Create a ",(0,i.jsx)(n.code,{children:".env"})," file from template:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cp .env.example .env\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Configure environment discovery:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { config } from "dotenv";\nimport path from "path";\n\nexport function findNearestEnvFile(startDir = process.cwd()) {\n  let currentDir = startDir;\n\n  while (currentDir !== path.parse(currentDir).root) {\n    const envPath = path.join(currentDir, ".env");\n\n    if (fs.existsSync(envPath)) {\n      return envPath;\n    }\n\n    currentDir = path.dirname(currentDir);\n  }\n\n  return null;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"character-specific-secrets",children:"Character-Specific Secrets"}),"\n",(0,i.jsx)(n.p,{children:"Define secrets in character files:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "name": "TradingBot",\n  "settings": {\n    "secrets": {\n      "OPENAI_API_KEY": "character-specific-key",\n      "WALLET_PRIVATE_KEY": "character-specific-wallet"\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Access secrets in code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const apiKey = runtime.getSetting("OPENAI_API_KEY");\n'})}),"\n",(0,i.jsx)(n.h3,{id:"secure-storage",children:"Secure Storage"}),"\n",(0,i.jsx)(n.h4,{id:"database-secrets",children:"Database Secrets"}),"\n",(0,i.jsx)(n.p,{children:"Use encrypted connection strings:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class SecureDatabase {\n  private connection: Connection;\n\n  constructor(encryptedConfig: string) {\n    const config = this.decryptConfig(encryptedConfig);\n    this.connection = new Connection(config);\n  }\n\n  private decryptConfig(encrypted: string): DatabaseConfig {\n    // Implement decryption logic\n    return JSON.parse(decrypted);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"wallet-management",children:"Wallet Management"}),"\n",(0,i.jsx)(n.p,{children:"Secure handling of blockchain credentials:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'class WalletManager {\n  private async initializeWallet(runtime: IAgentRuntime) {\n    const privateKey =\n      runtime.getSetting("SOLANA_PRIVATE_KEY") ??\n      runtime.getSetting("WALLET_PRIVATE_KEY");\n\n    if (!privateKey) {\n      throw new Error("Wallet private key not configured");\n    }\n\n    // Validate key format\n    try {\n      const keyBuffer = Buffer.from(privateKey, "base64");\n      if (keyBuffer.length !== 64) {\n        throw new Error("Invalid key length");\n      }\n    } catch (error) {\n      throw new Error("Invalid private key format");\n    }\n\n    // Initialize wallet securely\n    return new Wallet(privateKey);\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"secret-rotation",children:"Secret Rotation"}),"\n",(0,i.jsx)(n.p,{children:"Implement automatic secret rotation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class SecretRotation {\n  private static readonly SECRET_LIFETIME = 90 * 24 * 60 * 60 * 1000; // 90 days\n\n  async shouldRotateSecret(secretName: string): Promise<boolean> {\n    const lastRotation = await this.getLastRotation(secretName);\n    return Date.now() - lastRotation > SecretRotation.SECRET_LIFETIME;\n  }\n\n  async rotateSecret(secretName: string): Promise<void> {\n    // Implement rotation logic\n    const newSecret = await this.generateNewSecret();\n    await this.updateSecret(secretName, newSecret);\n    await this.recordRotation(secretName);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"access-control",children:"Access Control"}),"\n",(0,i.jsx)(n.p,{children:"Implement proper access controls:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'class SecretAccess {\n  private static readonly ALLOWED_KEYS = [\n    "OPENAI_API_KEY",\n    "DISCORD_TOKEN",\n    // ... other allowed keys\n  ];\n\n  static validateAccess(key: string): boolean {\n    return this.ALLOWED_KEYS.includes(key);\n  }\n\n  static async getSecret(\n    runtime: IAgentRuntime,\n    key: string,\n  ): Promise<string | null> {\n    if (!this.validateAccess(key)) {\n      throw new Error(`Unauthorized access to secret: ${key}`);\n    }\n\n    return runtime.getSetting(key);\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"encryption-at-rest",children:"Encryption at Rest"}),"\n",(0,i.jsx)(n.p,{children:"Implement encryption for stored secrets:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { createCipheriv, createDecipheriv } from "crypto";\n\nclass SecretEncryption {\n  static async encrypt(value: string, key: Buffer): Promise<string> {\n    const iv = crypto.randomBytes(16);\n    const cipher = createCipheriv("aes-256-gcm", key, iv);\n\n    let encrypted = cipher.update(value, "utf8", "hex");\n    encrypted += cipher.final("hex");\n\n    return JSON.stringify({\n      iv: iv.toString("hex"),\n      encrypted,\n      tag: cipher.getAuthTag().toString("hex"),\n    });\n  }\n\n  static async decrypt(encrypted: string, key: Buffer): Promise<string> {\n    const { iv, encrypted: encryptedData, tag } = JSON.parse(encrypted);\n\n    const decipher = createDecipheriv(\n      "aes-256-gcm",\n      key,\n      Buffer.from(iv, "hex"),\n    );\n\n    decipher.setAuthTag(Buffer.from(tag, "hex"));\n\n    let decrypted = decipher.update(encryptedData, "hex", "utf8");\n    decrypted += decipher.final("utf8");\n\n    return decrypted;\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-environment-segregation",children:"1. Environment Segregation"}),"\n",(0,i.jsx)(n.p,{children:"Maintain separate environment files:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:".env.development    # Local development settings\n.env.staging       # Staging environment\n.env.production    # Production settings\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-git-security",children:"2. Git Security"}),"\n",(0,i.jsx)(n.p,{children:"Exclude sensitive files:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gitignore",children:"# .gitignore\n.env\n.env.*\ncharacters/**/secrets.json\n**/serviceAccount.json\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-secret-validation",children:"3. Secret Validation"}),"\n",(0,i.jsx)(n.p,{children:"Validate secrets before use:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'async function validateSecrets(character: Character): Promise<void> {\n  const required = ["OPENAI_API_KEY"];\n  const missing = required.filter((key) => !character.settings.secrets[key]);\n\n  if (missing.length > 0) {\n    throw new Error(`Missing required secrets: ${missing.join(", ")}`);\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-error-handling",children:"4. Error Handling"}),"\n",(0,i.jsx)(n.p,{children:"Secure error messages:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'try {\n  await loadSecrets();\n} catch (error) {\n  if (error.code === "ENOENT") {\n    console.error("Environment file not found");\n  } else if (error instanceof ValidationError) {\n    console.error("Invalid secret format");\n  } else {\n    // Log securely without exposing secret values\n    console.error("Error loading secrets");\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"1-handling-api-keys",children:"1. Handling API Keys"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'class APIKeyManager {\n  private validateAPIKey(key: string): boolean {\n    if (key.startsWith("sk-")) {\n      return key.length > 20;\n    }\n    return false;\n  }\n\n  async rotateAPIKey(provider: string): Promise<void> {\n    // Implement key rotation logic\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-secure-configuration-loading",children:"2. Secure Configuration Loading"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'class ConfigLoader {\n  private static sanitizePath(path: string): boolean {\n    return !path.includes("../") && !path.startsWith("/");\n  }\n\n  async loadConfig(path: string): Promise<Config> {\n    if (!this.sanitizePath(path)) {\n      throw new Error("Invalid config path");\n    }\n    // Load configuration\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-memory-security",children:"3. Memory Security"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class SecureMemory {\n  private secrets: Map<string, WeakRef<string>> = new Map();\n\n  set(key: string, value: string): void {\n    this.secrets.set(key, new WeakRef(value));\n  }\n\n  get(key: string): string | null {\n    const ref = this.secrets.get(key);\n    return ref?.deref() ?? null;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Missing Secrets"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'if (!process.env.OPENAI_API_KEY) {\n  throw new Error(\n    "OpenAI API key not found in environment or character settings",\n  );\n}\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Invalid Secret Format"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function validateApiKey(key: string): boolean {\n  // OpenAI keys start with 'sk-'\n  if (key.startsWith(\"sk-\")) {\n    return key.length > 20;\n  }\n  return false;\n}\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"Secret Loading Errors"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'try {\n  await loadSecrets();\n} catch (error) {\n  if (error.response) {\n    console.error("Response data:", error.response.data);\n    console.error("Response status:", error.response.status);\n  } else if (error.request) {\n    console.error("No response received:", error.request);\n  } else {\n    console.error("Error setting up request:", error.message);\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"related-resources",children:"Related Resources"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/eliza/docs/guides/configuration",children:"Configuration Guide"})," for general setup"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/eliza/docs/guides/local-development",children:"Local Development"})," for development environment"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/eliza/docs/advanced/infrastructure",children:"Infrastructure Guide"})," for deployment security"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var t=r(96540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);