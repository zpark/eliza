"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[13649],{9236:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"technical/architecture/socket-communication","title":"Socket Communication Architecture","description":"ElizaOS implements real-time communication through WebSocket connections, providing instant message delivery and live interaction capabilities across multiple platforms and agents.","source":"@site/docs/technical/architecture/socket-communication.md","sourceDirName":"technical/architecture","slug":"/technical/architecture/socket-communication","permalink":"/docs/technical/architecture/socket-communication","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/technical/architecture/socket-communication.md","tags":[],"version":"current","lastUpdatedBy":"Sayo","lastUpdatedAt":1751802400000,"frontMatter":{}}');var o=t(31085),i=t(71184);const a={},r="Socket Communication Architecture",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Architecture Components",id:"architecture-components",level:2},{value:"Server-Side Implementation",id:"server-side-implementation",level:3},{value:"Socket.IO Server Setup",id:"socketio-server-setup",level:4},{value:"Message Processing Pipeline",id:"message-processing-pipeline",level:4},{value:"Client-Side Implementation",id:"client-side-implementation",level:3},{value:"Socket Manager",id:"socket-manager",level:4},{value:"React Integration",id:"react-integration",level:4},{value:"Message Flow Architecture",id:"message-flow-architecture",level:2},{value:"Message Types",id:"message-types",level:3},{value:"Channel Management",id:"channel-management",level:3},{value:"Event Broadcasting",id:"event-broadcasting",level:3},{value:"Integration with Agent Runtime",id:"integration-with-agent-runtime",level:2},{value:"Bootstrap Plugin Integration",id:"bootstrap-plugin-integration",level:3},{value:"Send Handler Registration",id:"send-handler-registration",level:3},{value:"Connection Management",id:"connection-management",level:2},{value:"Connection State Tracking",id:"connection-state-tracking",level:3},{value:"Reconnection Handling",id:"reconnection-handling",level:3},{value:"Performance Optimizations",id:"performance-optimizations",level:2},{value:"Message Batching",id:"message-batching",level:3},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Error Handling and Resilience",id:"error-handling-and-resilience",level:2},{value:"Error Recovery",id:"error-recovery",level:3},{value:"Circuit Breaker Pattern",id:"circuit-breaker-pattern",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Authentication and Authorization",id:"authentication-and-authorization",level:3},{value:"Rate Limiting",id:"rate-limiting",level:3}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"socket-communication-architecture",children:"Socket Communication Architecture"})}),"\n",(0,o.jsx)(e.p,{children:"ElizaOS implements real-time communication through WebSocket connections, providing instant message delivery and live interaction capabilities across multiple platforms and agents."}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"The socket communication system enables:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Real-time messaging"})," - Instant bidirectional communication"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Multi-agent coordination"})," - Live coordination between multiple agents"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Cross-platform integration"})," - Unified communication layer"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Event-driven architecture"})," - Reactive message handling"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"architecture-components",children:"Architecture Components"}),"\n",(0,o.jsx)(e.h3,{id:"server-side-implementation",children:"Server-Side Implementation"}),"\n",(0,o.jsx)(e.h4,{id:"socketio-server-setup",children:"Socket.IO Server Setup"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// packages/server/src/socketio/index.ts\nimport { Server as SocketIOServer } from 'socket.io';\n\nexport const setupSocketIO = (server: any, runtime: IAgentRuntime) => {\n  const io = new SocketIOServer(server, {\n    cors: {\n      origin: '*',\n      methods: ['GET', 'POST'],\n    },\n  });\n\n  // Message type definitions\n  enum MessageType {\n    ROOM_JOINING = 'room_joining',\n    SEND_MESSAGE = 'send_message',\n    MESSAGE = 'message',\n    ACK = 'ack',\n    THINKING = 'thinking',\n    CONTROL = 'control',\n  }\n\n  io.on('connection', (socket) => {\n    console.log('User connected:', socket.id);\n\n    // Handle message sending\n    socket.on(MessageType.SEND_MESSAGE, async (data) => {\n      await handleIncomingMessage(socket, data, runtime);\n    });\n\n    // Handle room joining\n    socket.on(MessageType.ROOM_JOINING, (data) => {\n      socket.join(data.roomId);\n      console.log(`Socket ${socket.id} joined room ${data.roomId}`);\n    });\n\n    socket.on('disconnect', () => {\n      console.log('User disconnected:', socket.id);\n    });\n  });\n\n  return io;\n};\n"})}),"\n",(0,o.jsx)(e.h4,{id:"message-processing-pipeline",children:"Message Processing Pipeline"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"async function handleIncomingMessage(socket: Socket, data: MessageData, runtime: IAgentRuntime) {\n  try {\n    // 1. Validate message data\n    const validatedData = validateMessageData(data);\n\n    // 2. Create memory object\n    const memory: Memory = {\n      id: stringToUuid(Date.now().toString()),\n      entityId: stringToUuid(validatedData.userId),\n      roomId: stringToUuid(validatedData.roomId),\n      worldId: stringToUuid(validatedData.worldId || 'default'),\n      content: {\n        text: validatedData.text,\n        source: 'websocket-api',\n        metadata: validatedData.metadata || {},\n      },\n      type: MemoryType.MESSAGE,\n    };\n\n    // 3. Store message in database\n    await runtime.memory.create(memory);\n\n    // 4. Broadcast message to room participants\n    socket.to(validatedData.roomId).emit(MessageType.MESSAGE, {\n      id: memory.id,\n      userId: memory.entityId,\n      text: memory.content.text,\n      timestamp: Date.now(),\n    });\n\n    // 5. Process with agent runtime\n    const response = await runtime.processMessage(memory);\n\n    // 6. Send agent response back to room\n    if (response) {\n      socket.to(validatedData.roomId).emit(MessageType.MESSAGE, {\n        id: response.id,\n        userId: runtime.agentId,\n        text: response.content.text,\n        timestamp: Date.now(),\n      });\n    }\n\n    // 7. Send acknowledgment\n    socket.emit(MessageType.ACK, { success: true, messageId: memory.id });\n  } catch (error) {\n    console.error('Message processing error:', error);\n    socket.emit(MessageType.ACK, { success: false, error: error.message });\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"client-side-implementation",children:"Client-Side Implementation"}),"\n",(0,o.jsx)(e.h4,{id:"socket-manager",children:"Socket Manager"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// packages/client/src/lib/socketio-manager.ts\nimport { io, Socket } from 'socket.io-client';\nimport { Evt } from 'evt';\n\nexport class SocketIOManager {\n  private static instance: SocketIOManager;\n  private socket: Socket | null = null;\n  private eventBus = Evt.create<SocketEvent>();\n  private activeChannels = new Set<string>();\n\n  static getInstance(): SocketIOManager {\n    if (!SocketIOManager.instance) {\n      SocketIOManager.instance = new SocketIOManager();\n    }\n    return SocketIOManager.instance;\n  }\n\n  connect(url: string): void {\n    if (this.socket?.connected) {\n      return;\n    }\n\n    this.socket = io(url, {\n      autoConnect: true,\n      reconnection: true,\n      reconnectionAttempts: 5,\n      reconnectionDelay: 1000,\n    });\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    if (!this.socket) return;\n\n    // Connection events\n    this.socket.on('connect', () => {\n      console.log('Connected to server');\n      this.eventBus.post('connected');\n    });\n\n    this.socket.on('disconnect', () => {\n      console.log('Disconnected from server');\n      this.eventBus.post('disconnected');\n    });\n\n    // Message events\n    this.socket.on('message', (data: MessageEvent) => {\n      this.eventBus.post('message', data);\n    });\n\n    this.socket.on('thinking', (data: ThinkingEvent) => {\n      this.eventBus.post('thinking', data);\n    });\n\n    this.socket.on('ack', (data: AckEvent) => {\n      this.eventBus.post('ack', data);\n    });\n  }\n\n  joinChannel(channelId: string): void {\n    if (!this.socket) {\n      throw new Error('Socket not connected');\n    }\n\n    this.socket.emit('room_joining', { roomId: channelId });\n    this.activeChannels.add(channelId);\n  }\n\n  sendMessage(channelId: string, message: string, metadata?: any): void {\n    if (!this.socket) {\n      throw new Error('Socket not connected');\n    }\n\n    this.socket.emit('send_message', {\n      roomId: channelId,\n      text: message,\n      userId: this.getUserId(),\n      metadata,\n    });\n  }\n\n  // Event subscription interface\n  on<T extends keyof SocketEventMap>(\n    event: T,\n    handler: (data: SocketEventMap[T]) => void\n  ): () => void {\n    const ctx = this.eventBus.attach(event, handler);\n    return () => ctx.detach();\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h4,{id:"react-integration",children:"React Integration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// packages/client/src/hooks/useSocket.ts\nimport { useEffect, useState } from 'react';\nimport { SocketIOManager } from '../lib/socketio-manager';\n\nexport function useSocket(serverUrl?: string) {\n  const [isConnected, setIsConnected] = useState(false);\n  const [socket] = useState(() => SocketIOManager.getInstance());\n\n  useEffect(() => {\n    if (serverUrl) {\n      socket.connect(serverUrl);\n    }\n\n    // Subscribe to connection events\n    const unsubscribeConnected = socket.on('connected', () => {\n      setIsConnected(true);\n    });\n\n    const unsubscribeDisconnected = socket.on('disconnected', () => {\n      setIsConnected(false);\n    });\n\n    return () => {\n      unsubscribeConnected();\n      unsubscribeDisconnected();\n    };\n  }, [serverUrl, socket]);\n\n  return {\n    socket,\n    isConnected,\n    joinChannel: (channelId: string) => socket.joinChannel(channelId),\n    sendMessage: (channelId: string, message: string, metadata?: any) =>\n      socket.sendMessage(channelId, message, metadata),\n  };\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"message-flow-architecture",children:"Message Flow Architecture"}),"\n",(0,o.jsx)(e.h3,{id:"message-types",children:"Message Types"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"interface SocketMessage {\n  type: MessageType;\n  payload: any;\n  timestamp: number;\n  id: string;\n}\n\nenum MessageType {\n  // User actions\n  ROOM_JOINING = 'room_joining', // User joins a channel\n  SEND_MESSAGE = 'send_message', // User sends a message\n\n  // Server responses\n  MESSAGE = 'message', // Broadcast message to room\n  ACK = 'ack', // Acknowledgment of received message\n  THINKING = 'thinking', // Agent is processing (typing indicator)\n  CONTROL = 'control', // System control messages\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"channel-management",children:"Channel Management"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// Auto-creation of channels for message flow\nclass ChannelManager {\n  private channels = new Map<string, ChannelInfo>();\n\n  async ensureChannel(channelId: string): Promise<ChannelInfo> {\n    if (!this.channels.has(channelId)) {\n      // Create new channel\n      const channel: ChannelInfo = {\n        id: channelId,\n        participants: new Set(),\n        createdAt: Date.now(),\n        lastActivity: Date.now(),\n      };\n\n      // Store in database\n      await this.saveChannel(channel);\n      this.channels.set(channelId, channel);\n    }\n\n    return this.channels.get(channelId)!;\n  }\n\n  addParticipant(channelId: string, userId: string): void {\n    const channel = this.channels.get(channelId);\n    if (channel) {\n      channel.participants.add(userId);\n      channel.lastActivity = Date.now();\n    }\n  }\n\n  removeParticipant(channelId: string, userId: string): void {\n    const channel = this.channels.get(channelId);\n    if (channel) {\n      channel.participants.delete(userId);\n\n      // Cleanup empty channels\n      if (channel.participants.size === 0) {\n        this.scheduleChannelCleanup(channelId);\n      }\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"event-broadcasting",children:"Event Broadcasting"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"class EventBroadcaster {\n  constructor(private io: SocketIOServer) {}\n\n  // Broadcast to specific room\n  broadcastToRoom(roomId: string, event: string, data: any): void {\n    this.io.to(roomId).emit(event, {\n      ...data,\n      timestamp: Date.now(),\n      roomId,\n    });\n  }\n\n  // Broadcast to all connected clients\n  broadcastGlobally(event: string, data: any): void {\n    this.io.emit(event, {\n      ...data,\n      timestamp: Date.now(),\n    });\n  }\n\n  // Send to specific socket\n  sendToSocket(socketId: string, event: string, data: any): void {\n    this.io.to(socketId).emit(event, {\n      ...data,\n      timestamp: Date.now(),\n    });\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"integration-with-agent-runtime",children:"Integration with Agent Runtime"}),"\n",(0,o.jsx)(e.h3,{id:"bootstrap-plugin-integration",children:"Bootstrap Plugin Integration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// packages/plugin-bootstrap/src/index.ts\nexport default {\n  name: 'bootstrap',\n  description: 'Core event handlers and message routing',\n\n  services: [\n    {\n      name: 'websocket',\n      initialize: async (runtime: IAgentRuntime) => {\n        // Handle entity joined events for world/entity creation\n        runtime.on('ENTITY_JOINED', async (data) => {\n          await handleEntityJoined(runtime, data);\n        });\n\n        // Handle messages from socket connections\n        runtime.on('MESSAGE_RECEIVED', async (data) => {\n          await handleSocketMessage(runtime, data);\n        });\n      },\n    },\n  ],\n};\n\nasync function handleEntityJoined(runtime: IAgentRuntime, data: EntityJoinedEvent) {\n  // Ensure world exists\n  await runtime.ensureWorldExists({\n    id: data.worldId,\n    name: data.worldName || 'Socket World',\n  });\n\n  // Ensure entity exists\n  await runtime.ensureEntityExists({\n    id: data.entityId,\n    name: data.entityName || 'Socket User',\n  });\n\n  // Create or update room\n  await runtime.ensureRoomExists({\n    id: data.roomId,\n    worldId: data.worldId,\n    name: data.roomName || 'Socket Channel',\n  });\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"send-handler-registration",children:"Send Handler Registration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// Register WebSocket send handler\nruntime.sendHandlers.set(\n  'websocket-api',\n  async (runtime: IAgentRuntime, target: TargetInfo, content: Content) => {\n    const socketManager = SocketIOManager.getInstance();\n\n    // Send message through WebSocket\n    socketManager.sendMessage(target.roomId, content.text, content.metadata);\n\n    // Also broadcast to room participants\n    const io = getSocketIOInstance();\n    io.to(target.roomId).emit('message', {\n      id: stringToUuid(Date.now().toString()),\n      userId: runtime.agentId,\n      text: content.text,\n      timestamp: Date.now(),\n      source: 'agent',\n    });\n  }\n);\n"})}),"\n",(0,o.jsx)(e.h2,{id:"connection-management",children:"Connection Management"}),"\n",(0,o.jsx)(e.h3,{id:"connection-state-tracking",children:"Connection State Tracking"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"class ConnectionManager {\n  private connections = new Map<string, ConnectionInfo>();\n\n  trackConnection(socketId: string, info: ConnectionInfo): void {\n    this.connections.set(socketId, {\n      ...info,\n      connectedAt: Date.now(),\n      lastSeen: Date.now(),\n    });\n  }\n\n  updateLastSeen(socketId: string): void {\n    const connection = this.connections.get(socketId);\n    if (connection) {\n      connection.lastSeen = Date.now();\n    }\n  }\n\n  removeConnection(socketId: string): void {\n    this.connections.delete(socketId);\n  }\n\n  // Get active connections for a room\n  getActiveConnections(roomId: string): ConnectionInfo[] {\n    return Array.from(this.connections.values()).filter((conn) => conn.roomIds.includes(roomId));\n  }\n\n  // Cleanup stale connections\n  cleanupStaleConnections(maxAge: number = 5 * 60 * 1000): void {\n    const cutoff = Date.now() - maxAge;\n\n    for (const [socketId, connection] of this.connections) {\n      if (connection.lastSeen < cutoff) {\n        this.removeConnection(socketId);\n      }\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"reconnection-handling",children:"Reconnection Handling"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// Client-side reconnection logic\nclass ReconnectionManager {\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectDelay = 1000;\n\n  async handleReconnection(socket: Socket): Promise<void> {\n    socket.on('disconnect', () => {\n      this.startReconnectionProcess();\n    });\n\n    socket.on('connect', () => {\n      this.resetReconnectionState();\n      this.restoreActiveChannels();\n    });\n  }\n\n  private startReconnectionProcess(): void {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      return;\n    }\n\n    setTimeout(\n      () => {\n        this.reconnectAttempts++;\n        this.attemptReconnection();\n      },\n      this.reconnectDelay * Math.pow(2, this.reconnectAttempts)\n    );\n  }\n\n  private resetReconnectionState(): void {\n    this.reconnectAttempts = 0;\n  }\n\n  private restoreActiveChannels(): void {\n    const socketManager = SocketIOManager.getInstance();\n\n    // Rejoin all previously active channels\n    for (const channelId of socketManager.getActiveChannels()) {\n      socketManager.joinChannel(channelId);\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"performance-optimizations",children:"Performance Optimizations"}),"\n",(0,o.jsx)(e.h3,{id:"message-batching",children:"Message Batching"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"class MessageBatcher {\n  private batch: SocketMessage[] = [];\n  private batchTimer: NodeJS.Timeout | null = null;\n  private readonly batchSize = 10;\n  private readonly batchDelay = 100; // ms\n\n  addMessage(message: SocketMessage): void {\n    this.batch.push(message);\n\n    if (this.batch.length >= this.batchSize) {\n      this.flushBatch();\n    } else if (!this.batchTimer) {\n      this.batchTimer = setTimeout(() => {\n        this.flushBatch();\n      }, this.batchDelay);\n    }\n  }\n\n  private flushBatch(): void {\n    if (this.batch.length > 0) {\n      this.processBatch([...this.batch]);\n      this.batch = [];\n    }\n\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = null;\n    }\n  }\n\n  private processBatch(messages: SocketMessage[]): void {\n    // Process batch of messages efficiently\n    const grouped = this.groupMessagesByRoom(messages);\n\n    for (const [roomId, roomMessages] of grouped) {\n      this.broadcastBatchToRoom(roomId, roomMessages);\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"connection-pooling",children:"Connection Pooling"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"class SocketPool {\n  private pools = new Map<string, Socket[]>();\n  private readonly maxPoolSize = 10;\n\n  getConnection(roomId: string): Socket | null {\n    const pool = this.pools.get(roomId) || [];\n    return pool.find((socket) => socket.connected) || null;\n  }\n\n  addConnection(roomId: string, socket: Socket): void {\n    if (!this.pools.has(roomId)) {\n      this.pools.set(roomId, []);\n    }\n\n    const pool = this.pools.get(roomId)!;\n\n    if (pool.length < this.maxPoolSize) {\n      pool.push(socket);\n    }\n\n    // Cleanup disconnected sockets\n    this.cleanupPool(roomId);\n  }\n\n  private cleanupPool(roomId: string): void {\n    const pool = this.pools.get(roomId);\n    if (pool) {\n      const active = pool.filter((socket) => socket.connected);\n      this.pools.set(roomId, active);\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"error-handling-and-resilience",children:"Error Handling and Resilience"}),"\n",(0,o.jsx)(e.h3,{id:"error-recovery",children:"Error Recovery"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"class SocketErrorHandler {\n  handleConnectionError(error: Error, socket: Socket): void {\n    console.error('Socket connection error:', error);\n\n    // Attempt graceful recovery\n    if (this.isRecoverableError(error)) {\n      this.scheduleReconnection(socket);\n    } else {\n      this.handleFatalError(error, socket);\n    }\n  }\n\n  handleMessageError(error: Error, message: SocketMessage): void {\n    console.error('Message processing error:', error);\n\n    // Try to send error response\n    try {\n      this.sendErrorResponse(message, error);\n    } catch (responseError) {\n      console.error('Failed to send error response:', responseError);\n    }\n  }\n\n  private isRecoverableError(error: Error): boolean {\n    const recoverableErrors = ['ECONNRESET', 'ENOTFOUND', 'TIMEOUT', 'NETWORK_ERROR'];\n\n    return recoverableErrors.some(\n      (errType) => error.message.includes(errType) || error.name.includes(errType)\n    );\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"circuit-breaker-pattern",children:"Circuit Breaker Pattern"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"class SocketCircuitBreaker {\n  private failureCount = 0;\n  private readonly failureThreshold = 5;\n  private readonly resetTimeout = 60000; // 1 minute\n  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';\n  private nextAttempt = 0;\n\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.state === 'OPEN') {\n      if (Date.now() < this.nextAttempt) {\n        throw new Error('Circuit breaker is OPEN');\n      }\n      this.state = 'HALF_OPEN';\n    }\n\n    try {\n      const result = await operation();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private onSuccess(): void {\n    this.failureCount = 0;\n    this.state = 'CLOSED';\n  }\n\n  private onFailure(): void {\n    this.failureCount++;\n\n    if (this.failureCount >= this.failureThreshold) {\n      this.state = 'OPEN';\n      this.nextAttempt = Date.now() + this.resetTimeout;\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,o.jsx)(e.h3,{id:"authentication-and-authorization",children:"Authentication and Authorization"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// JWT-based socket authentication\nconst authenticateSocket = (socket: Socket, next: (err?: Error) => void) => {\n  const token = socket.handshake.auth.token;\n\n  if (!token) {\n    return next(new Error('Authentication required'));\n  }\n\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET!);\n    socket.userId = decoded.userId;\n    socket.permissions = decoded.permissions || [];\n    next();\n  } catch (error) {\n    next(new Error('Invalid token'));\n  }\n};\n\n// Room access control\nconst authorizeRoomAccess = async (socket: Socket, roomId: string): Promise<boolean> => {\n  // Check if user has permission to access room\n  const hasAccess = await checkRoomPermissions(socket.userId, roomId);\n\n  if (!hasAccess) {\n    socket.emit('error', { message: 'Access denied to room' });\n    return false;\n  }\n\n  return true;\n};\n"})}),"\n",(0,o.jsx)(e.h3,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"class SocketRateLimiter {\n  private userLimits = new Map<string, RateLimit>();\n  private readonly maxRequests = 100;\n  private readonly windowMs = 60000; // 1 minute\n\n  checkRateLimit(userId: string): boolean {\n    const now = Date.now();\n    const userLimit = this.userLimits.get(userId) || {\n      requests: 0,\n      resetTime: now + this.windowMs,\n    };\n\n    if (now > userLimit.resetTime) {\n      userLimit.requests = 0;\n      userLimit.resetTime = now + this.windowMs;\n    }\n\n    if (userLimit.requests >= this.maxRequests) {\n      return false;\n    }\n\n    userLimit.requests++;\n    this.userLimits.set(userId, userLimit);\n    return true;\n  }\n}\n"})}),"\n",(0,o.jsx)(e.p,{children:"This socket communication architecture provides the foundation for real-time interaction in ElizaOS, enabling instant messaging, live agent responses, and coordinated multi-agent communication across various platforms and clients."})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(l,{...n})}):l(n)}},71184:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>r});var s=t(14041);const o={},i=s.createContext(o);function a(n){const e=s.useContext(i);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),s.createElement(i.Provider,{value:e},n.children)}}}]);