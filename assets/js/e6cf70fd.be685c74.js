"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[45326],{61741:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"technical/architecture/plugin-system","title":"Plugin System","description":"Deep dive into ElizaOS plugin architecture and development","source":"@site/docs/technical/architecture/plugin-system.md","sourceDirName":"technical/architecture","slug":"/technical/architecture/plugin-system","permalink":"/docs/technical/architecture/plugin-system","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/technical/architecture/plugin-system.md","tags":[],"version":"current","lastUpdatedBy":"SYMBaiEX","lastUpdatedAt":1751753321000,"frontMatter":{"title":"Plugin System","description":"Deep dive into ElizaOS plugin architecture and development"},"sidebar":"technicalSidebar","previous":{"title":"\ud83e\udde9 Memory System","permalink":"/docs/technical/architecture/memory-system"},"next":{"title":"\u26a1 Actions API","permalink":"/docs/technical/api-reference/actions-api"}}');var a=i(31085),r=i(71184);const s={title:"Plugin System",description:"Deep dive into ElizaOS plugin architecture and development"},o="Plugin System",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Plugin Structure",id:"plugin-structure",level:2},{value:"Basic Plugin Definition",id:"basic-plugin-definition",level:3},{value:"Complete Plugin Example",id:"complete-plugin-example",level:3},{value:"Plugin Components",id:"plugin-components",level:2},{value:"1. Actions",id:"1-actions",level:3},{value:"2. Providers",id:"2-providers",level:3},{value:"3. Evaluators",id:"3-evaluators",level:3},{value:"4. Services",id:"4-services",level:3},{value:"Plugin Lifecycle",id:"plugin-lifecycle",level:2},{value:"1. Loading Process",id:"1-loading-process",level:3},{value:"2. Dependency Resolution",id:"2-dependency-resolution",level:3},{value:"3. Hot Reloading",id:"3-hot-reloading",level:3},{value:"Plugin Development",id:"plugin-development",level:2},{value:"1. TypeScript Plugin Template",id:"1-typescript-plugin-template",level:3},{value:"2. Plugin Testing",id:"2-plugin-testing",level:3},{value:"3. Plugin Publishing",id:"3-plugin-publishing",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"1. Plugin Composition",id:"1-plugin-composition",level:3},{value:"2. Plugin Middleware",id:"2-plugin-middleware",level:3},{value:"3. Plugin Communication",id:"3-plugin-communication",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"1. Sandboxing",id:"1-sandboxing",level:3},{value:"2. Permission System",id:"2-permission-system",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"1. Lazy Loading",id:"1-lazy-loading",level:3},{value:"2. Resource Pooling",id:"2-resource-pooling",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function u(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"plugin-system",children:"Plugin System"})}),"\n",(0,a.jsx)(e.p,{children:"The ElizaOS plugin system provides a powerful, extensible architecture for adding custom functionality to agents. This guide covers the plugin architecture, development patterns, and best practices."}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(e.p,{children:"The plugin system enables:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Modular functionality through standardized interfaces"}),"\n",(0,a.jsx)(e.li,{children:"Hot-loading and dynamic plugin management"}),"\n",(0,a.jsx)(e.li,{children:"Dependency resolution and version management"}),"\n",(0,a.jsx)(e.li,{children:"Isolated plugin contexts for security"}),"\n",(0,a.jsx)(e.li,{children:"Shared services and state management"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"architecture",children:"Architecture"}),"\n",(0,a.jsx)(e.mermaid,{value:'graph TB\n    subgraph "Plugin System"\n        PM[Plugin Manager] --\x3e Loader[Plugin Loader]\n        Loader --\x3e Validator[Plugin Validator]\n        Validator --\x3e Registry[Plugin Registry]\n\n        Registry --\x3e Actions[Actions]\n        Registry --\x3e Providers[Providers]\n        Registry --\x3e Evaluators[Evaluators]\n        Registry --\x3e Services[Services]\n    end\n\n    subgraph "Runtime Integration"\n        Runtime[Agent Runtime] --\x3e PM\n        Runtime --\x3e Executor[Plugin Executor]\n        Executor --\x3e Context[Plugin Context]\n        Context --\x3e Plugin[Plugin Instance]\n    end'}),"\n",(0,a.jsx)(e.h2,{id:"plugin-structure",children:"Plugin Structure"}),"\n",(0,a.jsx)(e.h3,{id:"basic-plugin-definition",children:"Basic Plugin Definition"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface Plugin {\n  name: string; // Unique identifier\n  version: string; // Semantic version\n  description?: string; // Human-readable description\n  author?: string; // Plugin author\n  license?: string; // License identifier\n\n  // Dependencies\n  dependencies?: string[]; // Required plugins\n  optionalDependencies?: string[]; // Optional plugins\n\n  // Components\n  actions?: Action[]; // Action handlers\n  providers?: Provider[]; // Context providers\n  evaluators?: Evaluator[]; // Message evaluators\n  services?: Service[]; // Background services\n\n  // Lifecycle hooks\n  onLoad?: (runtime: IAgentRuntime) => Promise<void>;\n  onUnload?: (runtime: IAgentRuntime) => Promise<void>;\n\n  // Configuration\n  configSchema?: ConfigSchema; // Configuration validation\n  defaultConfig?: any; // Default configuration\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"complete-plugin-example",children:"Complete Plugin Example"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"import { Plugin, IAgentRuntime } from '@elizaos/core';\n\nexport const weatherPlugin: Plugin = {\n  name: 'weather',\n  version: '1.0.0',\n  description: 'Weather information and forecasts',\n  author: 'ElizaOS Team',\n  license: 'MIT',\n\n  dependencies: ['http-client', 'geolocation'],\n\n  actions: [\n    {\n      name: 'GET_WEATHER',\n      description: 'Get current weather for a location',\n      examples: [\n        { input: \"What's the weather in London?\", output: 'Getting weather...' },\n        { input: 'Is it raining in Tokyo?', output: 'Checking weather...' },\n      ],\n\n      validate: async (input: string): Promise<boolean> => {\n        const weatherPattern = /weather|temperature|rain|snow|forecast/i;\n        return weatherPattern.test(input);\n      },\n\n      handler: async ({ input, runtime }) => {\n        const location = await extractLocation(input);\n        const weather = await runtime.getService('weather').getWeather(location);\n\n        return {\n          text: formatWeatherResponse(weather),\n          data: weather,\n        };\n      },\n    },\n  ],\n\n  providers: [\n    {\n      name: 'weather-context',\n      description: 'Provides weather context for conversations',\n\n      get: async (runtime: IAgentRuntime) => {\n        const location = await runtime.getService('geolocation').getCurrentLocation();\n        const weather = await runtime.getService('weather').getWeather(location);\n\n        return {\n          currentWeather: weather,\n          lastUpdated: new Date(),\n        };\n      },\n    },\n  ],\n\n  services: [\n    {\n      name: 'weather',\n\n      async start(runtime: IAgentRuntime) {\n        this.apiKey = runtime.config.weatherApiKey;\n        this.cache = new Map();\n\n        // Start cache cleanup timer\n        this.cleanupTimer = setInterval(\n          () => {\n            this.cleanupCache();\n          },\n          60 * 60 * 1000\n        ); // Every hour\n      },\n\n      async stop() {\n        clearInterval(this.cleanupTimer);\n        this.cache.clear();\n      },\n\n      async getWeather(location: string) {\n        // Check cache first\n        const cached = this.cache.get(location);\n        if (cached && Date.now() - cached.timestamp < 10 * 60 * 1000) {\n          return cached.data;\n        }\n\n        // Fetch from API\n        const weather = await this.fetchWeatherFromAPI(location);\n\n        // Update cache\n        this.cache.set(location, {\n          data: weather,\n          timestamp: Date.now(),\n        });\n\n        return weather;\n      },\n    },\n  ],\n\n  configSchema: {\n    type: 'object',\n    properties: {\n      weatherApiKey: {\n        type: 'string',\n        description: 'API key for weather service',\n      },\n      units: {\n        type: 'string',\n        enum: ['metric', 'imperial'],\n        default: 'metric',\n      },\n      cacheDuration: {\n        type: 'number',\n        description: 'Cache duration in minutes',\n        default: 10,\n      },\n    },\n    required: ['weatherApiKey'],\n  },\n\n  async onLoad(runtime: IAgentRuntime) {\n    console.log('Weather plugin loaded');\n\n    // Validate configuration\n    if (!runtime.config.weatherApiKey) {\n      throw new Error('Weather API key is required');\n    }\n  },\n\n  async onUnload(runtime: IAgentRuntime) {\n    console.log('Weather plugin unloaded');\n\n    // Cleanup resources\n    const weatherService = runtime.getService('weather');\n    if (weatherService) {\n      await weatherService.stop();\n    }\n  },\n};\n"})}),"\n",(0,a.jsx)(e.h2,{id:"plugin-components",children:"Plugin Components"}),"\n",(0,a.jsx)(e.h3,{id:"1-actions",children:"1. Actions"}),"\n",(0,a.jsx)(e.p,{children:"Actions define how plugins respond to user input:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface Action {\n  name: string;\n  description: string;\n  examples: Example[];\n\n  // Validation\n  validate: (input: string, context: Context) => Promise<boolean>;\n\n  // Handler\n  handler: (params: ActionParams) => Promise<ActionResult>;\n\n  // Optional configuration\n  config?: {\n    priority?: number; // Execution priority\n    timeout?: number; // Execution timeout\n    rateLimit?: RateLimit; // Rate limiting\n    permissions?: string[]; // Required permissions\n  };\n}\n\n// Advanced action with middleware\nexport const advancedAction: Action = {\n  name: 'ADVANCED_ACTION',\n  description: 'Demonstrates advanced action features',\n\n  examples: [\n    {\n      input: 'Analyze this data',\n      output: 'Analysis complete',\n      context: { requiresAuth: true },\n    },\n  ],\n\n  validate: async (input: string, context: Context): Promise<boolean> => {\n    // Multi-stage validation\n    const checks = [\n      () => input.length > 0,\n      () => context.user?.authenticated === true,\n      async () => await checkUserPermissions(context.user, 'data:analyze'),\n    ];\n\n    for (const check of checks) {\n      if (!(await check())) return false;\n    }\n\n    return true;\n  },\n\n  handler: async ({ input, context, runtime }) => {\n    // Pre-processing\n    const startTime = Date.now();\n    runtime.logger.info('Starting advanced action', { input });\n\n    try {\n      // Main logic\n      const result = await performAnalysis(input);\n\n      // Post-processing\n      await runtime.emit('action:completed', {\n        action: 'ADVANCED_ACTION',\n        duration: Date.now() - startTime,\n        success: true,\n      });\n\n      return {\n        text: `Analysis complete: ${result.summary}`,\n        data: result,\n        metadata: {\n          processingTime: Date.now() - startTime,\n          confidence: result.confidence,\n        },\n      };\n    } catch (error) {\n      runtime.logger.error('Action failed', { error });\n\n      await runtime.emit('action:failed', {\n        action: 'ADVANCED_ACTION',\n        error: error.message,\n      });\n\n      throw error;\n    }\n  },\n\n  config: {\n    priority: 10,\n    timeout: 30000,\n    rateLimit: {\n      maxRequests: 10,\n      windowMs: 60000,\n    },\n    permissions: ['data:analyze'],\n  },\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-providers",children:"2. Providers"}),"\n",(0,a.jsx)(e.p,{children:"Providers supply dynamic context to the agent:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface Provider {\n  name: string;\n  description: string;\n\n  // Get current context\n  get: (runtime: IAgentRuntime) => Promise<any>;\n\n  // Optional: Subscribe to updates\n  subscribe?: (callback: (data: any) => void) => () => void;\n\n  // Optional: Cache configuration\n  cacheConfig?: {\n    ttl: number; // Time to live in ms\n    staleWhileRevalidate?: boolean;\n  };\n}\n\n// Real-time data provider\nexport const realtimeProvider: Provider = {\n  name: 'market-data',\n  description: 'Provides real-time market data',\n\n  get: async (runtime: IAgentRuntime) => {\n    const cache = runtime.getService('cache');\n    const cacheKey = 'market-data';\n\n    // Try cache first\n    const cached = await cache.get(cacheKey);\n    if (cached) return cached;\n\n    // Fetch fresh data\n    const marketData = await fetchMarketData();\n\n    // Update cache\n    await cache.set(cacheKey, marketData, { ttl: 60000 });\n\n    return marketData;\n  },\n\n  subscribe: (callback: (data: any) => void) => {\n    // Setup WebSocket connection\n    const ws = new WebSocket('wss://market-data.example.com');\n\n    ws.on('message', (data) => {\n      const parsed = JSON.parse(data);\n      callback(parsed);\n    });\n\n    // Return unsubscribe function\n    return () => {\n      ws.close();\n    };\n  },\n\n  cacheConfig: {\n    ttl: 60000,\n    staleWhileRevalidate: true,\n  },\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"3-evaluators",children:"3. Evaluators"}),"\n",(0,a.jsx)(e.p,{children:"Evaluators analyze and score messages:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface Evaluator {\n  name: string;\n  description: string;\n\n  // Evaluate message\n  evaluate: (params: EvaluatorParams) => Promise<EvaluatorResult>;\n\n  // Optional: Batch evaluation\n  evaluateBatch?: (messages: Message[]) => Promise<EvaluatorResult[]>;\n}\n\ninterface EvaluatorResult {\n  score: number; // 0-1 confidence score\n  passed: boolean; // Whether evaluation passed\n  metadata?: any; // Additional metadata\n}\n\n// Sentiment evaluator\nexport const sentimentEvaluator: Evaluator = {\n  name: 'sentiment',\n  description: 'Evaluates message sentiment',\n\n  evaluate: async ({ message, context, runtime }) => {\n    const sentiment = await analyzeSentiment(message.content);\n\n    // Track sentiment over time\n    await runtime.getService('analytics').track('sentiment', {\n      entityId: message.entityId,\n      sentiment: sentiment.score,\n      timestamp: new Date(),\n    });\n\n    return {\n      score: Math.abs(sentiment.score),\n      passed: sentiment.score > -0.5, // Not too negative\n      metadata: {\n        sentiment: sentiment.label,\n        confidence: sentiment.confidence,\n        aspects: sentiment.aspects,\n      },\n    };\n  },\n\n  evaluateBatch: async (messages: Message[]) => {\n    // Efficient batch processing\n    const texts = messages.map((m) => m.content);\n    const sentiments = await analyzeSentimentBatch(texts);\n\n    return sentiments.map((sentiment, i) => ({\n      score: Math.abs(sentiment.score),\n      passed: sentiment.score > -0.5,\n      metadata: {\n        messageId: messages[i].id,\n        sentiment: sentiment.label,\n      },\n    }));\n  },\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"4-services",children:"4. Services"}),"\n",(0,a.jsx)(e.p,{children:"Services provide shared functionality:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface Service {\n  name: string;\n\n  // Lifecycle methods\n  start: (runtime: IAgentRuntime) => Promise<void>;\n  stop: () => Promise<void>;\n\n  // Service methods (defined by implementation)\n  [key: string]: any;\n}\n\n// Database service example\nexport class DatabaseService implements Service {\n  name = 'database';\n  private pool: ConnectionPool;\n  private cache: CacheLayer;\n\n  async start(runtime: IAgentRuntime) {\n    // Initialize connection pool\n    this.pool = new ConnectionPool({\n      host: runtime.config.dbHost,\n      port: runtime.config.dbPort,\n      database: runtime.config.dbName,\n      max: 20,\n      idleTimeoutMillis: 30000,\n    });\n\n    // Initialize cache layer\n    this.cache = new CacheLayer({\n      ttl: 5 * 60 * 1000,\n      max: 1000,\n    });\n\n    // Test connection\n    await this.pool.query('SELECT 1');\n\n    runtime.logger.info('Database service started');\n  }\n\n  async stop() {\n    await this.pool.end();\n    this.cache.clear();\n  }\n\n  async query(sql: string, params?: any[]): Promise<any> {\n    const cacheKey = this.getCacheKey(sql, params);\n\n    // Check cache for SELECT queries\n    if (sql.trim().toUpperCase().startsWith('SELECT')) {\n      const cached = this.cache.get(cacheKey);\n      if (cached) return cached;\n    }\n\n    // Execute query\n    const result = await this.pool.query(sql, params);\n\n    // Cache SELECT results\n    if (sql.trim().toUpperCase().startsWith('SELECT')) {\n      this.cache.set(cacheKey, result.rows);\n    }\n\n    return result.rows;\n  }\n\n  async transaction(callback: (client: any) => Promise<any>): Promise<any> {\n    const client = await this.pool.connect();\n\n    try {\n      await client.query('BEGIN');\n      const result = await callback(client);\n      await client.query('COMMIT');\n      return result;\n    } catch (error) {\n      await client.query('ROLLBACK');\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  private getCacheKey(sql: string, params?: any[]): string {\n    return `${sql}:${JSON.stringify(params || [])}`;\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"plugin-lifecycle",children:"Plugin Lifecycle"}),"\n",(0,a.jsx)(e.h3,{id:"1-loading-process",children:"1. Loading Process"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"class PluginLoader {\n  async loadPlugin(pluginPath: string): Promise<Plugin> {\n    try {\n      // 1. Load plugin module\n      const module = await import(pluginPath);\n      const plugin = module.default || module;\n\n      // 2. Validate plugin structure\n      this.validatePlugin(plugin);\n\n      // 3. Check dependencies\n      await this.checkDependencies(plugin);\n\n      // 4. Initialize plugin\n      if (plugin.onLoad) {\n        await plugin.onLoad(this.runtime);\n      }\n\n      // 5. Register components\n      await this.registerComponents(plugin);\n\n      // 6. Start services\n      await this.startServices(plugin);\n\n      return plugin;\n    } catch (error) {\n      throw new PluginLoadError(`Failed to load plugin ${pluginPath}: ${error.message}`);\n    }\n  }\n\n  private validatePlugin(plugin: any): void {\n    if (!plugin.name || !plugin.version) {\n      throw new Error('Plugin must have name and version');\n    }\n\n    // Validate version format\n    if (!semver.valid(plugin.version)) {\n      throw new Error('Invalid plugin version format');\n    }\n\n    // Validate component arrays\n    const components = ['actions', 'providers', 'evaluators', 'services'];\n    for (const component of components) {\n      if (plugin[component] && !Array.isArray(plugin[component])) {\n        throw new Error(`Plugin ${component} must be an array`);\n      }\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-dependency-resolution",children:"2. Dependency Resolution"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"class DependencyResolver {\n  async resolve(plugins: Plugin[]): Promise<Plugin[]> {\n    const graph = this.buildDependencyGraph(plugins);\n    const sorted = this.topologicalSort(graph);\n\n    if (sorted === null) {\n      throw new Error('Circular dependency detected');\n    }\n\n    return sorted;\n  }\n\n  private buildDependencyGraph(plugins: Plugin[]): DependencyGraph {\n    const graph = new Map<string, Set<string>>();\n    const pluginMap = new Map(plugins.map((p) => [p.name, p]));\n\n    for (const plugin of plugins) {\n      const deps = new Set<string>();\n\n      // Add required dependencies\n      for (const dep of plugin.dependencies || []) {\n        if (!pluginMap.has(dep)) {\n          throw new Error(`Plugin ${plugin.name} depends on missing plugin ${dep}`);\n        }\n        deps.add(dep);\n      }\n\n      // Add optional dependencies if available\n      for (const dep of plugin.optionalDependencies || []) {\n        if (pluginMap.has(dep)) {\n          deps.add(dep);\n        }\n      }\n\n      graph.set(plugin.name, deps);\n    }\n\n    return graph;\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"3-hot-reloading",children:"3. Hot Reloading"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"class HotReloader {\n  private watchers = new Map<string, FSWatcher>();\n\n  async watchPlugin(pluginPath: string, plugin: Plugin): Promise<void> {\n    const watcher = watch(pluginPath, {\n      persistent: true,\n      ignoreInitial: true,\n    });\n\n    watcher.on('change', async () => {\n      try {\n        runtime.logger.info(`Reloading plugin ${plugin.name}`);\n\n        // Unload current version\n        await this.unloadPlugin(plugin);\n\n        // Clear module cache\n        delete require.cache[require.resolve(pluginPath)];\n\n        // Load new version\n        const newPlugin = await this.loadPlugin(pluginPath);\n\n        // Migrate state if needed\n        await this.migrateState(plugin, newPlugin);\n\n        runtime.logger.info(`Plugin ${plugin.name} reloaded successfully`);\n      } catch (error) {\n        runtime.logger.error(`Failed to reload plugin ${plugin.name}`, error);\n      }\n    });\n\n    this.watchers.set(plugin.name, watcher);\n  }\n\n  async stopWatching(pluginName: string): Promise<void> {\n    const watcher = this.watchers.get(pluginName);\n    if (watcher) {\n      await watcher.close();\n      this.watchers.delete(pluginName);\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"plugin-development",children:"Plugin Development"}),"\n",(0,a.jsx)(e.h3,{id:"1-typescript-plugin-template",children:"1. TypeScript Plugin Template"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"import { Plugin, IAgentRuntime, Action, Provider, Service } from '@elizaos/core';\n\ninterface MyPluginConfig {\n  apiKey: string;\n  endpoint?: string;\n  timeout?: number;\n}\n\nexport default class MyPlugin implements Plugin {\n  name = 'my-plugin';\n  version = '1.0.0';\n  description = 'My custom ElizaOS plugin';\n\n  private config: MyPluginConfig;\n  private runtime: IAgentRuntime;\n\n  actions = [this.createMyAction()];\n\n  providers = [this.createMyProvider()];\n\n  services = [this.createMyService()];\n\n  async onLoad(runtime: IAgentRuntime): Promise<void> {\n    this.runtime = runtime;\n    this.config = this.validateConfig(runtime.config);\n\n    // Initialize plugin\n    await this.initialize();\n  }\n\n  async onUnload(): Promise<void> {\n    // Cleanup resources\n    await this.cleanup();\n  }\n\n  private createMyAction(): Action {\n    return {\n      name: 'MY_ACTION',\n      description: 'Performs my custom action',\n      examples: [{ input: 'Do something', output: 'Something done!' }],\n\n      validate: async (input: string) => {\n        return input.toLowerCase().includes('something');\n      },\n\n      handler: async ({ input, runtime }) => {\n        const result = await this.performAction(input);\n        return {\n          text: `Action completed: ${result}`,\n          data: { result },\n        };\n      },\n    };\n  }\n\n  private createMyProvider(): Provider {\n    return {\n      name: 'my-context',\n      description: 'Provides my custom context',\n\n      get: async () => {\n        return {\n          timestamp: new Date(),\n          data: await this.fetchContextData(),\n        };\n      },\n    };\n  }\n\n  private createMyService(): Service {\n    const service = {\n      name: 'my-service',\n\n      async start(runtime: IAgentRuntime) {\n        // Initialize service\n      },\n\n      async stop() {\n        // Cleanup service\n      },\n\n      // Custom service methods\n      async doSomething(param: string) {\n        return `Did something with ${param}`;\n      },\n    };\n\n    return service;\n  }\n\n  private validateConfig(config: any): MyPluginConfig {\n    if (!config.myPluginApiKey) {\n      throw new Error('myPluginApiKey is required');\n    }\n\n    return {\n      apiKey: config.myPluginApiKey,\n      endpoint: config.myPluginEndpoint || 'https://api.example.com',\n      timeout: config.myPluginTimeout || 5000,\n    };\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-plugin-testing",children:"2. Plugin Testing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\nimport { createMockRuntime } from '@elizaos/testing';\nimport MyPlugin from './my-plugin';\n\ndescribe('MyPlugin', () => {\n  let runtime: MockRuntime;\n  let plugin: MyPlugin;\n\n  beforeEach(async () => {\n    runtime = createMockRuntime({\n      config: {\n        myPluginApiKey: 'test-key',\n      },\n    });\n\n    plugin = new MyPlugin();\n    await plugin.onLoad(runtime);\n  });\n\n  afterEach(async () => {\n    await plugin.onUnload();\n  });\n\n  describe('MY_ACTION', () => {\n    const action = plugin.actions[0];\n\n    it('should validate correct input', async () => {\n      const valid = await action.validate('Do something please');\n      expect(valid).toBe(true);\n    });\n\n    it('should reject invalid input', async () => {\n      const valid = await action.validate('Do nothing');\n      expect(valid).toBe(false);\n    });\n\n    it('should handle action correctly', async () => {\n      const result = await action.handler({\n        input: 'Do something cool',\n        runtime,\n        context: {},\n      });\n\n      expect(result.text).toContain('Action completed');\n      expect(result.data).toBeDefined();\n    });\n  });\n\n  describe('my-service', () => {\n    it('should provide service functionality', async () => {\n      const service = runtime.getService('my-service');\n      const result = await service.doSomething('test');\n\n      expect(result).toBe('Did something with test');\n    });\n  });\n});\n"})}),"\n",(0,a.jsx)(e.h3,{id:"3-plugin-publishing",children:"3. Plugin Publishing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-json",children:'// package.json\n{\n  "name": "@elizaos/plugin-my-plugin",\n  "version": "1.0.0",\n  "description": "My custom ElizaOS plugin",\n  "main": "dist/index.js",\n  "types": "dist/index.d.ts",\n  "files": ["dist", "README.md", "LICENSE"],\n  "scripts": {\n    "build": "tsc",\n    "test": "bun test",\n    "prepublish": "bun run build && bun run test"\n  },\n  "peerDependencies": {\n    "@elizaos/core": "^1.0.0"\n  },\n  "keywords": ["elizaos", "plugin", "ai", "agent"],\n  "author": "Your Name",\n  "license": "MIT"\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,a.jsx)(e.h3,{id:"1-plugin-composition",children:"1. Plugin Composition"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Compose multiple plugins into one\nexport function composePlugins(...plugins: Plugin[]): Plugin {\n  return {\n    name: 'composed-plugin',\n    version: '1.0.0',\n\n    actions: plugins.flatMap((p) => p.actions || []),\n    providers: plugins.flatMap((p) => p.providers || []),\n    evaluators: plugins.flatMap((p) => p.evaluators || []),\n    services: plugins.flatMap((p) => p.services || []),\n\n    async onLoad(runtime: IAgentRuntime) {\n      for (const plugin of plugins) {\n        if (plugin.onLoad) {\n          await plugin.onLoad(runtime);\n        }\n      }\n    },\n\n    async onUnload(runtime: IAgentRuntime) {\n      for (const plugin of plugins.reverse()) {\n        if (plugin.onUnload) {\n          await plugin.onUnload(runtime);\n        }\n      }\n    },\n  };\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-plugin-middleware",children:"2. Plugin Middleware"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Wrap plugin components with middleware\nexport function withLogging(action: Action): Action {\n  return {\n    ...action,\n    handler: async (params) => {\n      const start = Date.now();\n      params.runtime.logger.info(`Starting action ${action.name}`);\n\n      try {\n        const result = await action.handler(params);\n\n        params.runtime.logger.info(`Action ${action.name} completed`, {\n          duration: Date.now() - start,\n        });\n\n        return result;\n      } catch (error) {\n        params.runtime.logger.error(`Action ${action.name} failed`, {\n          error: error.message,\n          duration: Date.now() - start,\n        });\n\n        throw error;\n      }\n    },\n  };\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"3-plugin-communication",children:"3. Plugin Communication"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Inter-plugin communication via events\nexport class PluginEventBus {\n  private listeners = new Map<string, Set<Function>>();\n\n  emit(event: string, data: any): void {\n    const handlers = this.listeners.get(event);\n    if (handlers) {\n      handlers.forEach((handler) => {\n        try {\n          handler(data);\n        } catch (error) {\n          console.error(`Event handler error for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  on(event: string, handler: Function): () => void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n\n    this.listeners.get(event)!.add(handler);\n\n    // Return unsubscribe function\n    return () => {\n      this.listeners.get(event)?.delete(handler);\n    };\n  }\n}\n\n// Usage in plugins\nexport const pluginA: Plugin = {\n  name: 'plugin-a',\n\n  async onLoad(runtime: IAgentRuntime) {\n    // Emit event\n    runtime.emit('plugin-a:ready', { version: '1.0.0' });\n  },\n};\n\nexport const pluginB: Plugin = {\n  name: 'plugin-b',\n\n  async onLoad(runtime: IAgentRuntime) {\n    // Listen for plugin-a events\n    runtime.on('plugin-a:ready', (data) => {\n      console.log('Plugin A is ready:', data);\n    });\n  },\n};\n"})}),"\n",(0,a.jsx)(e.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,a.jsx)(e.h3,{id:"1-sandboxing",children:"1. Sandboxing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Run plugins in isolated contexts\nclass PluginSandbox {\n  async runInSandbox(plugin: Plugin, code: string): Promise<any> {\n    const vm = new VM({\n      timeout: 5000,\n      sandbox: {\n        // Allowed globals\n        console: console,\n        setTimeout: setTimeout,\n        clearTimeout: clearTimeout,\n\n        // Plugin API\n        runtime: this.createSafeRuntime(),\n\n        // Denied\n        process: undefined,\n        require: undefined,\n        __dirname: undefined,\n        __filename: undefined,\n      },\n    });\n\n    return vm.run(code);\n  }\n\n  private createSafeRuntime(): any {\n    return {\n      // Only expose safe methods\n      logger: {\n        info: (...args) => console.log(...args),\n        error: (...args) => console.error(...args),\n      },\n\n      config: {\n        // Only expose non-sensitive config\n        get: (key: string) => {\n          if (this.isSafeConfig(key)) {\n            return this.runtime.config[key];\n          }\n          return undefined;\n        },\n      },\n    };\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-permission-system",children:"2. Permission System"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Define plugin permissions\ninterface PluginPermissions {\n  actions?: string[]; // Allowed action names\n  services?: string[]; // Allowed service access\n  events?: string[]; // Allowed event emissions\n  config?: string[]; // Allowed config keys\n  network?: boolean; // Network access\n  filesystem?: boolean; // File system access\n}\n\nclass PermissionManager {\n  checkPermission(plugin: Plugin, permission: string, resource?: string): boolean {\n    const permissions = this.getPluginPermissions(plugin.name);\n\n    switch (permission) {\n      case 'service:access':\n        return permissions.services?.includes(resource!) ?? false;\n\n      case 'event:emit':\n        return permissions.events?.includes(resource!) ?? false;\n\n      case 'config:read':\n        return permissions.config?.includes(resource!) ?? false;\n\n      case 'network:request':\n        return permissions.network ?? false;\n\n      default:\n        return false;\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsx)(e.h3,{id:"1-lazy-loading",children:"1. Lazy Loading"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Load plugins on demand\nclass LazyPluginLoader {\n  private plugins = new Map<string, () => Promise<Plugin>>();\n  private loaded = new Map<string, Plugin>();\n\n  register(name: string, loader: () => Promise<Plugin>): void {\n    this.plugins.set(name, loader);\n  }\n\n  async get(name: string): Promise<Plugin | null> {\n    // Return if already loaded\n    if (this.loaded.has(name)) {\n      return this.loaded.get(name)!;\n    }\n\n    // Load if registered\n    const loader = this.plugins.get(name);\n    if (loader) {\n      const plugin = await loader();\n      this.loaded.set(name, plugin);\n      return plugin;\n    }\n\n    return null;\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-resource-pooling",children:"2. Resource Pooling"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Share resources between plugins\nclass ResourcePool {\n  private pools = new Map<string, any>();\n\n  async getConnection(type: string, config: any): Promise<any> {\n    const key = `${type}:${JSON.stringify(config)}`;\n\n    if (!this.pools.has(key)) {\n      const pool = await this.createPool(type, config);\n      this.pools.set(key, pool);\n    }\n\n    return this.pools.get(key);\n  }\n\n  private async createPool(type: string, config: any): Promise<any> {\n    switch (type) {\n      case 'database':\n        return new DatabasePool(config);\n      case 'redis':\n        return new RedisPool(config);\n      case 'http':\n        return new HttpClientPool(config);\n      default:\n        throw new Error(`Unknown pool type: ${type}`);\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Single Responsibility"}),": Each plugin should focus on one feature area"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Error Handling"}),": Always handle errors gracefully with fallbacks"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Resource Management"}),": Clean up resources in onUnload"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Configuration Validation"}),": Validate all configuration at load time"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Documentation"}),": Document all actions, providers, and services"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Testing"}),": Write comprehensive tests for all plugin components"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Versioning"}),": Follow semantic versioning for plugins"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Performance"}),": Consider caching and lazy loading for efficiency"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/docs/technical/architecture/core-concepts",children:"Core Concepts"})," - Fundamental ElizaOS concepts"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/docs/technical/architecture/state-management",children:"State Management"})," - Plugin state management"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/docs/technical/api-reference/actions-api",children:"Actions API"})," - Detailed Actions API"]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(u,{...n})}):u(n)}},71184:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>o});var t=i(14041);const a={},r=t.createContext(a);function s(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);