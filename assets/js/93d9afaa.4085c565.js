"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[68649],{52391:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"technical/architecture/service-layer","title":"Service Layer Architecture","description":"ElizaOS implements a comprehensive service layer that provides modular, reusable functionality for agents. Services handle external integrations, background processing, and shared system resources while maintaining clean separation of concerns.","source":"@site/docs/technical/architecture/service-layer.md","sourceDirName":"technical/architecture","slug":"/technical/architecture/service-layer","permalink":"/docs/technical/architecture/service-layer","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/docs/technical/architecture/service-layer.md","tags":[],"version":"current","lastUpdatedBy":"Sayo","lastUpdatedAt":1751802400000,"frontMatter":{}}');var t=r(31085),s=r(71184);const a={},c="Service Layer Architecture",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Service Architecture",id:"service-architecture",level:2},{value:"Service Interface",id:"service-interface",level:3},{value:"Service Type Registry",id:"service-type-registry",level:3},{value:"Service Registration and Access",id:"service-registration-and-access",level:3},{value:"Built-in Services",id:"built-in-services",level:2},{value:"Transcription Service",id:"transcription-service",level:3},{value:"Browser Service",id:"browser-service",level:3},{value:"Speech Service",id:"speech-service",level:3},{value:"Service Builder Pattern",id:"service-builder-pattern",level:2},{value:"Service Lifecycle Management",id:"service-lifecycle-management",level:2},{value:"Initialization Sequence",id:"initialization-sequence",level:3},{value:"Health Monitoring",id:"health-monitoring",level:3},{value:"Service Integration Patterns",id:"service-integration-patterns",level:2},{value:"Action-Service Integration",id:"action-service-integration",level:3},{value:"Provider-Service Integration",id:"provider-service-integration",level:3},{value:"Custom Service Development",id:"custom-service-development",level:2},{value:"Creating a Custom Service",id:"creating-a-custom-service",level:3},{value:"Service Registration in Plugins",id:"service-registration-in-plugins",level:3},{value:"Error Handling and Resilience",id:"error-handling-and-resilience",level:2},{value:"Service Circuit Breaker",id:"service-circuit-breaker",level:3},{value:"Service Retry Logic",id:"service-retry-logic",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"service-layer-architecture",children:"Service Layer Architecture"})}),"\n",(0,t.jsx)(n.p,{children:"ElizaOS implements a comprehensive service layer that provides modular, reusable functionality for agents. Services handle external integrations, background processing, and shared system resources while maintaining clean separation of concerns."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The service layer provides:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Modular Integration"})," - Pluggable services for different platforms and tools"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lifecycle Management"})," - Proper initialization, startup, and shutdown handling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dependency Injection"})," - Type-safe service access throughout the runtime"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Background Processing"})," - Long-running tasks and scheduled operations"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"service-architecture",children:"Service Architecture"}),"\n",(0,t.jsx)(n.h3,{id:"service-interface",children:"Service Interface"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/types/service.ts\n\ninterface Service {\n  name: string;\n  description?: string;\n  initialize?: (runtime: IAgentRuntime) => Promise<void>;\n  start?: (runtime: IAgentRuntime) => Promise<void>;\n  stop?: (runtime: IAgentRuntime) => Promise<void>;\n  [key: string]: any; // Additional service-specific methods and properties\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"service-type-registry",children:"Service Type Registry"}),"\n",(0,t.jsx)(n.p,{children:"ElizaOS uses a type-safe service registry system:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Service type definitions\ninterface ServiceTypeRegistry {\n  TRANSCRIPTION: 'transcription';\n  VIDEO: 'video';\n  BROWSER: 'browser';\n  SPEECH: 'speech';\n  IMAGE_RECOGNITION: 'image_recognition';\n  PDF: 'pdf';\n  // Extensible via module augmentation\n}\n\ntype ServiceType = ServiceTypeRegistry[keyof ServiceTypeRegistry];\n"})}),"\n",(0,t.jsx)(n.h3,{id:"service-registration-and-access",children:"Service Registration and Access"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/runtime.ts\n\nclass AgentRuntime implements IAgentRuntime {\n  private services = new Map<ServiceType, Service>();\n\n  // Register a service with the runtime\n  registerService(serviceType: ServiceType, service: Service): void {\n    this.services.set(serviceType, service);\n  }\n\n  // Type-safe service access\n  getService<T extends Service>(serviceType: ServiceType): T | null {\n    return (this.services.get(serviceType) as T) || null;\n  }\n\n  // Get all registered services\n  getServices(): Map<ServiceType, Service> {\n    return new Map(this.services);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"built-in-services",children:"Built-in Services"}),"\n",(0,t.jsx)(n.h3,{id:"transcription-service",children:"Transcription Service"}),"\n",(0,t.jsx)(n.p,{children:"Handles audio-to-text conversion:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// packages/plugin-node/src/services/transcription.ts\n\ninterface TranscriptionService extends Service {\n  transcribe(audioBuffer: Buffer, options?: TranscriptionOptions): Promise<string>;\n  getSupportedFormats(): string[];\n  isConfigured(): boolean;\n}\n\nclass WhisperTranscriptionService implements TranscriptionService {\n  name = 'whisper-transcription';\n  description = 'OpenAI Whisper-based audio transcription';\n\n  async initialize(runtime: IAgentRuntime): Promise<void> {\n    // Initialize Whisper model or API client\n    this.validateConfiguration();\n  }\n\n  async transcribe(audioBuffer: Buffer, options?: TranscriptionOptions): Promise<string> {\n    try {\n      // Convert audio buffer to format expected by Whisper\n      const audioFile = await this.prepareAudioFile(audioBuffer);\n\n      // Call Whisper API or local model\n      const response = await this.callWhisperAPI(audioFile, options);\n\n      return response.text;\n    } catch (error) {\n      console.error('Transcription failed:', error);\n      throw new Error(`Transcription service error: ${error.message}`);\n    }\n  }\n\n  getSupportedFormats(): string[] {\n    return ['mp3', 'wav', 'ogg', 'm4a', 'webm'];\n  }\n\n  isConfigured(): boolean {\n    return !!process.env.OPENAI_API_KEY;\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"browser-service",children:"Browser Service"}),"\n",(0,t.jsx)(n.p,{children:"Provides web browsing and content extraction:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// packages/plugin-node/src/services/browser.ts\n\ninterface BrowserService extends Service {\n  browse(url: string, options?: BrowseOptions): Promise<BrowseResult>;\n  screenshot(url: string, options?: ScreenshotOptions): Promise<Buffer>;\n  extractText(url: string): Promise<string>;\n  close(): Promise<void>;\n}\n\nclass PuppeteerBrowserService implements BrowserService {\n  name = 'puppeteer-browser';\n  description = 'Puppeteer-based web browsing service';\n\n  private browser: Browser | null = null;\n\n  async initialize(runtime: IAgentRuntime): Promise<void> {\n    // Launch browser instance\n    this.browser = await puppeteer.launch({\n      headless: true,\n      args: ['--no-sandbox', '--disable-setuid-sandbox'],\n    });\n  }\n\n  async browse(url: string, options: BrowseOptions = {}): Promise<BrowseResult> {\n    if (!this.browser) {\n      throw new Error('Browser service not initialized');\n    }\n\n    const page = await this.browser.newPage();\n\n    try {\n      // Configure page settings\n      await page.setViewport({ width: 1920, height: 1080 });\n      await page.setUserAgent(options.userAgent || this.getDefaultUserAgent());\n\n      // Navigate to URL\n      const response = await page.goto(url, {\n        waitUntil: options.waitUntil || 'domcontentloaded',\n        timeout: options.timeout || 30000,\n      });\n\n      // Extract content based on options\n      const result: BrowseResult = {\n        url: page.url(),\n        title: await page.title(),\n        text: await this.extractPageText(page, options),\n        html: options.includeHtml ? await page.content() : undefined,\n        screenshot: options.screenshot ? await page.screenshot() : undefined,\n        statusCode: response?.status(),\n        links: options.extractLinks ? await this.extractLinks(page) : undefined,\n      };\n\n      return result;\n    } finally {\n      await page.close();\n    }\n  }\n\n  async stop(): Promise<void> {\n    if (this.browser) {\n      await this.browser.close();\n      this.browser = null;\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"speech-service",children:"Speech Service"}),"\n",(0,t.jsx)(n.p,{children:"Handles text-to-speech conversion:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// packages/plugin-node/src/services/speech.ts\n\ninterface SpeechService extends Service {\n  speak(text: string, options?: SpeechOptions): Promise<Buffer>;\n  getVoices(): Promise<Voice[]>;\n  setVoice(voiceId: string): void;\n}\n\nclass ElevenLabsSpeechService implements SpeechService {\n  name = 'elevenlabs-speech';\n  description = 'ElevenLabs text-to-speech service';\n\n  private selectedVoice: string = 'default';\n\n  async speak(text: string, options: SpeechOptions = {}): Promise<Buffer> {\n    const voice = options.voice || this.selectedVoice;\n\n    try {\n      const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voice}`, {\n        method: 'POST',\n        headers: {\n          Accept: 'audio/mpeg',\n          'Content-Type': 'application/json',\n          'xi-api-key': process.env.ELEVENLABS_API_KEY!,\n        },\n        body: JSON.stringify({\n          text,\n          model_id: options.model || 'eleven_monolingual_v1',\n          voice_settings: {\n            stability: options.stability || 0.5,\n            similarity_boost: options.similarity_boost || 0.5,\n          },\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Speech synthesis failed: ${response.statusText}`);\n      }\n\n      return Buffer.from(await response.arrayBuffer());\n    } catch (error) {\n      console.error('Speech synthesis error:', error);\n      throw error;\n    }\n  }\n\n  async getVoices(): Promise<Voice[]> {\n    const response = await fetch('https://api.elevenlabs.io/v1/voices', {\n      headers: {\n        'xi-api-key': process.env.ELEVENLABS_API_KEY!,\n      },\n    });\n\n    const data = await response.json();\n    return data.voices.map((voice: any) => ({\n      id: voice.voice_id,\n      name: voice.name,\n      category: voice.category,\n      description: voice.description,\n    }));\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"service-builder-pattern",children:"Service Builder Pattern"}),"\n",(0,t.jsx)(n.p,{children:"ElizaOS provides a fluent builder API for creating services:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/service.ts\n\ninterface ServiceBuilder {\n  withName(name: string): ServiceBuilder;\n  withDescription(description: string): ServiceBuilder;\n  withInitialize(fn: (runtime: IAgentRuntime) => Promise<void>): ServiceBuilder;\n  withStart(fn: (runtime: IAgentRuntime) => Promise<void>): ServiceBuilder;\n  withStop(fn: (runtime: IAgentRuntime) => Promise<void>): ServiceBuilder;\n  withMethod(name: string, fn: Function): ServiceBuilder;\n  build(): Service;\n}\n\nfunction createService(type: ServiceType): ServiceBuilder {\n  const service: Partial<Service> = {};\n\n  return {\n    withName(name: string): ServiceBuilder {\n      service.name = name;\n      return this;\n    },\n\n    withDescription(description: string): ServiceBuilder {\n      service.description = description;\n      return this;\n    },\n\n    withInitialize(fn: (runtime: IAgentRuntime) => Promise<void>): ServiceBuilder {\n      service.initialize = fn;\n      return this;\n    },\n\n    withStart(fn: (runtime: IAgentRuntime) => Promise<void>): ServiceBuilder {\n      service.start = fn;\n      return this;\n    },\n\n    withStop(fn: (runtime: IAgentRuntime) => Promise<void>): ServiceBuilder {\n      service.stop = fn;\n      return this;\n    },\n\n    withMethod(name: string, fn: Function): ServiceBuilder {\n      (service as any)[name] = fn;\n      return this;\n    },\n\n    build(): Service {\n      if (!service.name) {\n        throw new Error('Service name is required');\n      }\n      return service as Service;\n    },\n  };\n}\n\n// Usage example\nconst customService = createService('custom')\n  .withName('my-custom-service')\n  .withDescription('A custom service for specific functionality')\n  .withInitialize(async (runtime) => {\n    console.log('Initializing custom service');\n  })\n  .withMethod('customMethod', async (data: any) => {\n    return `Processed: ${data}`;\n  })\n  .build();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"service-lifecycle-management",children:"Service Lifecycle Management"}),"\n",(0,t.jsx)(n.h3,{id:"initialization-sequence",children:"Initialization Sequence"}),"\n",(0,t.jsx)(n.p,{children:"Services are initialized in a specific order during runtime startup:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/runtime.ts\n\nclass AgentRuntime {\n  async initializeServices(): Promise<void> {\n    const services = Array.from(this.services.entries());\n\n    // Initialize services sequentially to handle dependencies\n    for (const [serviceType, service] of services) {\n      try {\n        if (service.initialize) {\n          console.log(`Initializing service: ${service.name}`);\n          await service.initialize(this);\n        }\n      } catch (error) {\n        console.error(`Failed to initialize service ${service.name}:`, error);\n        // Decide whether to continue or fail fast based on service criticality\n        if (this.isCriticalService(serviceType)) {\n          throw error;\n        }\n      }\n    }\n  }\n\n  async startServices(): Promise<void> {\n    const services = Array.from(this.services.values());\n\n    // Start services in parallel since they should be independent\n    await Promise.allSettled(\n      services.map(async (service) => {\n        if (service.start) {\n          try {\n            console.log(`Starting service: ${service.name}`);\n            await service.start(this);\n          } catch (error) {\n            console.error(`Failed to start service ${service.name}:`, error);\n          }\n        }\n      })\n    );\n  }\n\n  async stopServices(): Promise<void> {\n    const services = Array.from(this.services.values());\n\n    // Stop services in parallel for faster shutdown\n    await Promise.allSettled(\n      services.map(async (service) => {\n        if (service.stop) {\n          try {\n            console.log(`Stopping service: ${service.name}`);\n            await service.stop(this);\n          } catch (error) {\n            console.error(`Failed to stop service ${service.name}:`, error);\n          }\n        }\n      })\n    );\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"health-monitoring",children:"Health Monitoring"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface ServiceHealth {\n  name: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  lastCheck: Date;\n  error?: string;\n  metrics?: {\n    uptime: number;\n    requestCount: number;\n    errorRate: number;\n    averageResponseTime: number;\n  };\n}\n\nclass ServiceHealthMonitor {\n  private healthChecks = new Map<string, () => Promise<ServiceHealth>>();\n\n  registerHealthCheck(serviceName: string, check: () => Promise<ServiceHealth>): void {\n    this.healthChecks.set(serviceName, check);\n  }\n\n  async checkAllServices(): Promise<ServiceHealth[]> {\n    const results: ServiceHealth[] = [];\n\n    for (const [serviceName, check] of this.healthChecks) {\n      try {\n        const health = await check();\n        results.push(health);\n      } catch (error) {\n        results.push({\n          name: serviceName,\n          status: 'unhealthy',\n          lastCheck: new Date(),\n          error: error.message,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  async getServiceHealth(serviceName: string): Promise<ServiceHealth | null> {\n    const check = this.healthChecks.get(serviceName);\n    if (!check) return null;\n\n    try {\n      return await check();\n    } catch (error) {\n      return {\n        name: serviceName,\n        status: 'unhealthy',\n        lastCheck: new Date(),\n        error: error.message,\n      };\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"service-integration-patterns",children:"Service Integration Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"action-service-integration",children:"Action-Service Integration"}),"\n",(0,t.jsx)(n.p,{children:"Services are commonly used within actions to provide functionality:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Example: Transcription action using transcription service\nconst transcribeAction: Action = {\n  name: 'TRANSCRIBE_AUDIO',\n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    // Check if message has audio attachment\n    const hasAudio = message.content.attachments?.some((att) => att.type === 'audio');\n\n    // Check if transcription service is available\n    const transcriptionService = runtime.getService<TranscriptionService>('transcription');\n\n    return hasAudio && transcriptionService?.isConfigured();\n  },\n\n  handler: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {\n    const transcriptionService = runtime.getService<TranscriptionService>('transcription');\n    if (!transcriptionService) {\n      throw new Error('Transcription service not available');\n    }\n\n    // Find audio attachment\n    const audioAttachment = message.content.attachments?.find((att) => att.type === 'audio');\n\n    if (!audioAttachment) {\n      return false;\n    }\n\n    try {\n      // Transcribe audio\n      const transcription = await transcriptionService.transcribe(audioAttachment.data, {\n        language: 'en',\n      });\n\n      // Store transcription as memory\n      await runtime.memory.create({\n        ...message,\n        content: {\n          text: transcription,\n          metadata: {\n            source: 'transcription',\n            originalAudio: audioAttachment.id,\n          },\n        },\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Transcription failed:', error);\n      return false;\n    }\n  },\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"provider-service-integration",children:"Provider-Service Integration"}),"\n",(0,t.jsx)(n.p,{children:"Providers can use services to enhance state composition:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Example: Web content provider using browser service\nconst webContentProvider: Provider = {\n  get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\n    const browserService = runtime.getService<BrowserService>('browser');\n    if (!browserService) {\n      return null;\n    }\n\n    // Extract URLs from message\n    const urls = extractUrls(message.content.text);\n    if (urls.length === 0) {\n      return null;\n    }\n\n    try {\n      // Browse first URL and extract content\n      const result = await browserService.browse(urls[0], {\n        extractText: true,\n        timeout: 10000,\n      });\n\n      return {\n        text: `Web content from ${result.url}:\\n${result.text}`,\n        data: {\n          webContent: {\n            url: result.url,\n            title: result.title,\n            text: result.text,\n          },\n        },\n      };\n    } catch (error) {\n      console.error('Failed to browse URL:', error);\n      return null;\n    }\n  },\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"custom-service-development",children:"Custom Service Development"}),"\n",(0,t.jsx)(n.h3,{id:"creating-a-custom-service",children:"Creating a Custom Service"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Example: Database cleanup service\ninterface DatabaseCleanupService extends Service {\n  scheduleCleanup(interval: number): void;\n  runCleanup(): Promise<void>;\n  getCleanupStats(): CleanupStats;\n}\n\nclass DatabaseCleanupServiceImpl implements DatabaseCleanupService {\n  name = 'database-cleanup';\n  description = 'Automated database maintenance and cleanup';\n\n  private cleanupInterval: NodeJS.Timeout | null = null;\n  private stats: CleanupStats = {\n    lastRun: null,\n    recordsDeleted: 0,\n    spaceSaved: 0,\n  };\n\n  async initialize(runtime: IAgentRuntime): Promise<void> {\n    console.log('Initializing database cleanup service');\n    // Set up default cleanup schedule (daily)\n    this.scheduleCleanup(24 * 60 * 60 * 1000);\n  }\n\n  async start(runtime: IAgentRuntime): Promise<void> {\n    console.log('Database cleanup service started');\n  }\n\n  async stop(runtime: IAgentRuntime): Promise<void> {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n    console.log('Database cleanup service stopped');\n  }\n\n  scheduleCleanup(interval: number): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n\n    this.cleanupInterval = setInterval(async () => {\n      try {\n        await this.runCleanup();\n      } catch (error) {\n        console.error('Scheduled cleanup failed:', error);\n      }\n    }, interval);\n  }\n\n  async runCleanup(): Promise<void> {\n    const startTime = Date.now();\n    let deletedRecords = 0;\n\n    try {\n      // Clean up old memories (older than 30 days)\n      const cutoffDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n      deletedRecords += await this.cleanupOldMemories(cutoffDate);\n\n      // Clean up orphaned entities\n      deletedRecords += await this.cleanupOrphanedEntities();\n\n      // Clean up unused embeddings\n      deletedRecords += await this.cleanupUnusedEmbeddings();\n\n      // Update stats\n      this.stats = {\n        lastRun: new Date(),\n        recordsDeleted: this.stats.recordsDeleted + deletedRecords,\n        spaceSaved: this.estimateSpaceSaved(deletedRecords),\n      };\n\n      console.log(\n        `Cleanup completed: ${deletedRecords} records deleted in ${Date.now() - startTime}ms`\n      );\n    } catch (error) {\n      console.error('Database cleanup failed:', error);\n      throw error;\n    }\n  }\n\n  getCleanupStats(): CleanupStats {\n    return { ...this.stats };\n  }\n\n  private async cleanupOldMemories(cutoffDate: Date): Promise<number> {\n    // Implementation would depend on the database adapter\n    // This is a simplified example\n    return 0;\n  }\n\n  private async cleanupOrphanedEntities(): Promise<number> {\n    return 0;\n  }\n\n  private async cleanupUnusedEmbeddings(): Promise<number> {\n    return 0;\n  }\n\n  private estimateSpaceSaved(recordsDeleted: number): number {\n    // Rough estimate: 1KB per record\n    return recordsDeleted * 1024;\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"service-registration-in-plugins",children:"Service Registration in Plugins"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Plugin that provides custom services\nconst cleanupPlugin: Plugin = {\n  name: 'database-cleanup',\n  description: 'Provides automated database maintenance',\n\n  services: [\n    {\n      name: 'database-cleanup',\n      service: new DatabaseCleanupServiceImpl(),\n    },\n  ],\n\n  actions: [],\n  evaluators: [],\n  providers: [],\n};\n\n// Register plugin with runtime\nruntime.registerPlugin(cleanupPlugin);\n\n// Access the service\nconst cleanupService = runtime.getService<DatabaseCleanupService>('database-cleanup');\nif (cleanupService) {\n  await cleanupService.runCleanup();\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling-and-resilience",children:"Error Handling and Resilience"}),"\n",(0,t.jsx)(n.h3,{id:"service-circuit-breaker",children:"Service Circuit Breaker"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class ServiceCircuitBreaker {\n  private failures = new Map<string, number>();\n  private lastFailure = new Map<string, number>();\n  private readonly threshold = 5;\n  private readonly timeout = 60000; // 1 minute\n\n  async execute<T>(serviceName: string, operation: () => Promise<T>): Promise<T> {\n    const failures = this.failures.get(serviceName) || 0;\n    const lastFailure = this.lastFailure.get(serviceName) || 0;\n\n    // Check if circuit is open\n    if (failures >= this.threshold) {\n      if (Date.now() - lastFailure < this.timeout) {\n        throw new Error(`Service ${serviceName} is temporarily unavailable`);\n      }\n      // Reset circuit after timeout\n      this.failures.set(serviceName, 0);\n    }\n\n    try {\n      const result = await operation();\n      // Reset failures on success\n      this.failures.set(serviceName, 0);\n      return result;\n    } catch (error) {\n      // Track failure\n      this.failures.set(serviceName, failures + 1);\n      this.lastFailure.set(serviceName, Date.now());\n      throw error;\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"service-retry-logic",children:"Service Retry Logic"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class ServiceRetryHandler {\n  async withRetry<T>(\n    operation: () => Promise<T>,\n    options: {\n      maxRetries?: number;\n      delay?: number;\n      backoff?: 'linear' | 'exponential';\n    } = {}\n  ): Promise<T> {\n    const maxRetries = options.maxRetries || 3;\n    const baseDelay = options.delay || 1000;\n    const backoff = options.backoff || 'exponential';\n\n    let lastError: Error;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error;\n\n        if (attempt === maxRetries) {\n          break;\n        }\n\n        // Calculate delay\n        const delay =\n          backoff === 'exponential' ? baseDelay * Math.pow(2, attempt) : baseDelay * (attempt + 1);\n\n        console.log(\n          `Operation failed, retrying in ${delay}ms (attempt ${attempt + 1}/${maxRetries})`\n        );\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n\n    throw lastError;\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This service layer architecture provides ElizaOS with a robust, extensible foundation for integrating external systems and managing background operations while maintaining clean separation of concerns and proper lifecycle management."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},71184:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var i=r(14041);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);