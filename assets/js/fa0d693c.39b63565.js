"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[93985],{34163:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"core/evaluators","title":"\ud83d\udcca Evaluators","description":"Evaluators are core components that assess and extract information from conversations. Agents use evaluators to automatically process conversations after they happen to help build up their knowledge and understanding over time.","source":"@site/versioned_docs/version-0.25.9/core/evaluators.md","sourceDirName":"core","slug":"/core/evaluators","permalink":"/docs/0.25.9/core/evaluators","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/develop/packages/docs/versioned_docs/version-0.25.9/core/evaluators.md","tags":[],"version":"0.25.9","lastUpdatedBy":"madjin","lastUpdatedAt":1742171474000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Actions","permalink":"/docs/0.25.9/core/actions"},"next":{"title":"Database Adapters","permalink":"/docs/0.25.9/core/database"}}');var o=t(31085),s=t(71184);const r={sidebar_position:5},i="\ud83d\udcca Evaluators",l={},c=[{value:"How They Work",id:"how-they-work",level:2},{value:"Common Uses",id:"common-uses",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Core Interface",id:"core-interface",level:3},{value:"Validation Function",id:"validation-function",level:3},{value:"Handler Function",id:"handler-function",level:3},{value:"Memory Integration",id:"memory-integration",level:3},{value:"Fact Evaluator",id:"fact-evaluator",level:2},{value:"Example Facts",id:"example-facts",level:4},{value:"Goal Evaluator",id:"goal-evaluator",level:2},{value:"Example Goals",id:"example-goals",level:4},{value:"FAQ",id:"faq",level:2},{value:"How do evaluators differ from providers?",id:"how-do-evaluators-differ-from-providers",level:3},{value:"Can evaluators modify agent behavior?",id:"can-evaluators-modify-agent-behavior",level:3},{value:"How many evaluators can run simultaneously?",id:"how-many-evaluators-can-run-simultaneously",level:3},{value:"Can evaluators communicate with each other?",id:"can-evaluators-communicate-with-each-other",level:3},{value:"How are evaluation results persisted?",id:"how-are-evaluation-results-persisted",level:3},{value:"What&#39;s the difference between similes and examples in evaluators?",id:"whats-the-difference-between-similes-and-examples-in-evaluators",level:3},{value:"Can evaluators be conditionally enabled?",id:"can-evaluators-be-conditionally-enabled",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"-evaluators",children:"\ud83d\udcca Evaluators"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/api/interfaces/evaluator",children:"Evaluators"})," are core components that assess and extract information from conversations. Agents use evaluators to automatically process conversations after they happen to help build up their knowledge and understanding over time."]}),"\n",(0,o.jsxs)(n.p,{children:["They integrate with the ",(0,o.jsx)(n.a,{href:"/api/classes/AgentRuntime",children:(0,o.jsx)(n.code,{children:"AgentRuntime"})})," evaluation system to enable reflection, fact-gathering, and behavioral adaptation and run after each agent action to help maintain contextural awareness. Enabling agents to reflect on their actions and world state is crucial for improving coherence and problem-solving abilities. For example, by reflecting on its performance, an agent can refine its strategies and improve its interactions over time."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"how-they-work",children:"How They Work"}),"\n",(0,o.jsx)(n.p,{children:"Evaluators run automatically after each agent action (responses, messages, activities, or API calls) to analyze what happened and update the agent's understanding. They extract important information (like facts about users), track progress on goals, and learn from interactions."}),"\n",(0,o.jsx)(n.p,{children:"Let's say you're at a party and meet someone new. During the conversation:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"You learn their name is Sarah"}),"\n",(0,o.jsx)(n.li,{children:"They mention living in Seattle"}),"\n",(0,o.jsx)(n.li,{children:"They work as a software engineer"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"After the conversation, your brain:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Stores these facts for later"}),"\n",(0,o.jsx)(n.li,{children:"Updates your understanding of who Sarah is"}),"\n",(0,o.jsx)(n.li,{children:'Might note "I should connect Sarah with Bob who\'s also in tech"'}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This is exactly how evaluators work for agents - they run in the background to extract insights, track progress, and build up the agent's knowledge over time. However there are some limitations, such as evaluators only process current interactions (can't modify past data), they run after actions complete (not during). Therefore evaluators are best for analysis rather than critical operations."}),"\n",(0,o.jsx)(n.p,{children:"The key thing to remember is: evaluators are your agent's way of learning and growing from each interaction, just like how we naturally process and learn from our conversations."}),"\n",(0,o.jsx)(n.h3,{id:"common-uses",children:"Common Uses"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"https://github.com/elizaOS/eliza/blob/main/packages/plugin-bootstrap/src/evaluators/fact.ts",children:"Fact Evaluator"})}),": Learns and remembers facts about users"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"https://raw.githubusercontent.com/elizaOS/eliza/refs/heads/main/packages/plugin-bootstrap/src/evaluators/goal.ts",children:"Goal Evaluator"})}),": Tracks progress on objectives"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Trust Evaluator"}),": Builds understanding of relationships"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sentiment Evaluator"}),": Tracks emotional tone of conversations"]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,o.jsx)(n.p,{children:"Here's a basic example of an evaluator implementation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const evaluator = {\n  // Should this evaluator run right now?\n  validate: async (runtime, message) => {\n    // Return true to run, false to skip\n    return shouldRunThisTime;\n  },\n\n  // What to do when it runs\n  handler: async (runtime, message) => {\n    // Extract info, update memory, etc\n    const newInfo = extractFromMessage(message);\n    await storeInMemory(newInfo);\n  },\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"core-interface",children:"Core Interface"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface Evaluator {\n  name: string; // Unique identifier\n  similes: string[]; // Similar evaluator descriptions\n  description: string; // Purpose and functionality\n  validate: (runtime: IAgentRuntime, message: Memory) => Promise<boolean>;\n  handler: (runtime: IAgentRuntime, message: Memory) => Promise<any>;\n  examples: EvaluatorExample[];\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["For full type definitions, see the ",(0,o.jsx)(n.a,{href:"/api/interfaces/Evaluator",children:(0,o.jsx)(n.code,{children:"Evaluator"})})," interface documentation."]}),"\n",(0,o.jsx)(n.h3,{id:"validation-function",children:"Validation Function"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"validate"})," function is critical for determining when an evaluator should run. For peak performance, proper validation ensures evaluators run only when necessary. For instance, a customer service agent might check if all required user data has been collected and only run if data is still missing."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"validate: async (runtime: IAgentRuntime, message: Memory) => boolean;\n"})}),"\n",(0,o.jsx)(n.p,{children:"Determines if evaluator should run for current message. Returns true to execute handler, false to skip. Should be efficient and quick to check."}),"\n",(0,o.jsx)(n.h3,{id:"handler-function",children:"Handler Function"}),"\n",(0,o.jsx)(n.p,{children:"The handler function contains the evaluator's code. It is where the logic for analyzing data, extracting information, and triggering actions resides."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"handler: async (runtime: IAgentRuntime, message: Memory) => any;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Contains main evaluation logic and runs when validate() returns true. Can access ",(0,o.jsx)(n.a,{href:"/api/interfaces/IAgentRuntime",children:(0,o.jsx)(n.code,{children:"runtime"})})," services and ",(0,o.jsx)(n.a,{href:"/api/interfaces/Memory",children:(0,o.jsx)(n.code,{children:"memory"})}),"."]}),"\n",(0,o.jsxs)(n.admonition,{type:"tip",children:[(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Ensure Evaluators are unique and lightweight"})}),(0,o.jsx)(n.p,{children:"Avoid complex operations or lengthy computations within the evaluator's handler function and ensure that evaluators have clear and distinct responsibilities not already handled by other components for peak performance."})]}),"\n",(0,o.jsx)(n.h3,{id:"memory-integration",children:"Memory Integration"}),"\n",(0,o.jsx)(n.p,{children:"Results are stored using runtime memory managers:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// Example storing evaluation results\nconst memory = await runtime.memoryManager.addEmbeddingToMemory({\n  userId: user?.id,\n  content: { text: evaluationResult },\n  roomId: roomId,\n  embedding: await embed(runtime, evaluationResult),\n});\n\nawait runtime.memoryManager.createMemory(memory);\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"fact-evaluator",children:"Fact Evaluator"}),"\n",(0,o.jsxs)(n.p,{children:[":::info Deep Dive\nFor a comprehensive guide on how the fact evaluator system works, including implementation details and best practices, check out our ",(0,o.jsx)(n.a,{href:"/docs/0.25.9/core/fact-evaluator",children:"Fact Evaluator Guide"}),".\n:::"]}),"\n",(0,o.jsx)(n.p,{children:"The Fact Evaluator is one of the most powerful built-in evaluators. It processes convos to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Extract meaningful facts and opinions about users and the world"}),"\n",(0,o.jsx)(n.li,{children:"Distinguish between permanent facts, opinions, and status"}),"\n",(0,o.jsx)(n.li,{children:"Track what information is already known vs new information"}),"\n",(0,o.jsx)(n.li,{children:"Build up the agent's understanding over time through embeddings and memory storage"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Facts are stored with the following structure:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface Fact {\n  claim: string; // The actual information extracted\n  type: 'fact' | 'opinion' | 'status'; // Classification of the information\n  in_bio: boolean; // Whether this info is already in the agent's knowledge\n  already_known: boolean; // Whether this was previously extracted\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"example-facts",children:"Example Facts"}),"\n",(0,o.jsx)(n.p,{children:"Here's an example of extracted facts from a conversation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"User: I finally finished my marathon training program!\nAgent: That's a huge accomplishment! How do you feel about it?\nUser: I'm really proud of what I achieved. It was tough but worth it.\nAgent: What's next for you?\nUser: I'm actually training for a triathlon now. It's a whole new challenge.\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const extractedFacts = [\n  {\n    claim: 'User completed marathon training',\n    type: 'fact', // Permanent info / achievement\n    in_bio: false,\n    already_known: false, // Prevents duplicate storage\n  },\n  {\n    claim: 'User feels proud of their achievement',\n    type: 'opinion', // Subjective views or feelings\n    in_bio: false,\n    already_known: false,\n  },\n  {\n    claim: 'User is currently training for a triathlon',\n    type: 'status', // Ongoing activity, changeable\n    in_bio: false,\n    already_known: false,\n  },\n];\n"})}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"View Full Fact Evaluator Implementation"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"import { composeContext } from '@elizaos/core';\nimport { generateObjectArray } from '@elizaos/core';\nimport { MemoryManager } from '@elizaos/core';\nimport {\n  type ActionExample,\n  type IAgentRuntime,\n  type Memory,\n  ModelClass,\n  type Evaluator,\n} from '@elizaos/core';\n\nexport const formatFacts = (facts: Memory[]) => {\n  const messageStrings = facts.reverse().map((fact: Memory) => fact.content.text);\n  const finalMessageStrings = messageStrings.join('\\n');\n  return finalMessageStrings;\n};\n\nconst factsTemplate =\n  // {{actors}}\n  `TASK: Extract Claims from the conversation as an array of claims in JSON format.\n\n# START OF EXAMPLES\nThese are examples of the expected output of this task:\n{{evaluationExamples}}\n# END OF EXAMPLES\n\n# INSTRUCTIONS\n\nExtract any claims from the conversation that are not already present in the list of known facts above:\n- Try not to include already-known facts. If you think a fact is already known, but you're not sure, respond with already_known: true.\n- If the fact is already in the user's description, set in_bio to true\n- If we've already extracted this fact, set already_known to true\n- Set the claim type to 'status', 'fact' or 'opinion'\n- For true facts about the world or the character that do not change, set the claim type to 'fact'\n- For facts that are true but change over time, set the claim type to 'status'\n- For non-facts, set the type to 'opinion'\n- 'opinion' includes non-factual opinions and also includes the character's thoughts, feelings, judgments or recommendations\n- Include any factual detail, including where the user lives, works, or goes to school, what they do for a living, their hobbies, and any other relevant information\n\nRecent Messages:\n{{recentMessages}}\n\nResponse should be a JSON object array inside a JSON markdown block. Correct response format:\n\\`\\`\\`json\n[\n  {\"claim\": string, \"type\": enum<fact|opinion|status>, in_bio: boolean, already_known: boolean },\n  {\"claim\": string, \"type\": enum<fact|opinion|status>, in_bio: boolean, already_known: boolean },\n  ...\n]\n\\`\\`\\``;\n\nasync function handler(runtime: IAgentRuntime, message: Memory) {\n  const state = await runtime.composeState(message);\n\n  const { agentId, roomId } = state;\n\n  const context = composeContext({\n    state,\n    template: runtime.character.templates?.factsTemplate || factsTemplate,\n  });\n\n  const facts = await generateObjectArray({\n    runtime,\n    context,\n    modelClass: ModelClass.LARGE,\n  });\n\n  const factsManager = new MemoryManager({\n    runtime,\n    tableName: 'facts',\n  });\n\n  if (!facts) {\n    return [];\n  }\n\n  // If the fact is known or corrupted, remove it\n  const filteredFacts = facts\n    .filter((fact) => {\n      return (\n        !fact.already_known &&\n        fact.type === 'fact' &&\n        !fact.in_bio &&\n        fact.claim &&\n        fact.claim.trim() !== ''\n      );\n    })\n    .map((fact) => fact.claim);\n\n  for (const fact of filteredFacts) {\n    const factMemory = await factsManager.addEmbeddingToMemory({\n      userId: agentId!,\n      agentId,\n      content: { text: fact },\n      roomId,\n      createdAt: Date.now(),\n    });\n\n    await factsManager.createMemory(factMemory, true);\n\n    await new Promise((resolve) => setTimeout(resolve, 250));\n  }\n  return filteredFacts;\n}\n\nexport const factEvaluator: Evaluator = {\n  name: 'GET_FACTS',\n  similes: [\n    'GET_CLAIMS',\n    'EXTRACT_CLAIMS',\n    'EXTRACT_FACTS',\n    'EXTRACT_CLAIM',\n    'EXTRACT_INFORMATION',\n  ],\n  validate: async (\n    runtime: IAgentRuntime,\n\n    message: Memory\n  ): Promise<boolean> => {\n    const messageCount = (await runtime.messageManager.countMemories(message.roomId)) as number;\n\n    const reflectionCount = Math.ceil(runtime.getConversationLength() / 2);\n\n    return messageCount % reflectionCount === 0;\n  },\n  description:\n    'Extract factual information about the people in the conversation, the current events in the world, and anything else that might be important to remember.',\n  handler,\n  examples: [\n    {\n      context: `Actors in the scene:\n{{user1}}: Programmer and moderator of the local story club.\n{{user2}}: New member of the club. Likes to write and read.\n\nFacts about the actors:\nNone`,\n      messages: [\n        {\n          user: '{{user1}}',\n          content: { text: 'So where are you from' },\n        },\n        {\n          user: '{{user2}}',\n          content: { text: \"I'm from the city\" },\n        },\n        {\n          user: '{{user1}}',\n          content: { text: 'Which city?' },\n        },\n        {\n          user: '{{user2}}',\n          content: { text: 'Oakland' },\n        },\n        {\n          user: '{{user1}}',\n          content: {\n            text: \"Oh, I've never been there, but I know it's in California\",\n          },\n        },\n      ] as ActionExample[],\n      outcome: `{ \"claim\": \"{{user2}} is from Oakland\", \"type\": \"fact\", \"in_bio\": false, \"already_known\": false },`,\n    },\n    {\n      context: `Actors in the scene:\n{{user1}}: Athelete and cyclist. Worked out every day for a year to prepare for a marathon.\n{{user2}}: Likes to go to the beach and shop.\n\nFacts about the actors:\n{{user1}} and {{user2}} are talking about the marathon\n{{user1}} and {{user2}} have just started dating`,\n      messages: [\n        {\n          user: '{{user1}}',\n          content: {\n            text: 'I finally completed the marathon this year!',\n          },\n        },\n        {\n          user: '{{user2}}',\n          content: { text: 'Wow! How long did it take?' },\n        },\n        {\n          user: '{{user1}}',\n          content: { text: 'A little over three hours.' },\n        },\n        {\n          user: '{{user1}}',\n          content: { text: \"I'm so proud of myself.\" },\n        },\n      ] as ActionExample[],\n      outcome: `Claims:\njson\\`\\`\\`\n[\n  { \"claim\": \"Alex just completed a marathon in just under 4 hours.\", \"type\": \"fact\", \"in_bio\": false, \"already_known\": false },\n  { \"claim\": \"Alex worked out 2 hours a day at the gym for a year.\", \"type\": \"fact\", \"in_bio\": true, \"already_known\": false },\n  { \"claim\": \"Alex is really proud of himself.\", \"type\": \"opinion\", \"in_bio\": false, \"already_known\": false }\n]\n\\`\\`\\`\n`,\n    },\n    {\n      context: `Actors in the scene:\n{{user1}}: Likes to play poker and go to the park. Friends with Eva.\n{{user2}}: Also likes to play poker. Likes to write and read.\n\nFacts about the actors:\nMike and Eva won a regional poker tournament about six months ago\nMike is married to Alex\nEva studied Philosophy before switching to Computer Science`,\n      messages: [\n        {\n          user: '{{user1}}',\n          content: {\n            text: 'Remember when we won the regional poker tournament last spring',\n          },\n        },\n        {\n          user: '{{user2}}',\n          content: {\n            text: 'That was one of the best days of my life',\n          },\n        },\n        {\n          user: '{{user1}}',\n          content: {\n            text: 'It really put our poker club on the map',\n          },\n        },\n      ] as ActionExample[],\n      outcome: `Claims:\njson\\`\\`\\`\n[\n  { \"claim\": \"Mike and Eva won the regional poker tournament last spring\", \"type\": \"fact\", \"in_bio\": false, \"already_known\": true },\n  { \"claim\": \"Winning the regional poker tournament put the poker club on the map\", \"type\": \"opinion\", \"in_bio\": false, \"already_known\": false }\n]\n\\`\\`\\``,\n    },\n  ],\n};\n"})})]}),"\n",(0,o.jsxs)(n.p,{children:["Source: ",(0,o.jsx)(n.a,{href:"https://github.com/elizaOS/eliza/blob/main/packages/plugin-bootstrap/src/evaluators/fact.ts",children:"https://github.com/elizaOS/eliza/blob/main/packages/plugin-bootstrap/src/evaluators/fact.ts"})]}),"\n",(0,o.jsx)(n.h2,{id:"goal-evaluator",children:"Goal Evaluator"}),"\n",(0,o.jsx)(n.p,{children:"The Goal Evaluator tracks progress on conversation objectives by analyzing messages and updating goal status. Goals are structured like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface Goal {\n  id: string;\n  name: string;\n  status: 'IN_PROGRESS' | 'DONE' | 'FAILED';\n  objectives: Objective[];\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"example-goals",children:"Example Goals"}),"\n",(0,o.jsx)(n.p,{children:"Here's how the goal evaluator processes a conversation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// Initial goal state\nconst goal = {\n  id: 'book-club-123',\n  name: 'Complete reading assignment',\n  status: 'IN_PROGRESS',\n  objectives: [\n    { description: 'Read chapters 1-3', completed: false },\n    { description: 'Take chapter notes', completed: false },\n    { description: 'Share thoughts in book club', completed: false },\n  ],\n};\n\n// Conversation happens\nconst conversation = `\nUser: I finished reading the first three chapters last night\nAgent: Great! Did you take any notes while reading?\nUser: Yes, I made detailed notes about the main characters\nAgent: Perfect, we can discuss those in the club meeting\nUser: I'm looking forward to sharing my thoughts tomorrow\n`;\n\n// Goal evaluator updates the goal status\nconst updatedGoal = {\n  id: 'book-club-123',\n  name: 'Complete reading assignment',\n  status: 'IN_PROGRESS', // Still in progress\n  objectives: [\n    { description: 'Read chapters 1-3', completed: true }, // Marked complete\n    { description: 'Take chapter notes', completed: true }, // Marked complete\n    { description: 'Share thoughts in book club', completed: false }, // Still pending\n  ],\n};\n\n// After the book club meeting, goal would be marked DONE\n// If user can't complete objectives, goal could be marked FAILED\n"})}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"View Full Goal Evaluator Implementation"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { composeContext } from "@elizaos/core";\nimport { generateText } from "@elizaos/core";\nimport { getGoals } from "@elizaos/core";\nimport { parseJsonArrayFromText } from "@elizaos/core";\nimport {\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type Objective,\n    type Goal,\n    type State,\n    type Evaluator,\n} from "@elizaos/core";\n\nconst goalsTemplate = `TASK: Update Goal\nAnalyze the conversation and update the status of the goals based on the new information provided.\n\n# INSTRUCTIONS\n\n- Review the conversation and identify any progress towards the objectives of the current goals.\n- Update the objectives if they have been completed or if there is new information about them.\n- Update the status of the goal to \'DONE\' if all objectives are completed.\n- If no progress is made, do not change the status of the goal.\n\n# START OF ACTUAL TASK INFORMATION\n\n{{goals}}\n{{recentMessages}}\n\nTASK: Analyze the conversation and update the status of the goals based on the new information provided. Respond with a JSON array of goals to update.\n\n- Each item must include the goal ID, as well as the fields in the goal to update.\n- For updating objectives, include the entire objectives array including unchanged fields.\n- Only include goals which need to be updated.\n- Goal status options are \'IN_PROGRESS\', \'DONE\' and \'FAILED\'. If the goal is active it should always be \'IN_PROGRESS\'.\n- If the goal has been successfully completed, set status to DONE. If the goal cannot be completed, set status to FAILED.\n- If those goal is still in progress, do not include the status field.\n\nResponse format should be:\n\\`\\`\\`json\n[\n{\n"id": <goal uuid>, // required\n"status": "IN_PROGRESS" | "DONE" | "FAILED", // optional\n"objectives": [ // optional\n{ "description": "Objective description", "completed": true | false },\n{ "description": "Objective description", "completed": true | false }\n] // NOTE: If updating objectives, include the entire objectives array including unchanged fields.\n}\n]\n\\`\\`\\``;\n\nasync function handler(\nruntime: IAgentRuntime,\nmessage: Memory,\nstate: State | undefined,\noptions: { [key: string]: unknown } = { onlyInProgress: true }\n): Promise<Goal[]> {\nstate = (await runtime.composeState(message)) as State;\nconst context = composeContext({\nstate,\ntemplate: runtime.character.templates?.goalsTemplate || goalsTemplate,\n});\n\n    // Request generateText from OpenAI to analyze conversation and suggest goal updates\n    const response = await generateText({\n        runtime,\n        context,\n        modelClass: ModelClass.LARGE,\n    });\n\n    // Parse the JSON response to extract goal updates\n    const updates = parseJsonArrayFromText(response);\n\n    // get goals\n    const goalsData = await getGoals({\n        runtime,\n        roomId: message.roomId,\n        onlyInProgress: options.onlyInProgress as boolean,\n    });\n\n    // Apply the updates to the goals\n    const updatedGoals = goalsData\n        .map((goal: Goal): Goal => {\n            const update = updates?.find((u) => u.id === goal.id);\n            if (update) {\n                // Merge the update into the existing goal\n                return {\n                    ...goal,\n                    ...update,\n                    objectives: goal.objectives.map((objective) => {\n                        const updatedObjective = update.objectives?.find(uo => uo.description === objective.description);\n                        return updatedObjective ? { ...objective, ...updatedObjective } : objective;\n                    }),\n                };\n            }\n            return null; // No update for this goal\n        })\n        .filter(Boolean);\n\n    // Update goals in the database\n    for (const goal of updatedGoals) {\n        const id = goal.id;\n        // delete id from goal\n        if (goal.id) delete goal.id;\n        await runtime.databaseAdapter.updateGoal({ ...goal, id });\n    }\n\n    return updatedGoals; // Return updated goals for further processing or logging\n\n}\n\nexport const goalEvaluator: Evaluator = {\nname: "UPDATE_GOAL",\nsimiles: [\n"UPDATE_GOALS",\n"EDIT_GOAL",\n"UPDATE_GOAL_STATUS",\n"UPDATE_OBJECTIVES",\n],\nvalidate: async (\nruntime: IAgentRuntime,\nmessage: Memory\n): Promise<boolean> => {\n// Check if there are active goals that could potentially be updated\nconst goals = await getGoals({\nruntime,\ncount: 1,\nonlyInProgress: true,\nroomId: message.roomId,\n});\nreturn goals.length > 0;\n},\ndescription:\n"Analyze the conversation and update the status of the goals based on the new information provided.",\nhandler,\nexamples: [\n{\ncontext: `Actors in the scene:\n{{user1}}: An avid reader and member of a book club.\n{{user2}}: The organizer of the book club.\n\nGoals:\n\n- Name: Finish reading "War and Peace"\n  id: 12345-67890-12345-67890\n  Status: IN_PROGRESS\n  Objectives: - Read up to chapter 20 by the end of the month - Discuss the first part in the next meeting`,\n\n            messages: [\n                {\n                    user: "{{user1}}",\n                    content: {\n                        text: "I\'ve just finished chapter 20 of \'War and Peace\'",\n                    },\n                },\n                {\n                    user: "{{user2}}",\n                    content: {\n                        text: "Were you able to grasp the complexities of the characters",\n                    },\n                },\n                {\n                    user: "{{user1}}",\n                    content: {\n                        text: "Yep. I\'ve prepared some notes for our discussion",\n                    },\n                },\n            ],\n\n            outcome: `[\n        {\n          "id": "12345-67890-12345-67890",\n          "status": "DONE",\n          "objectives": [\n            { "description": "Read up to chapter 20 by the end of the month", "completed": true },\n            { "description": "Prepare notes for the next discussion", "completed": true }\n          ]\n        }\n      ]`,\n        },\n\n        {\n            context: `Actors in the scene:\n\n  {{user1}}: A fitness enthusiast working towards a marathon.\n  {{user2}}: A personal trainer.\n\nGoals:\n\n- Name: Complete a marathon\n  id: 23456-78901-23456-78901\n  Status: IN_PROGRESS\n  Objectives: - Increase running distance to 30 miles a week - Complete a half-marathon as practice`,\n\n            messages: [\n                {\n                    user: "{{user1}}",\n                    content: { text: "I managed to run 30 miles this week" },\n                },\n                {\n                    user: "{{user2}}",\n                    content: {\n                        text: "Impressive progress! How do you feel about the half-marathon next month?",\n                    },\n                },\n                {\n                    user: "{{user1}}",\n                    content: {\n                        text: "I feel confident. The training is paying off.",\n                    },\n                },\n            ],\n\n            outcome: `[\n        {\n          "id": "23456-78901-23456-78901",\n          "objectives": [\n            { "description": "Increase running distance to 30 miles a week", "completed": true },\n            { "description": "Complete a half-marathon as practice", "completed": false }\n          ]\n        }\n      ]`,\n        },\n\n        {\n            context: `Actors in the scene:\n\n  {{user1}}: A student working on a final year project.\n  {{user2}}: The project supervisor.\n\nGoals:\n\n- Name: Finish the final year project\n  id: 34567-89012-34567-89012\n  Status: IN_PROGRESS\n  Objectives: - Submit the first draft of the thesis - Complete the project prototype`,\n\n              messages: [\n                  {\n                      user: "{{user1}}",\n                      content: {\n                          text: "I\'ve submitted the first draft of my thesis.",\n                      },\n                  },\n                  {\n                      user: "{{user2}}",\n                      content: {\n                          text: "Well done. How is the prototype coming along?",\n                      },\n                  },\n                  {\n                      user: "{{user1}}",\n                      content: {\n                          text: "It\'s almost done. I just need to finalize the testing phase.",\n                      },\n                  },\n              ],\n\n              outcome: `[\n          {\n            "id": "34567-89012-34567-89012",\n            "objectives": [\n              { "description": "Submit the first draft of the thesis", "completed": true },\n              { "description": "Complete the project prototype", "completed": false }\n            ]\n          }\n        ]`,\n          },\n\n          {\n              context: `Actors in the scene:\n          {{user1}}: A project manager working on a software development project.\n          {{user2}}: A software developer in the project team.\n\n          Goals:\n          - Name: Launch the new software version\n            id: 45678-90123-45678-90123\n            Status: IN_PROGRESS\n            Objectives:\n              - Complete the coding for the new features\n              - Perform comprehensive testing of the software`,\n\n              messages: [\n                  {\n                      user: "{{user1}}",\n                      content: {\n                          text: "How\'s the progress on the new features?",\n                      },\n                  },\n                  {\n                      user: "{{user2}}",\n                      content: {\n                          text: "We\'ve encountered some unexpected challenges and are currently troubleshooting.",\n                      },\n                  },\n                  {\n                      user: "{{user1}}",\n                      content: {\n                          text: "Let\'s move on and cancel the task.",\n                      },\n                  },\n              ],\n\n              outcome: `[\n          {\n            "id": "45678-90123-45678-90123",\n            "status": "FAILED"\n        ]`,\n          },\n      ],\n\n  };\n\n'})})]}),"\n",(0,o.jsxs)(n.p,{children:["Source: ",(0,o.jsx)(n.a,{href:"https://github.com/elizaOS/eliza/blob/main/packages/plugin-bootstrap/src/evaluators/goals.ts",children:"https://github.com/elizaOS/eliza/blob/main/packages/plugin-bootstrap/src/evaluators/goals.ts"})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,o.jsx)(n.h3,{id:"how-do-evaluators-differ-from-providers",children:"How do evaluators differ from providers?"}),"\n",(0,o.jsxs)(n.p,{children:["While ",(0,o.jsx)(n.a,{href:"/api/interfaces/Provider",children:"providers"})," supply data to the agent before responses, evaluators analyze conversations after responses. Providers inform decisions, evaluators learn from outcomes."]}),"\n",(0,o.jsx)(n.h3,{id:"can-evaluators-modify-agent-behavior",children:"Can evaluators modify agent behavior?"}),"\n",(0,o.jsx)(n.p,{children:"Evaluators can influence future behavior by storing insights in memory, but cannot directly modify agent responses or interrupt ongoing actions."}),"\n",(0,o.jsx)(n.h3,{id:"how-many-evaluators-can-run-simultaneously",children:"How many evaluators can run simultaneously?"}),"\n",(0,o.jsx)(n.p,{children:"There's no hard limit, but each evaluator adds processing overhead. Focus on essential evaluations and use efficient validation to optimize performance."}),"\n",(0,o.jsx)(n.h3,{id:"can-evaluators-communicate-with-each-other",children:"Can evaluators communicate with each other?"}),"\n",(0,o.jsx)(n.p,{children:"Evaluators don't directly communicate but can share data through the memory system. One evaluator can read insights stored by another."}),"\n",(0,o.jsx)(n.h3,{id:"how-are-evaluation-results-persisted",children:"How are evaluation results persisted?"}),"\n",(0,o.jsxs)(n.p,{children:["Results are stored using the runtime's memory managers with embeddings for efficient retrieval. See the ",(0,o.jsx)(n.a,{href:"/api/interfaces/IMemoryManager",children:(0,o.jsx)(n.code,{children:"IMemoryManager"})})," interface for details."]}),"\n",(0,o.jsx)(n.h3,{id:"whats-the-difference-between-similes-and-examples-in-evaluators",children:"What's the difference between similes and examples in evaluators?"}),"\n",(0,o.jsx)(n.p,{children:"Similes provide alternative descriptions of the evaluator's purpose, while examples show concrete scenarios with inputs and expected outcomes. Examples help verify correct implementation."}),"\n",(0,o.jsx)(n.h3,{id:"can-evaluators-be-conditionally-enabled",children:"Can evaluators be conditionally enabled?"}),"\n",(0,o.jsx)(n.p,{children:"Yes, use the validation function to control when evaluators run. This can be based on message content, user status, or other runtime conditions."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var a=t(14041);const o={},s=a.createContext(o);function r(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);